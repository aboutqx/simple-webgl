(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{44:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n(0);class s{constructor(e,t){this._mesh=e,this._shader=t}draw(e){this._shader.bind(),this._shader.style(e),r.a.draw(this._mesh)}get mesh(){return this._mesh}get shader(){return this._shader}}},45:function(e,t,n){"use strict";var r=n(0),s=n(3);let i,o;t.a=class{constructor(e,t,n={},s=1){i=!window.useWebgl2&&r.c.getExtension("WEBGL_depth_texture"),this.width=e||r.b.width,this.height=t||r.b.height,this._numTargets=s,this._multipleTargets=s>1,1==n.hdr?this._parameters={internalFormat:r.c.RGBA16F,type:r.c.HALF_FLOAT,minFilter:n.minFilter,maxFilter:n.magFilter}:this._parameters=n,window.useWebgl2||(o=r.c.getExtension("WEBGL_draw_buffers")),this._multipleTargets&&this._checkMaxNumRenderTarget(),this._init()}_init(){if(this._initTextures(),this.frameBuffer=r.c.createFramebuffer(),r.c.bindFramebuffer(r.c.FRAMEBUFFER,this.frameBuffer),window.useWebgl2){if(0===this._numTargets)r.c.readBuffer(r.c.NONE),r.c.drawBuffers([r.c.NONE]);else{const e=[];for(let t=0;t<this._numTargets;t++)r.c.framebufferTexture2D(r.c.DRAW_FRAMEBUFFER,r.c.COLOR_ATTACHMENT0+t,r.c.TEXTURE_2D,this._textures[t].texture,0),e.push(r.c["COLOR_ATTACHMENT"+t]);r.c.drawBuffers(e)}r.c.framebufferTexture2D(r.c.DRAW_FRAMEBUFFER,r.c.DEPTH_ATTACHMENT,r.c.TEXTURE_2D,this.glDepthTexture.texture,0)}else{for(let e=0;e<this._numTargets;e++)r.c.framebufferTexture2D(r.c.FRAMEBUFFER,r.c.COLOR_ATTACHMENT0+e,r.c.TEXTURE_2D,this._textures[e].texture,0);if(this._multipleTargets){const e=[];for(let t=0;t<this._numTargets;t++)e.push(o[`COLOR_ATTACHMENT${t}_WEBGL`]);o.drawBuffersWEBGL(e)}i&&r.c.framebufferTexture2D(r.c.FRAMEBUFFER,r.c.DEPTH_ATTACHMENT,r.c.TEXTURE_2D,this.glDepthTexture.texture,0)}r.c.checkFramebufferStatus(r.c.FRAMEBUFFER)!=r.c.FRAMEBUFFER_COMPLETE&&console.log("gl.checkFramebufferStatus() returned "+status.toString(16)),r.c.bindTexture(r.c.TEXTURE_2D,null),r.c.bindRenderbuffer(r.c.RENDERBUFFER,null),r.c.bindFramebuffer(r.c.FRAMEBUFFER,null),this.clear()}_checkMaxNumRenderTarget(){const e=window.useWebgl2?r.c.getParameter(r.c.MAX_DRAW_BUFFERS):r.c.getParameter(o.MAX_DRAW_BUFFERS_WEBGL);this._numTargets>e&&(console.error("Over max number of draw buffers supported : ",e),this._numTargets=e)}_initTextures(){this._textures=[];for(let e=0;e<this._numTargets;e++){const e=this._createTexture();this._textures.push(e)}window.useWebgl2?this.glDepthTexture=this._createTexture(r.c.DEPTH_COMPONENT16,r.c.UNSIGNED_SHORT,r.c.DEPTH_COMPONENT,{minFilter:r.c.NEAREST,magFilter:r.c.NEAREST}):this.glDepthTexture=this._createTexture(r.c.DEPTH_COMPONENT,r.c.UNSIGNED_SHORT,r.c.DEPTH_COMPONENT,{minFilter:r.c.LINEAR})}_createTexture(e,t,n,i={}){const o=Object.assign({},this._parameters);o.internalFormat=e||o.internalFormat,o.format=n||o.format||r.c.RGBA,o.type=t||o.type||r.c.UNSIGNED_BYTE;for(const e in i)o[e]=i[e];return new s.a(null,o,this.width,this.height)}bind(e=!0){e&&r.c.viewport(0,0,this.width,this.height),r.c.bindFramebuffer(r.c.FRAMEBUFFER,this.frameBuffer),r.a.clear(0,0,0,1)}unbind(e=!0){e&&r.c.viewport(0,0,r.b.width,r.b.height),r.c.bindFramebuffer(r.c.FRAMEBUFFER,null),this._textures.forEach(e=>{e.generateMipmap()})}clear(e=0,t=0,n=0,s=0){this.bind(),r.a.clear(e,t,n,s),this.unbind()}get textures(){return this._textures}getTexture(e=0){return this._textures[e]}get depthTexture(){return this.glDepthTexture}get minFilter(){return this._textures[0].minFilter}set minFilter(e){this._textures.forEach(t=>{t.minFilter=e})}get magFilter(){return this._textures[0].magFilter}set magFilter(e){this._textures.forEach(t=>{t.magFilter=e})}get wrapS(){return this._textures[0].wrapS}set wrapS(e){this._textures.forEach(t=>{t.wrapS=e})}get wrapT(){return this._textures[0].wrapT}set wrapT(e){this._textures.forEach(t=>{t.wrapT=e})}showParameters(){this._textures[0].showParameters()}get numTargets(){return this._numTargets}}},46:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));var r=n(13),s=n(15),i=n(42),o=n(44);class a extends o.a{constructor(e){const t=new s.a(r.c,e);super(i.a.bigTriangle(),t)}draw(e){super.draw(e)}}},66:function(e,t,n){"use strict";var r=n(57),s=n(1);class i extends r.a{constructor(){super();const e=s.e.clone([0,0,5]),t=s.e.create(),n=s.e.clone([0,1,0]);this.lookAt(e,t,n),this.ortho(-1,1,1,-1)}setBoundary(e,t,n,r,s=.1,i=100){this.ortho(e,t,n,r,s,i)}ortho(e,t,n,r,i=.1,o=100){this.left=e,this.right=t,this.top=n,this.bottom=r,s.b.ortho(this._projection,e,t,r,n,i,o)}}t.a=i},90:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return v}));var r=n(2),s=n(43),i=n(4),o=n(45),a=n(0),c=n(46),u=n(66),x=n(71);const h=function(e,t){return e+Math.random()*(t-e)};class v extends s.a{constructor(){super(),Object(r.a)(this,"_count",0)}init(){this.saveprg=this.compile("#version 300 es\n// save.vert\n\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nin vec3 normal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nout vec2 vTexCoord;\nout vec3 vColor;\nout vec3 vNormal;\n\nvoid main(void) {\n\tvColor      = position;\n\tvec3 pos    = vec3(texCoord, 0.0);\n\tgl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\n    gl_PointSize = 1.0;\n    vNormal = normal;\n}","#version 300 es\n// save.frag\n\nprecision highp float;\n#define GLSLIFY 1\n\nin vec3 vColor;\nout vec4 FragColor;\nvoid main(void) {\n    FragColor = vec4(vColor, 1.0);\n}"),this.renderPrg=this.compile("#version 300 es\n// render.vert\n\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform sampler2D texture0;\nuniform sampler2D textureNext;\nuniform float percent;\nout vec4 vColor;\nout vec3 vNormal;\n\nvoid main(void) {\n\tvec2 uv      = position.xy * .5;\n\tvec3 currPos = texture(texture0, uv).rgb;\n\tvec3 nextPos = texture(textureNext, uv).rgb;\n\tvec3 pos     = mix(currPos, nextPos, percent);\n\tvec4 V       = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\tgl_Position  = V;\n\tgl_PointSize = 1.2;\n\n\tfloat d \t = V.z/V.w;\n\td \t\t\t = d*.5 + .5;\n\tvColor       = vec4(d, d, d, 1.0);\n\n\tif(length(currPos) - length(nextPos) > 1.0) vColor.a = 0.0;\n\tvNormal = normal;\n}","#version 300 es\n// render.frag\n\nprecision highp float;\n#define GLSLIFY 1\n\nin vec4 vColor;\nout vec4 FragColor;\n\nvoid main(void) {\n\tif(vColor.a <= 0.01) {\n\t\tdiscard;\n\t}\n    FragColor = vColor;\n}"),window.params={gamma:2.2,exposure:5,numParticles:20,skipCount:3},this._vSim=new c.a("#version 300 es\n// sim.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nin vec2 vTexCoord;\nout vec4 FragColor;\nuniform sampler2D texture0;\nuniform float time;\nuniform float skipCount;\nuniform vec2 mousePos;\n\nvec3 mod289(vec3 x) {\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\t}\n\nvec4 mod289(vec4 x) {\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\t}\n\nvec4 permute(vec4 x) {\treturn mod289(((x*34.0)+1.0)*x);\t}\n\nvec4 taylorInvSqrt(vec4 r) {\treturn 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v) { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ){\n\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n\n}\n\nvec3 curlNoise( vec3 p ){\n  \n  const float e = .1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n\n}\n\nvoid main(void) {\n\n    if(vTexCoord.y < .5) {\n    \tif(vTexCoord.x < .5) {\n        vec2 uvVel   = vTexCoord + vec2(.5, .0);\n        vec2 uvExtra = vTexCoord + vec2(.5, .5);\n        vec3 pos     = texture(texture0, vTexCoord).rgb;\n        vec3 vel     = texture(texture0, uvVel).rgb;\n        vec3 extra   = texture(texture0, uvExtra).rgb;\n    \t\tpos += vel;\n    \t\t// \n    \t\t// if(length(pos) > maxRadius) {\n    \t\t// \t// pos *= .001;\n      //     pos = curlNoise(pos*extra) * .1 * extra.b;\n    \t\t// }\n    \t\tFragColor = vec4(pos, 1.0);\n\t\t} else {\n\t\t\t\n      vec2 uvPos      = vTexCoord - vec2(.5, .0);\n      vec2 uvExtra    = vTexCoord + vec2(-.5, .5);\n      vec3 pos        = texture(texture0, uvPos).rgb;\n      vec3 vel        = texture(texture0, vTexCoord).rgb;\n      vec3 extra      = texture(texture0, uvExtra).rgb;\n      float posOffset = (0.5 + extra.r * 0.25) * .35;\n\n\t\t\t/*/\n\t\t\tfloat ax = snoise(pos.xyz * posOffset + time * .1);\n\t\t\tfloat ay = snoise(pos.yzx * posOffset + time * .01);\n\t\t\tfloat az = snoise(pos.zxy * posOffset + time * .001);\n\t\t\tvec3 acc = vec3(ax, ay, az);\n\t\t\t/*/\n\t\t\tvec3 acc = curlNoise(pos * posOffset + time * .3);\n      // acc.z += .1;\n \n\t\t\t//*/\n\n      const float maxRadius = 0.75;\n      float d = length(pos);\n      if(d > maxRadius) {\n        vec3 dir = normalize(pos);\n        float f = d * .21;\n        acc -= dir * f;\n      }\n\n\t\t\tvel += acc * .003 * (skipCount+1.0);\n      vel.xy -= (mousePos.xy - .5) * .02;\n\t\t\tconst float decrease = .9;\n\t\t\tvel *= decrease;\n\n\t\t\tFragColor = vec4(vel, 1.0);\n\t\t}\n\t} else {\n\t\tFragColor = texture(texture0, vTexCoord);\n\t}\n}"),a.a.applyHdrExtension();const e=params.numParticles,t={minFilter:a.c.NEAREST,magFilter:a.c.NEAREST,hdr:!0};this._fboCurrent=new o.a(2*e,2*e,t),this._fboTarget=new o.a(2*e,2*e,t),this.cameraOrtho=new u.a,this.orbital.radius=10,this.orbital.updateMatrix(),this.orbital.destroy()}_setGUI(){}attrib(){this._initRender(),this._initSave(),this.mousePos={x:0,y:0},x.a.addEvents(null,e=>x.a.getPos(e,this.mousePos))}prepare(){this.time=255*Math.random(),a.a.srcBlend(),a.a.setCamera(this.cameraOrtho),this._fboCurrent.bind(),a.a.clear(0,0,0,0),this._renderSave(),this._fboCurrent.unbind(),a.c.viewport(0,0,a.b.width,a.b.height),a.a.setCamera(this.camera)}_initRender(){const e=[],t=[];let n=0;const r=params.numParticles;let s,o;for(let i=0;i<r;i++)for(let a=0;a<r;a++)s=a/r,o=i/r,e.push([s,o,0]),t.push(n),n++;this.mesh=new i.a(a.c.POINTS),this.mesh.bufferVertex(e),this.mesh.bufferIndex(t)}_initSave(){const e=[],t=[],n=[];let r=0;const s=params.numParticles;let o,c;for(let i=0;i<s;i++)for(let a=0;a<s;a++)e.push([h(-1.5,1.5),h(-1.5,1.5),h(-1.5,1.5)]),o=a/s-1+.5/s,c=i/s-1+.5/s,t.push([o,c]),n.push(r),r++,e.push([Math.random(),Math.random(),Math.random()]),t.push([o,c+1]),n.push(r),r++;this.saveMesh=new i.a(a.c.POINTS),this.saveMesh.bufferVertex(e),this.saveMesh.bufferTexCoord(t),this.saveMesh.bufferIndex(n)}_render(e,t,n){this.renderPrg.bind(),this.renderPrg.style({texture0:e,textureNext:t,percent:n}),a.a.draw(this.mesh)}_renderSave(){this.saveprg.use(),a.a.draw(this.saveMesh)}_renderSim(e){this.time+=.01,this._vSim.draw({texture0:e,time:this.time,skipCount:params.skipCount,mousePos:[this.mousePos.x/a.b.width,this.mousePos.y/a.b.height]})}updateFbo(){a.a.setCamera(this.cameraOrtho),this._fboTarget.bind(),a.a.clear(0,0,0,0),this._renderSim(this._fboCurrent.getTexture()),this._fboTarget.unbind(),a.a.setCamera(this.camera);var e=this._fboTarget;this._fboTarget=this._fboCurrent,this._fboCurrent=e}render(){a.a.clear();let e=0;this._count%params.skipCount==0&&(this._count=0,this.updateFbo()),e=this._count/params.skipCount,this._count++,a.a.setCamera(this.camera),this._render(this._fboTarget.getTexture(),this._fboCurrent.getTexture(),e),this.frameBufferGUI.textureList=[{texture:this._fboTarget.getTexture(0)}]}}}}]);