(window.webpackJsonp=window.webpackJsonp||[]).push([[5,23],{10:function(e,t,n){"use strict";const r="#\\?RADIANCE",o="#.*",a="EXPOSURE=\\s*([0-9]*[.][0-9]*)",i="FORMAT=32-bit_rle_rgbe",s="-Y ([0-9]+) \\+X ([0-9]+)";t.a=function(e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));let t=0;const n=e.length,l=10;function d(){let r="";do{const n=e[t];if(n===l){++t;break}r+=String.fromCharCode(n)}while(++t<n);return r}let c=0,u=0,h=1,f=!1;for(let e=0;e<20;e++){const e=d();let t;if(t=e.match(r));else if(t=e.match(i))f=!0;else if(t=e.match(a))h=Number(t[1]);else if(t=e.match(o));else if(t=e.match(s)){u=Number(t[1]),c=Number(t[2]);break}}if(!f)throw new Error("File is not run length encoded!");const m=new Uint8Array(c*u*4);!function(e,t,n,r,o,a){const i=new Array(4);let s,l,d,c=null;const u=new Array(2),h=e.length;function f(t){let n=0;do{t[n++]=e[r]}while(++r<h&&n<t.length);return n}function m(t,n,o){let a=0;do{t[n+a++]=e[r]}while(++r<h&&a<o);return a}function p(e,t,n,r){const o=4*r,a=m(t,n,o);if(a<o)throw new Error(`Error reading raw pixels: got ${a} bytes, expected ${o}`)}for(;a>0;){if(f(i)<i.length)throw new Error(`Error reading bytes: expected ${i.length}`);if(2!==i[0]||2!==i[1]||0!=(128&i[2]))return t[n++]=i[0],t[n++]=i[1],t[n++]=i[2],t[n++]=i[3],void p(0,t,n,o*a-1);if(((255&i[2])<<8|255&i[3])!==o)throw new Error(`Wrong scanline width ${(255&i[2])<<8|255&i[3]}, expected ${o}`);null===c&&(c=new Array(4*o)),s=0;for(let e=0;e<4;e++)for(l=(e+1)*o;s<l;){if(f(u)<u.length)throw new Error("Error reading 2-byte buffer");if((255&u[0])>128){if(0==(d=(255&u[0])-128)||d>l-s)throw new Error("Bad scanline data");for(;d-- >0;)c[s++]=u[1]}else{if(0==(d=255&u[0])||d>l-s)throw new Error("Bad scanline data");if(c[s++]=u[1],--d>0){if(m(c,s,d)<d)throw new Error("Error reading non-run data");s+=d}}}for(let e=0;e<o;e++)t[n+0]=c[e],t[n+1]=c[e+o],t[n+2]=c[e+2*o],t[n+3]=c[e+3*o],n+=4;a--}}(e,m,0,t,c,u);const p=new Float32Array(c*u*4);for(let e=0;e<m.length;e+=4){let t=m[e+0]/255,n=m[e+1]/255,r=m[e+2]/255;const o=m[e+3],a=Math.pow(2,o-128);t*=a,n*=a,r*=a;const i=e;p[i+0]=t,p[i+1]=n,p[i+2]=r,p[i+3]=1}return{shape:[c,u],exposure:h,gamma:1,data:p}}},12:function(e,t){function n(e){if(this.gl=e,void 0!==e.bindVertexArray)this._impl=new r(this);else{var t=e.getExtension("OES_vertex_array_object");t?(!function(e,t){e.bindVertexArray=function(){return t.bindVertexArrayOES.apply(t,arguments)},e.createVertexArray=function(){return t.createVertexArrayOES.apply(t,arguments)},e.deleteVertexArray=function(){return t.deleteVertexArrayOES.apply(t,arguments)},e.isVertexArray=function(){return t.isVertexArrayOES.apply(t,arguments)}}(e,t),this._impl=new r(this)):this._impl=new o(this)}}function r(e){this._vao=e,this._handle=null}function o(e){this._vao=e}n.prototype={dispose:function(){this._impl.dispose(),this._impl=null},setup:function(e,t,n){e.ready||e._grabParameters(),this._impl.setup(e,t,n)},bind:function(){this._impl.bind()},unbind:function(){this._impl.unbind()}},r.prototype={dispose:function(){this.release(),this._vao=null},setup:function(e,t,n){this.release();var r=this._vao.gl;this._handle=r.createVertexArray(),r.bindVertexArray(this._handle);for(var o=0;o<t.length;o++)t[o].attribPointer(e);void 0!==n&&n.bind(),r.bindVertexArray(null)},bind:function(){this._vao.gl.bindVertexArray(this._handle)},unbind:function(){this._vao.gl.bindVertexArray(null)},release:function(){this._handle&&(this._vao.gl.deleteVertexArray(this._handle),this._handle=null)}},o.prototype={dispose:function(){this._vao=null,this.prg=null,this.buffers=null,this.indices=null},setup:function(e,t,n){this.prg=e,this.buffers=t,this.indices=n},bind:function(){for(var e=0;e<this.buffers.length;e++)this.buffers[e].attribPointer(this.prg);void 0!==this.indices&&this.indices.bind()},unbind:function(){}},e.exports=n},13:function(e,t,n){"use strict";var r=n(0),o=n(37),a=n.n(o);class i{constructor(e,t={},n=!1){if(n)return void(this.texture=e);let o=e.length>6;e[0].mipmapCount&&(o=e[0].mipmapCount>1),this.texture=r.d.createTexture(),this.magFilter=t.magFilter||r.d.LINEAR,this.minFilter=t.minFilter||r.d.LINEAR_MIPMAP_LINEAR,this.wrapS=t.wrapS||r.d.CLAMP_TO_EDGE,this.wrapT=t.wrapT||r.d.CLAMP_TO_EDGE,o||this.minFilter!=r.d.LINEAR_MIPMAP_LINEAR||(this.minFilter=r.d.LINEAR),r.d.bindTexture(r.d.TEXTURE_CUBE_MAP,this.texture);const a=[r.d.TEXTURE_CUBE_MAP_POSITIVE_X,r.d.TEXTURE_CUBE_MAP_NEGATIVE_X,r.d.TEXTURE_CUBE_MAP_POSITIVE_Y,r.d.TEXTURE_CUBE_MAP_NEGATIVE_Y,r.d.TEXTURE_CUBE_MAP_POSITIVE_Z,r.d.TEXTURE_CUBE_MAP_NEGATIVE_Z];let i=1,s=0;if(i=e.length/6,this.numLevels=i,o)for(let t=0;t<6;t++)for(let n=0;n<i;n++)r.d.pixelStorei(r.d.UNPACK_FLIP_Y_WEBGL,!1),e[s=t*i+n].shape?window.useWebgl2?r.d.texImage2D(a[t],n,r.d.RGBA16F,e[s].shape[0],e[s].shape[1],0,r.d.RGBA,r.d.FLOAT,e[s].data):r.d.texImage2D(a[t],n,r.d.RGBA,e[s].shape[0],e[s].shape[1],0,r.d.RGBA,r.d.FLOAT,e[s].data):r.d.texImage2D(a[t],n,r.d.RGBA,r.d.RGBA,r.d.UNSIGNED_BYTE,e[s]),r.d.texParameteri(r.d.TEXTURE_CUBE_MAP,r.d.TEXTURE_WRAP_S,this.wrapS),r.d.texParameteri(r.d.TEXTURE_CUBE_MAP,r.d.TEXTURE_WRAP_T,this.wrapT),r.d.texParameteri(r.d.TEXTURE_CUBE_MAP,r.d.TEXTURE_MAG_FILTER,this.magFilter),r.d.texParameteri(r.d.TEXTURE_CUBE_MAP,r.d.TEXTURE_MIN_FILTER,this.minFilter);else{let t=0;for(let n=0;n<6;n++)t=n*i,r.d.pixelStorei(r.d.UNPACK_FLIP_Y_WEBGL,!1),e[t].shape?window.useWebgl2?r.d.texImage2D(a[n],0,r.d.RGBA16F,e[t].shape[0],e[t].shape[1],0,r.d.RGBA,r.d.FLOAT,e[t].data):r.d.texImage2D(a[n],0,r.d.RGBA,e[t].shape[0],e[t].shape[1],0,r.d.RGBA,r.d.FLOAT,e[t].data):r.d.texImage2D(a[n],0,r.d.RGBA,r.d.RGBA,r.d.UNSIGNED_BYTE,e[t]),r.d.texParameteri(r.d.TEXTURE_CUBE_MAP,r.d.TEXTURE_WRAP_S,this.wrapS),r.d.texParameteri(r.d.TEXTURE_CUBE_MAP,r.d.TEXTURE_WRAP_T,this.wrapT),r.d.texParameteri(r.d.TEXTURE_CUBE_MAP,r.d.TEXTURE_MAG_FILTER,this.magFilter),r.d.texParameteri(r.d.TEXTURE_CUBE_MAP,r.d.TEXTURE_MIN_FILTER,this.minFilter);r.d.generateMipmap(r.d.TEXTURE_CUBE_MAP)}r.d.bindTexture(r.d.TEXTURE_CUBE_MAP,null)}bind(e=0){r.d.activeTexture(r.d.TEXTURE0+e),r.d.bindTexture(r.d.TEXTURE_CUBE_MAP,this.texture),this._bindIndex=e}unbind(){r.d.bindTexture(r.d.TEXTURE_CUBE_MAP,null)}}i.parseDDS=function(e){const t=a()(e),{flags:n}=t;console.log("ddsInfos",t);const r=new Int32Array(e,0,31);let o=1;131072&n&&(o=Math.max(1,r[7]));const s=t.images.map(t=>{return{data:new Float32Array(e.slice(t.offset,t.offset+t.length)),shape:t.shape,mipmapCount:o}});return new i(s)},t.a=i},26:function(e,t){e.exports="precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"},27:function(e,t){e.exports="#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\n#define GLSLIFY 1\n// material map\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture2D(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture2D(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture2D(metallicMap, TexCoords).r;\n    float roughness = texture2D(roughnessMap, TexCoords).r;\n    float ao        = texture2D(aoMap, TexCoords).r;\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"},35:function(e,t){e.exports="#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 WorldPos;\nvarying vec2 vUv;\nvoid main(void){\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  WorldPos = pos.xyz;\n  vUv = texCoord;\n}\n"},37:function(e,t){var n=542327876,r=131072,o=4,a=P("DXT1"),i=P("DXT3"),s=P("DXT5"),l=P("DX10"),d=116,c=512,u=3,h=2,f=31,m=0,p=1,v=2,g=3,E=4,T=7,_=20,x=21,b=28;function P(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}e.exports=function(e){var t,P,A=new Int32Array(e,0,f);if(A[m]!==n)throw new Error("Invalid magic number in DDS header");if(!A[_]&o)throw new Error("Unsupported format, must contain a FourCC code");var F=A[x];switch(F){case a:t=8,P="dxt1";break;case i:t=16,P="dxt3";break;case s:t=16,P="dxt5";break;case d:P="rgba32f";break;case l:var M=new Uint32Array(e.slice(128,148));P=M[0];var N=M[1];M[2],M[3],M[4];if(N!==u||P!==h)throw new Error("Unsupported DX10 texture format "+P);P="rgba32f";break;default:throw new Error("Unsupported FourCC code: "+function(e){return String.fromCharCode(255&e,e>>8&255,e>>16&255,e>>24&255)}(F))}var R=A[v],U=1;R&r&&(U=Math.max(1,A[T]));var C=!1;A[b]&c&&(C=!0);var y,w=A[E],L=A[g],B=A[p]+4,I=w,V=L,D=[];F===l&&(B+=20);if(C)for(var S=0;S<6;S++){if("rgba32f"!==P)throw new Error("Only RGBA32f cubemaps are supported");w=I,L=V;for(var G=Math.log(w)/Math.log(2)+1,X=0;X<G;X++)y=w*L*16,D.push({offset:B,length:y,shape:[w,L]}),X<U&&(B+=y),w=Math.floor(w/2),L=Math.floor(L/2)}else for(var X=0;X<U;X++)y=Math.max(4,w)/4*Math.max(4,L)/4*t,D.push({offset:B,length:y,shape:[w,L]}),B+=y,w=Math.floor(w/2),L=Math.floor(L/2);return{shape:[I,V],images:D,format:P,flags:R,cubemap:C}}},59:function(e,t,n){"use strict";n.r(t);var r=n(8),o=n(2),a=n(5),i=n(0),s=n(81),l=n.n(s),d=n(82),c=n.n(d),u=n(26),h=n.n(u),f=n(27),m=n.n(f),p=n(35),v=n.n(p),g=n(83),E=n.n(g),T=n(84),_=n.n(T),x=n(85),b=n.n(x),P=n(86),A=n.n(P),F=n(7),M=n(12),N=n.n(M),R=n(6),U=n(1),C=n(4),y=n(3),w=n.n(y),L=n(10),B=n(13);var I=class{constructor(e,t={}){this._size=e,this.magFilter=t.magFilter||i.d.LINEAR,this.minFilter=t.minFilter||i.d.LINEAR,this.wrapS=t.wrapS||i.d.CLAMP_TO_EDGE,this.wrapT=t.wrapT||i.d.CLAMP_TO_EDGE,this._init()}_init(){this.texture=i.d.createTexture(),this.glTexture=new B.a(this.texture,{},!0),i.d.bindTexture(i.d.TEXTURE_CUBE_MAP,this.texture),i.d.texParameteri(i.d.TEXTURE_CUBE_MAP,i.d.TEXTURE_MAG_FILTER,this.magFilter),i.d.texParameteri(i.d.TEXTURE_CUBE_MAP,i.d.TEXTURE_MIN_FILTER,this.minFilter),i.d.texParameteri(i.d.TEXTURE_CUBE_MAP,i.d.TEXTURE_WRAP_S,this.wrapS),i.d.texParameteri(i.d.TEXTURE_CUBE_MAP,i.d.TEXTURE_WRAP_T,this.wrapT);const e=[i.d.TEXTURE_CUBE_MAP_POSITIVE_X,i.d.TEXTURE_CUBE_MAP_NEGATIVE_X,i.d.TEXTURE_CUBE_MAP_POSITIVE_Y,i.d.TEXTURE_CUBE_MAP_NEGATIVE_Y,i.d.TEXTURE_CUBE_MAP_POSITIVE_Z,i.d.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let t=0;t<e.length;t++)i.d.pixelStorei(i.d.UNPACK_FLIP_Y_WEBGL,!1),i.d.texImage2D(e[t],0,i.d.RGBA,this.width,this.height,0,i.d.RGBA,i.d.FLOAT,null);this._frameBuffers=[];for(let t=0;t<e.length;t++){const n=i.d.createFramebuffer();i.d.bindFramebuffer(i.d.FRAMEBUFFER,n),i.d.framebufferTexture2D(i.d.FRAMEBUFFER,i.d.COLOR_ATTACHMENT0,e[t],this.texture,0);const r=i.d.checkFramebufferStatus(i.d.FRAMEBUFFER);r!==i.d.FRAMEBUFFER_COMPLETE&&console.log(`'gl.checkFramebufferStatus() returned '${r}`),this._frameBuffers.push(n)}i.d.bindFramebuffer(i.d.FRAMEBUFFER,null),i.d.bindRenderbuffer(i.d.RENDERBUFFER,null),i.d.bindTexture(i.d.TEXTURE_CUBE_MAP,null)}bind(e){i.d.viewport(0,0,this.width,this.height),i.d.bindFramebuffer(i.d.FRAMEBUFFER,this._frameBuffers[e])}unbind(){i.d.bindFramebuffer(i.d.FRAMEBUFFER,null),i.d.viewport(0,0,i.a.width,i.a.height)}getTexture(){return this.glTexture}get width(){return this._size}get height(){return this._size}};n.d(t,"default",function(){return V});class V extends a.default{constructor(){super(),Object(o.a)(this,"count",0)}init(){i.d.getExtension("OES_standard_derivatives"),i.d.getExtension("OES_texture_float"),i.d.getExtension("OES_texture_float_linear"),this.prg=this.compile(l.a,c.a),this.mapPrg=this.compile(h.a,m.a),this.cubePrg=this.compile(v.a,E.a),this.skyboxPrg=this.compile(_.a,b.a),this.irradiancePrg=this.compile(v.a,A.a)}attrib(){let{pos:e,index:t,normal:n,uv:r}=Object(R.Sphere)(256,256,.15),o=new C.a;o.bufferVertex(e),o.bufferIndices(t),o.bufferNormal(n),o.bufferTexCoord(r),this.sphere=o;let a=new C.a;a.bufferData(R.CubeData,["position","normal","texCoord"],[3,3,2]),this.cube=a;this.planeBuffer=new F.a(i.d,new Float32Array([3,-.5,3,1,0,-3,-.5,3,0,0,-3,-.5,-3,0,1,3,-.5,3,1,0,-3,-.5,-3,0,1,3,-.5,-3,1,1])),this.planeBuffer.attrib("position",3,i.d.FLOAT),this.planeBuffer.attrib("texCoord",2,i.d.FLOAT),this.planeVao=new N.a(i.d),this.planeVao.setup(this.cubePrg,[this.planeBuffer])}prepare(){i.d.enable(i.d.DEPTH_TEST),i.d.depthFunc(i.d.LEQUAL),i.d.pixelStorei(i.d.UNPACK_FLIP_Y_WEBGL,!0);let e=Object(L.a)(getAssets.equirectangular);console.log("hdrInfo",e),this.hdrTexture=new w.a(i.d,i.d.RGBA).fromData(e.shape[0],e.shape[1],e.data,i.d.FLOAT),this.hdrTexture.clamp();let t=i.d.createTexture();i.d.bindTexture(i.d.TEXTURE_CUBE_MAP,t);for(var n=0;n<6;n++)i.d.texImage2D(i.d.TEXTURE_CUBE_MAP_POSITIVE_X+n,0,i.d.RGBA,512,512,0,i.d.RGBA,i.d.FLOAT,null);i.d.texParameteri(i.d.TEXTURE_CUBE_MAP,i.d.TEXTURE_WRAP_S,i.d.CLAMP_TO_EDGE),i.d.texParameteri(i.d.TEXTURE_CUBE_MAP,i.d.TEXTURE_WRAP_T,i.d.CLAMP_TO_EDGE),i.d.texParameteri(i.d.TEXTURE_CUBE_MAP,i.d.TEXTURE_MAG_FILTER,i.d.LINEAR),i.d.texParameteri(i.d.TEXTURE_CUBE_MAP,i.d.TEXTURE_MIN_FILTER,i.d.LINEAR),this.cubemapTexture=t,this.cubePrg.use(),this.hdrTexture.bind(0);let r=U.a.identity(U.a.create()),o=U.a.identity(U.a.create()),a=U.a.identity(U.a.create()),s=U.a.identity(U.a.create());U.a.perspective(r,Object(i.e)(90),1,.1,100);const l=[[U.d.fromValues(0,0,0),U.d.fromValues(1,0,0),U.d.fromValues(0,-1,0)],[U.d.fromValues(0,0,0),U.d.fromValues(-1,0,0),U.d.fromValues(0,-1,0)],[U.d.fromValues(0,0,0),U.d.fromValues(0,1,0),U.d.fromValues(0,0,1)],[U.d.fromValues(0,0,0),U.d.fromValues(0,-1,0),U.d.fromValues(0,0,-1)],[U.d.fromValues(0,0,0),U.d.fromValues(0,0,1),U.d.fromValues(0,-1,0)],[U.d.fromValues(0,0,0),U.d.fromValues(0,0,-1),U.d.fromValues(0,-1,0)]];i.d.viewport(0,0,512,512);let d=i.d.createFramebuffer();i.d.bindFramebuffer(i.d.FRAMEBUFFER,d);for(let e=0;e<6;e++)U.a.lookAt(a,l[e][0],l[e][1],l[e][2]),U.a.multiply(s,r,a),this.cubePrg.style({equirectangularMap:0,vpMatrix:s,mMatrix:o}),i.d.framebufferTexture2D(i.d.FRAMEBUFFER,i.d.COLOR_ATTACHMENT0,i.d.TEXTURE_CUBE_MAP_POSITIVE_X+e,this.cubemapTexture,0),i.d.clear(i.d.COLOR_BUFFER_BIT|i.d.DEPTH_BUFFER_BIT),this.cube.bind(this.cubePrg,["position","texCoord"]),this.cube.draw();i.d.bindFramebuffer(i.d.FRAMEBUFFER,null),this.irradiancePrg.use();let c=new I(32);i.d.activeTexture(i.d.TEXTURE0),i.d.bindTexture(i.d.TEXTURE_CUBE_MAP,this.cubemapTexture);for(let e=0;e<6;e++)U.a.lookAt(a,l[e][0],l[e][1],l[e][2]),U.a.multiply(s,r,a),this.irradiancePrg.style({environmentMap:0,vpMatrix:s,mMatrix:o}),c.bind(e),i.d.clear(i.d.COLOR_BUFFER_BIT|i.d.DEPTH_BUFFER_BIT),this.cube.bind(this.irradiancePrg,["position","texCoord"]),this.cube.draw();c.unbind(),this.irradianceFbo=c}uniform(){let e=U.a.identity(U.a.create()),t=U.a.identity(U.a.create());this.tmpMatrix=U.a.identity(U.a.create());let n=[],r=[];U.d.transformQuat(n,[0,0,1],this.rotateQ),U.d.transformQuat(r,[0,1,0],this.rotateQ),this.eyeDirection=n,U.a.lookAt(e,n,[0,0,0],r),U.a.perspective(t,Object(i.e)(60),i.a.clientWidth/i.a.clientHeight,.1,100),U.a.multiply(this.tmpMatrix,t,e)}_setGUI(){this.addGUIParams({roughness:.2,metallic:6/7,lambertDiffuse:!0,orenNayarDiffuse:!1,map:"none"});let e=this.gui.addFolder("material param");e.add(this.params,"roughness",.05,1).step(.01),e.add(this.params,"metallic",0,6/7).step(.01),e.open();let t=this.gui.addFolder("diffuse model");t.add(this.params,"lambertDiffuse").listen().onChange(()=>{this.setChecked("lambertDiffuse")}),t.add(this.params,"orenNayarDiffuse").listen().onChange(()=>{this.setChecked("orenNayarDiffuse")}),t.open();let n=this.gui.addFolder("material map");n.add(this.params,"map",["none","plastic","wall","gold","grass","rusted_iron","wood"]).listen().onChange(()=>{this.setTexture()}),n.open()}setChecked(e){this.params.lambertDiffuse=!1,this.params.orenNayarDiffuse=!1,this.params[e]=!0}setTexture(){let e=this.params.map;"none"!==e&&(this.texture0=new w.a(i.d,i.d.RGBA).fromImage(getAssets[e+"Albedo"]),this.texture1=new w.a(i.d,i.d.RGBA).fromImage(getAssets[e+"Roughness"]),this.texture2=new w.a(i.d,i.d.RGBA).fromImage(getAssets[e+"Metallic"]),this.texture3=new w.a(i.d,i.d.RGBA).fromImage(getAssets[e+"Ao"]),this.texture4=new w.a(i.d,i.d.RGBA).fromImage(getAssets[e+"Normal"]))}render(){i.d.viewport(0,0,i.a.width,i.a.height),i.d.clearColor(.3,.3,.3,1),i.d.clearDepth(1),i.d.clear(i.d.COLOR_BUFFER_BIT|i.d.DEPTH_BUFFER_BIT);let e=U.a.identity(U.a.create()),t={vpMatrix:this.tmpMatrix,mMatrix:e,lightPositions:[-10,10,10,10,10,10,-10,-10,10,10,-10,10],lightColors:new Array(12).fill(300),camPos:this.eyeDirection,lambertDiffuse:this.params.lambertDiffuse,irradianceMap:0};"none"===this.params.map?(this.prg.use(),this.irradianceFbo.getTexture().bind(0),this.prg.style(Object(r.a)({},t,{albedo:[.5,0,0],roughness:this.params.roughness,metallic:this.params.metallic,ao:1})),this.sphere.bind(this.prg,["position","normal"])):(this.mapPrg.use(),this.texture0.bind(0),this.texture1.bind(1),this.texture2.bind(2),this.texture3.bind(3),this.texture4.bind(4),this.mapPrg.style(Object(r.a)({},t,{albedoMap:0,roughnessMap:1,metallicMap:2,aoMap:3,normalMap:4})),this.sphere.bind(this.mapPrg)),this.sphere.draw(),this.skyboxPrg.use(),i.d.activeTexture(i.d.TEXTURE0),i.d.bindTexture(i.d.TEXTURE_CUBE_MAP,this.cubemapTexture),this.skyboxPrg.style({environmentMap:0,vpMatrix:this.tmpMatrix,mMatrix:e}),this.cube.bind(this.skyboxPrg,["position"]),this.cube.draw()}}},6:function(e,t,n){"use strict";function r(e,t,n,r,a){let i,s=[],l=[],d=[],c=[];for(let l=0;l<=e;l++){let u=2*Math.PI/e*l,h=Math.cos(u),f=Math.sin(u);for(let e=0;e<=t;e++){let l=2*Math.PI/t*e,u=(h*n+r)*Math.cos(l),m=f*n,p=(h*n+r)*Math.sin(l);s.push(u,m,p),i=a||o(360/t*e,1,1,1),c.push(i[0],i[1],i[2],i[3]);let v=h*Math.cos(l),g=h*Math.sin(l);d.push(v,f,g)}}for(let n=0;n<e;n++)for(let e=0;e<t;e++){let r=(t+1)*n+e;l.push(r,r+t+1,r+1),l.push(r+t+1,r+t+2,r+1)}return{pos:s,index:l,normal:d,color:c}}function o(e,t,n,r){if(t>1||n>1||r>1)return;let o=e%360,a=Math.floor(o/60),i=o/60-a,s=n*(1-t),l=n*(1-t*i),d=n*(1-t*(1-i)),c=[];if(!t>0&&!t<0)c.push(n,n,n,r);else{let e=[n,l,s,s,d,n],t=[d,n,n,l,s,s],o=[s,s,d,n,n,l];c.push(e[a],t[a],o[a],r)}return c}function a(e,t,n,r){for(var a=[],i=[],s=[],l=[],d=[],c=0;c<=e;c++)for(var u=Math.PI/e*c,h=Math.cos(u),f=Math.sin(u),m=0;m<=t;m++){var p=2*Math.PI/t*m,v=f*n*Math.cos(p),g=h*n,E=f*n*Math.sin(p),T=f*Math.cos(p),_=f*Math.sin(p);if(r)var x=r;else x=o(360/e*c,1,1,1);a.push(v,g,E),i.push(T,h,_),s.push(x[0],x[1],x[2],x[3]),l.push(1-1/t*m,1/e*c)}for(u=0,c=0;c<e;c++)for(m=0;m<t;m++)u=(t+1)*c+m,d.push(u,u+1,u+t+2),d.push(u,u+t+2,u+t+1);return{pos:a,normal:i,color:s,uv:l,index:d}}function i(e,t,n){const r=e/2,o=n/2;return[r,t,o,0,1,0,1,0,-r,t,-o,0,1,0,0,1,-r,t,o,0,1,0,0,0,r,t,o,0,1,0,1,0,r,t,-o,0,1,0,1,1,-r,t,-o,0,1,0,0,1]}n.r(t),n.d(t,"Torus",function(){return r}),n.d(t,"hsva",function(){return o}),n.d(t,"Sphere",function(){return a}),n.d(t,"plane",function(){return i}),n.d(t,"QuadData",function(){return s}),n.d(t,"CubeData",function(){return l});const s=[-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0],l=[-1,-1,-1,0,0,-1,0,0,1,1,-1,0,0,-1,1,1,1,-1,-1,0,0,-1,1,0,1,1,-1,0,0,-1,1,1,-1,-1,-1,0,0,-1,0,0,-1,1,-1,0,0,-1,0,1,-1,-1,1,0,0,1,0,0,1,-1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,-1,1,1,0,0,1,0,1,-1,-1,1,0,0,1,0,0,-1,1,1,-1,0,0,1,0,-1,1,-1,-1,0,0,1,1,-1,-1,-1,-1,0,0,0,1,-1,-1,-1,-1,0,0,0,1,-1,-1,1,-1,0,0,0,0,-1,1,1,-1,0,0,1,0,1,1,1,1,0,0,1,0,1,-1,-1,1,0,0,0,1,1,1,-1,1,0,0,1,1,1,-1,-1,1,0,0,0,1,1,1,1,1,0,0,1,0,1,-1,1,1,0,0,0,0,-1,-1,-1,0,-1,0,0,1,1,-1,-1,0,-1,0,1,1,1,-1,1,0,-1,0,1,0,1,-1,1,0,-1,0,1,0,-1,-1,1,0,-1,0,0,0,-1,-1,-1,0,-1,0,0,1,-1,1,-1,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,-1,0,1,0,1,1,1,1,1,0,1,0,1,0,-1,1,-1,0,1,0,0,1,-1,1,1,0,1,0,0,0]},81:function(e,t){e.exports="precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying   vec3 vNormal;\nvarying vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"},82:function(e,t){e.exports="\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 kS = fresnelSchlick(max(dot(N, V), 0.0), F0);\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n    vec3 irradiance = textureCube(irradianceMap, N).rgb;\n    vec3 diffuse      = irradiance * albedo;\n    vec3 ambient = (kD * diffuse) * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"},83:function(e,t){e.exports="\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D equirectangularMap;\nvarying vec3 WorldPos;\nvarying vec2 vUv;\n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec2 SampleSphericalMap(vec3 v)\n{\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y)); // [-PI/2,PI/2]\n    uv *= invAtan; //[-.5,.5]\n    uv += 0.5;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = SampleSphericalMap(normalize(WorldPos));\n    vec3 color = texture2D(equirectangularMap, uv).rgb;\n\n    gl_FragColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(WorldPos,1.);\n}\n"},84:function(e,t){e.exports="#define GLSLIFY 1\nattribute vec3 position;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 WorldPos;\n\nvoid main()\n{\n\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tvec4 clipPos    = vpMatrix * pos;\n\tgl_Position = clipPos.xyww; // 设置深度测试的z为1，这样只会在没有遮挡时渲染skybox，节省性能\n\n  WorldPos = pos.xyz;\n}\n"},85:function(e,t){e.exports="\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform samplerCube environmentMap;\nvarying vec3 WorldPos;\n\nvoid main()\n{\n    vec3 envColor = textureCube(environmentMap, WorldPos).rgb;\n\n    // HDR tonemap and gamma correct\n    envColor = envColor / (envColor + vec3(1.0));\n    envColor = pow(envColor, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(envColor, 1.0);\n}\n"},86:function(e,t){e.exports="precision mediump float;\n#define GLSLIFY 1\nvarying vec3 WorldPos;\n\nuniform samplerCube environmentMap;\n\nconst float PI = 3.14159265359;\n\nvoid main()\n{\n\t// The world vector acts as the normal of a tangent surface\n    // from the origin, aligned to WorldPos. Given this normal, calculate all\n    // incoming radiance of the environment. The result of this radiance\n    // is the radiance of light coming from -Normal direction, which is what\n    // we use in the PBR shader to sample irradiance.\n    vec3 N = normalize(WorldPos);\n\n    vec3 irradiance = vec3(0.0);\n\n    // tangent space calculation from origin point\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up            = cross(N, right);\n\n    const float sampleDelta = 0.025;\n    float nrSamples = 0.0;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\n\n            irradiance += textureCube(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n    gl_FragColor = vec4(irradiance, 1.0);\n}\n"}}]);