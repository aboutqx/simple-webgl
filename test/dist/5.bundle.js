(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{44:function(e,t,r){"use strict";r.d(t,"a",(function(){return s}));var i=r(0);class s{constructor(e,t){this._mesh=e,this._shader=t}draw(e){this._shader.bind(),this._shader.style(e),i.a.draw(this._mesh)}get mesh(){return this._mesh}get shader(){return this._shader}}},45:function(e,t,r){"use strict";var i=r(0),s=r(3);let n,o;t.a=class{constructor(e,t,r={},s=1){n=!window.useWebgl2&&i.c.getExtension("WEBGL_depth_texture"),this.width=e||i.b.width,this.height=t||i.b.height,this._numTargets=s,this._multipleTargets=s>1,1==r.hdr?this._parameters={internalFormat:i.c.RGBA16F,type:i.c.HALF_FLOAT,minFilter:r.minFilter,maxFilter:r.magFilter}:this._parameters=r,window.useWebgl2||(o=i.c.getExtension("WEBGL_draw_buffers")),this._multipleTargets&&this._checkMaxNumRenderTarget(),this._init()}_init(){if(this._initTextures(),this.frameBuffer=i.c.createFramebuffer(),i.c.bindFramebuffer(i.c.FRAMEBUFFER,this.frameBuffer),window.useWebgl2){if(0===this._numTargets)i.c.readBuffer(i.c.NONE),i.c.drawBuffers([i.c.NONE]);else{const e=[];for(let t=0;t<this._numTargets;t++)i.c.framebufferTexture2D(i.c.DRAW_FRAMEBUFFER,i.c.COLOR_ATTACHMENT0+t,i.c.TEXTURE_2D,this._textures[t].texture,0),e.push(i.c["COLOR_ATTACHMENT"+t]);i.c.drawBuffers(e)}i.c.framebufferTexture2D(i.c.DRAW_FRAMEBUFFER,i.c.DEPTH_ATTACHMENT,i.c.TEXTURE_2D,this.glDepthTexture.texture,0)}else{for(let e=0;e<this._numTargets;e++)i.c.framebufferTexture2D(i.c.FRAMEBUFFER,i.c.COLOR_ATTACHMENT0+e,i.c.TEXTURE_2D,this._textures[e].texture,0);if(this._multipleTargets){const e=[];for(let t=0;t<this._numTargets;t++)e.push(o[`COLOR_ATTACHMENT${t}_WEBGL`]);o.drawBuffersWEBGL(e)}n&&i.c.framebufferTexture2D(i.c.FRAMEBUFFER,i.c.DEPTH_ATTACHMENT,i.c.TEXTURE_2D,this.glDepthTexture.texture,0)}i.c.checkFramebufferStatus(i.c.FRAMEBUFFER)!=i.c.FRAMEBUFFER_COMPLETE&&console.log("gl.checkFramebufferStatus() returned "+status.toString(16)),i.c.bindTexture(i.c.TEXTURE_2D,null),i.c.bindRenderbuffer(i.c.RENDERBUFFER,null),i.c.bindFramebuffer(i.c.FRAMEBUFFER,null),this.clear()}_checkMaxNumRenderTarget(){const e=window.useWebgl2?i.c.getParameter(i.c.MAX_DRAW_BUFFERS):i.c.getParameter(o.MAX_DRAW_BUFFERS_WEBGL);this._numTargets>e&&(console.error("Over max number of draw buffers supported : ",e),this._numTargets=e)}_initTextures(){this._textures=[];for(let e=0;e<this._numTargets;e++){const e=this._createTexture();this._textures.push(e)}window.useWebgl2?this.glDepthTexture=this._createTexture(i.c.DEPTH_COMPONENT16,i.c.UNSIGNED_SHORT,i.c.DEPTH_COMPONENT,{minFilter:i.c.NEAREST,magFilter:i.c.NEAREST}):this.glDepthTexture=this._createTexture(i.c.DEPTH_COMPONENT,i.c.UNSIGNED_SHORT,i.c.DEPTH_COMPONENT,{minFilter:i.c.LINEAR})}_createTexture(e,t,r,n={}){const o=Object.assign({},this._parameters);o.internalFormat=e||o.internalFormat,o.format=r||o.format||i.c.RGBA,o.type=t||o.type||i.c.UNSIGNED_BYTE;for(const e in n)o[e]=n[e];return new s.a(null,o,this.width,this.height)}bind(e=!0){e&&i.c.viewport(0,0,this.width,this.height),i.c.bindFramebuffer(i.c.FRAMEBUFFER,this.frameBuffer),i.a.clear(0,0,0,1)}unbind(e=!0){e&&i.c.viewport(0,0,i.b.width,i.b.height),i.c.bindFramebuffer(i.c.FRAMEBUFFER,null),this._textures.forEach(e=>{e.generateMipmap()})}clear(e=0,t=0,r=0,s=0){this.bind(),i.a.clear(e,t,r,s),this.unbind()}get textures(){return this._textures}getTexture(e=0){return this._textures[e]}get depthTexture(){return this.glDepthTexture}get minFilter(){return this._textures[0].minFilter}set minFilter(e){this._textures.forEach(t=>{t.minFilter=e})}get magFilter(){return this._textures[0].magFilter}set magFilter(e){this._textures.forEach(t=>{t.magFilter=e})}get wrapS(){return this._textures[0].wrapS}set wrapS(e){this._textures.forEach(t=>{t.wrapS=e})}get wrapT(){return this._textures[0].wrapT}set wrapT(e){this._textures.forEach(t=>{t.wrapT=e})}showParameters(){this._textures[0].showParameters()}get numTargets(){return this._numTargets}}},46:function(e,t,r){"use strict";r.d(t,"a",(function(){return a}));var i=r(13),s=r(15),n=r(42),o=r(44);class a extends o.a{constructor(e){const t=new s.a(i.c,e);super(n.a.bigTriangle(),t)}draw(e){super.draw(e)}}},70:function(e,t,r){"use strict";var i=r(45);var s=class{constructor(e,t,r,s={},n=1){this._fbos=[];for(let o=0;o<e;o++){const e=new i.a(t,r,s,n);this._fbos.push(e)}}swap(){const e=this._fbos.shift();this._fbos.push(e)}get read(){return this._fbos[this._fbos.length-1]}get write(){return this._fbos[0]}get all(){return this._fbos}};t.a=class extends s{constructor(e,t,r={},i=1){super(2,e,t,r,i)}pingpong(e,t,r,i,s){}}},95:function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return h}));var i=r(43),s=r(1),n=r(0),o=r(42),a=r(46),l=r(45),u=r(70);class h extends i.a{constructor(){super()}init(){n.a.applyHdrExtension(),this.prg=this.basicVert("#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nlayout (location = 0) out vec4 FragColor;\nlayout (location = 1) out vec4 BrightColor;\n\nin  vec3 vPosition;\nin  vec3 vNormal;\nin  vec2 vTexCoord;\n\nstruct Light {\n    vec3 Position;\n    vec3 Color;\n};\n\nuniform Light lights[5];\nuniform vec3 baseColor;\nuniform vec3 uCameraPos;\nuniform float uAlpha;\n\nvoid main()\n{           \n    vec3 normal = normalize(vNormal);\n    // ambient\n    vec3 ambient = 0.0 * baseColor;\n    // lighting\n    vec3 lighting = vec3(0.0);\n    vec3 viewDir = normalize(uCameraPos - vPosition);\n    for(int i = 0; i < 5; i++)\n    {\n        // diffuse\n        vec3 lightDir = normalize(lights[i].Position - vPosition);\n        float diff = max(dot(lightDir, normal), 0.0);\n        vec3 result = lights[i].Color * diff * baseColor;      \n        // attenuation (use quadratic as we have gamma correction)\n        float distance = length(vPosition - lights[i].Position);\n        result *= 1.0 / (distance * distance);\n        lighting += result;\n                \n    }\n    vec3 result = ambient + lighting;\n    // check whether result is higher than some threshold, if so, output as bloom threshold color\n    // tranform to grayscale\n    float brightness = dot(result, vec3(0.2126, 0.7152, 0.0722));\n    if(brightness > 1.0)\n        BrightColor = vec4(result, uAlpha);\n    else\n        BrightColor = vec4(0.0, 0.0, 0.0, 1.0);\n    FragColor = vec4(result, uAlpha);\n}\n"),this._vBlur=new a.a("#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec2 vTexCoord;\n\nuniform sampler2D image;\n\nuniform bool horizontal;\nuniform float texOffsetScale;\nfloat weight[5] = float[] (0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162);\nout vec4 FragColor;\nfloat lod =1.;\n\nvoid main()\n{             \n    vec2 tex_offset = texOffsetScale * vec2(1.0/ float(textureSize(image, 0).x), 1.0/ float(textureSize(image, 0).y)); // gets size of single texel\n    vec3 result = texture(image, vTexCoord, lod).rgb * weight[0];\n    if(horizontal)\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n        result += texture(image, vTexCoord + vec2(tex_offset.x * float(i), 0.0), lod).rgb * weight[i];\n        result += texture(image, vTexCoord - vec2(tex_offset.x * float(i), 0.0), lod).rgb * weight[i];\n        }\n    }\n    else\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n            result += texture(image, vTexCoord + vec2(0.0, tex_offset.y * float(i)), lod).rgb * weight[i];\n            result += texture(image, vTexCoord - vec2(0.0, tex_offset.y * float(i)), lod).rgb * weight[i];\n        }\n    }\n    FragColor = vec4(result, 1.0);\n}"),this._vFinal=new a.a("#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec2 vTexCoord;\n\nuniform sampler2D scene;\nuniform sampler2D bloomBlur;\nuniform bool bloom;\nuniform float exposure;\n\nvoid main()\n{             \n    const float gamma = 2.2;\n    vec3 hdrColor = texture(scene, vTexCoord).rgb;      \n    vec3 bloomColor = texture(bloomBlur, vTexCoord).rgb;\n    if(bloom)\n        hdrColor += bloomColor; // additive blending\n    // tone mapping\n    vec3 result = vec3(1.0) - exp(-hdrColor * exposure);\n    // also gamma correct while we're at it       \n    result = pow(result, vec3(1.0 / gamma));\n    FragColor = vec4(result, 1.0);\n}")}attrib(){this.statue=o.a.cube(1),this.quad=o.a.bigTriangle()}prepare(){n.a.srcBlend(),this.orbital.radius=3.5,this.fbo=new l.a(n.b.width,n.b.height,{hdr:!0},2),this.textures=this.fbo.textures,this.pingpongFbo=new u.a(128,128,{hdr:!0})}_setGUI(){this.addGUIParams({texOffsetScale:.1,blurPassCount:5,lightScale:1,uAlpha:.5}),this.gui.add(this.params,"texOffsetScale",0,5).step(.01),this.gui.add(this.params,"blurPassCount",1,20).step(1),this.gui.add(this.params,"lightScale",.1,10).step(.1),this.gui.add(this.params,"uAlpha",0,1).step(.1)}uniform(){}_renderScene(){const e=s.b.create();s.b.rotateY(e,e,.3);let t=[10,20,10].map(e=>e*this.params.lightScale);this.prg.use(),this.prg.style({mMatrix:e,"lights[0].Position":[1.5,0,0],"lights[0].Color":t,"lights[1].Position":[-1.5,0,0],"lights[1].Color":t,"lights[2].Position":[0,1.5,-2],"lights[2].Color":t,"lights[3].Position":[0,0,2],"lights[3].Color":[10,20,10],"lights[4].Position":[0,-1.5,0],"lights[4].Color":[10,20,10],baseColor:[0,.3,.3],uAlpha:this.params.uAlpha}),this.statue.rotationY=12,n.a.draw(this.statue)}render(){this.fbo.bind(),n.a.clear(0,0,0),n.c.cullFace(n.c.FRONT),this._renderScene(),n.c.cullFace(n.c.BACK),this._renderScene(),this.fbo.unbind();let e=!0;for(let t=0;t<this.params.blurPassCount;t++)this.pingpongFbo.write.bind(),this._vBlur.draw({image:0==t?this.textures[1]:this.pingpongFbo.read.textures[0],horizontal:e,texOffsetScale:this.params.texOffsetScale}),e=!e,this.pingpongFbo.write.unbind(),this.pingpongFbo.swap();n.a.clear(0,0,0),this._vFinal.draw({scene:this.textures[0],bloomBlur:this.pingpongFbo.read.textures[0],bloom:!0,exposure:.1})}}}}]);