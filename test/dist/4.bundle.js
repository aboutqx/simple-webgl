(window.webpackJsonp=window.webpackJsonp||[]).push([[4,22,28],{132:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout   vec3 vNormal;\nout vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"},133:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 6.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color =  ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"},134:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 vNormal;\nout vec3 WorldPos;\nout vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"},135:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nin vec2 TexCoords;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"},142:function(e,t){e.exports="// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nattribute vec3 normal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n    vTextureCoord = texCoord;\n    vNormal = normal;\n}"},143:function(e,t){e.exports="// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"},16:function(e,t){e.exports="#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 WorldPos;\nout vec2 vUv;\nvoid main(void){\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  WorldPos = pos.xyz;\n  vUv = texCoord;\n}\n"},21:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D equirectangularMap;\nin vec3 WorldPos;\nin vec2 vUv;\nout vec4 outColor;\n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec2 SampleSphericalMap(vec3 v)\n{\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y)); // [-PI/2,PI/2]\n    uv *= invAtan; //[-.5,.5]\n    uv += 0.5;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = SampleSphericalMap(normalize(WorldPos));\n    vec3 color = textureLod(equirectangularMap, uv, 0.).rgb;\n\n    outColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(WorldPos,1.);\n}\n"},22:function(e,t){e.exports="#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nuniform   mat4 mMatrix;\nuniform   mat4 vMatrix;\nuniform   mat4 pMatrix;\n\nout vec3 WorldPos;\n\nvoid main()\n{\n  mat4 rotView = mat4(mat3(vMatrix)); // remove translation from the view matrix\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tvec4 clipPos    = pMatrix * rotView * pos;\n\tgl_Position = clipPos.xyww; // 设置深度测试的z为1，这样只会在没有遮挡时渲染skybox，节省性能\n\n  WorldPos = pos.xyz;\n}\n"},23:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform samplerCube environmentMap;\nin vec3 WorldPos;\nout vec4 outColor;\nvoid main()\n{\n    vec3 envColor = textureLod(environmentMap, WorldPos, 0.).rgb;\n\n    // HDR tonemap and gamma correct\n    envColor = envColor / (envColor + vec3(1.0));\n    envColor = pow(envColor, vec3(1.0/2.2));\n\n    outColor = vec4(envColor, 1.0);\n}\n"},24:function(e,t){e.exports="#version 300 es\n#define GLSLIFY 1\n\nin vec3 position;\nin vec2 texCoord;\nout vec2 TexCoords;\n\nvoid main(void) {\n  gl_Position = vec4(position, 1.);\n  TexCoords = texCoord;\n\n}\n"},25:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec2 FragColor;\nin vec2 TexCoords;\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits)\n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t// from spherical coordinates to cartesian coordinates - halfway vector\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\n\t// from tangent-space H vector to world-space sample vector\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    // note that we use a different k for IBL\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 1024u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the\n        // preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec2 integratedBRDF = IntegrateBRDF(TexCoords.x, TexCoords.y);\n    FragColor = integratedBRDF;\n    // FragColor = vec4(integratedBRDF,0. ,1.);\n}\n"},28:function(e,t,n){"use strict";var o=n(0),r=n(14),a=n(12);n(144);const i=(e,t)=>{if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0},s=e=>{const t=e.split("\n");for(let e=0;e<t.length;e++)t[e]=`${e+1}: ${t[e]}`;return t.join("\n")},c=e=>e.slice?e.slice(0):new Float32Array(e),l=n(142),u=n(143),h={float:"uniform1f",vec2:"uniform2fv",vec3:"uniform3fv",vec4:"uniform4fv",int:"uniform1i",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"};class m{constructor(e=l,t=u,n){this.parameters=[],this._uniformTextures=[],this._varyings=n,e||(e=l),t||(t=l);const o=this._createShaderProgram(e,!0),r=this._createShaderProgram(t,!1);this._attachShaderProgram(o,r)}use(){this.bind()}bind(){o.c.useProgram(this.shaderProgram),o.a.useShader(this)}uniform(e,t,n){if("object"==typeof e)return void this.uniformObject(e);const r=h[t]||t;let a,s=!1,l=-1;for(let t=0;t<this.parameters.length;t++)if((a=this.parameters[t]).name===e){s=!0,l=t;break}let u=!1;if(s?(this.shaderProgram[e]=a.uniformLoc,u=a.isNumber):(u="uniform1i"===r||"uniform1f"===r,this.shaderProgram[e]=o.c.getUniformLocation(this.shaderProgram,e),u?this.parameters.push({name:e,type:r,value:n,uniformLoc:this.shaderProgram[e],isNumber:u}):this.parameters.push({name:e,type:r,value:c(n),uniformLoc:this.shaderProgram[e],isNumber:u}),l=this.parameters.length-1),this.parameters[l].uniformLoc)if(-1===r.indexOf("Matrix"))if(u){(this.parameters[l].value!==n||!s)&&(o.c[r](this.shaderProgram[e],n),this.parameters[l].value=n)}else i(this.parameters[l].value,n)&&s||(o.c[r](this.shaderProgram[e],n),this.parameters[l].value=c(n));else i(this.parameters[l].value,n)&&s||(o.c[r](this.shaderProgram[e],!1,n),this.parameters[l].value=c(n))}style(e){this.uniformObject(e)}uniformObject(e){for(const t in e)if(e[t]instanceof r.a||e[t]instanceof a.a){const n=e[t];let o=-1;this._uniformTextures.forEach((e,r)=>{e.name===t&&(o=r,e.texture=n)}),-1===o&&(o=this._uniformTextures.length,this._uniformTextures.push({name:t,texture:n})),this.uniform(t,"uniform1i",o),n.bind(o)}else{let n=e[t];const o=m.getUniformType(n);if(n.concat&&n[0].concat){let e=[];for(let t=0;t<n.length;t++)e=e.concat(n[t]);n=e}this.uniform(t,o,n)}}_createShaderProgram(e,t){const n=t?o.c.VERTEX_SHADER:o.c.FRAGMENT_SHADER,r=o.c.createShader(n);return o.c.shaderSource(r,e),o.c.compileShader(r),o.c.getShaderParameter(r,o.c.COMPILE_STATUS)?r:(console.warn("Error in Shader : ",o.c.getShaderInfoLog(r)),console.log(s(e)),null)}_attachShaderProgram(e,t){this.shaderProgram=o.c.createProgram(),o.c.attachShader(this.shaderProgram,e),o.c.attachShader(this.shaderProgram,t),o.c.deleteShader(e),o.c.deleteShader(t),this._varyings&&(console.log("Transform feedback setup : ",this._varyings),o.c.transformFeedbackVaryings(this.shaderProgram,this._varyings,o.c.SEPARATE_ATTRIBS)),o.c.linkProgram(this.shaderProgram)}}m.getUniformType=function(e){const t=function(e){return 9===e.length?"uniformMatrix3fv":16===e.length?"uniformMatrix4fv":`vec${e.length}`};return!!e.length?e[0].concat?t(e[0]):t(e):"float"},t.a=m},4:function(e,t){var n=0,o=3553;function r(e,t,n){return 9728|+e|+t<<8|+(t&&n)<<1}function a(e,t){return this._uid=n++,this.gl=e,this.id=this.gl.createTexture(),this.width=0,this.height=0,this.format=t||e.RGB,this.type=e.UNSIGNED_BYTE,this.img=null,e.bindTexture(o,this.id),this.setFilter(!0),this}a.prototype={fromImage:function(e){var t=this.gl;return this.img=e,this.width=e.width,this.height=e.height,t.bindTexture(o,this.id),t.texImage2D(o,0,this.format,this.format,this.type,e),this},fromData:function(e,t,n,r){var a=this.gl;return this.width=e,this.height=t,n=n||null,this.type=r||a.UNSIGNED_BYTE,a.bindTexture(o,this.id),window.useWebgl2?r===a.RGBA16F?a.texImage2D(a.TEXTURE_2D,0,this.type,e,t,0,this.format,a.HALF_FLOAT,n):r===a.RG32F||r===a.RGBA32F||r===a.RGB32F?a.texImage2D(a.TEXTURE_2D,0,this.type,e,t,0,this.format,a.FLOAT,n):a.texImage2D(o,0,this.format,e,t,0,this.format,this.type,n):a.texImage2D(o,0,this.format,e,t,0,this.format,this.type,n),this},bind:function(e){var t=this.gl;void 0!==e&&t.activeTexture(t.TEXTURE0+(0|e)),t.bindTexture(o,this.id)},dispose:function(){this.gl&&this.gl.deleteTexture(this.id),this.id=null,this.gl=null},setFilter:function(e,t,n){var a=this.gl,i=r(!!e,!!t,!!n);a.texParameteri(o,a.TEXTURE_MAG_FILTER,r(!!e,!1,!1)),a.texParameteri(o,a.TEXTURE_MIN_FILTER,i)},repeat:function(){this.wrap(this.gl.REPEAT)},clamp:function(){this.wrap(this.gl.CLAMP_TO_EDGE)},mirror:function(){this.wrap(this.gl.MIRRORED_REPEAT)},wrap:function(e){var t=this.gl;t.texParameteri(o,t.TEXTURE_WRAP_S,e),t.texParameteri(o,t.TEXTURE_WRAP_T,e)}},e.exports=a},5:function(e,t,n){"use strict";n.r(t);var o=n(2),r=n(28),a=n(1),i=n(0);const s=function(e,t,n){const o=t||{};return e.touches&&!n?(o.x=e.touches[0].pageX,o.y=e.touches[0].pageY):e.touches?e.touches&&n&&(o.x=e.touches[1].pageX,o.y=e.touches[1].pageY):(o.x=e.clientX,o.y=e.clientY),o},c=1e-4;class l{constructor(e=[0,0,0],t=[0,1,0]){Object(o.a)(this,"cameraPos",void 0),Object(o.a)(this,"up",void 0),Object(o.a)(this,"cameraFront",[0,0,-1]),Object(o.a)(this,"_mouse",{}),Object(o.a)(this,"_preMouse",{}),Object(o.a)(this,"_mousedown",!1),Object(o.a)(this,"_rx",0),Object(o.a)(this,"_ry",0),Object(o.a)(this,"_preRx",0),Object(o.a)(this,"_preRy",0),Object(o.a)(this,"_targetRx",0),Object(o.a)(this,"_targetRy",0),Object(o.a)(this,"_viewMatrix",a.b.identity(a.b.create())),Object(o.a)(this,"_width",i.b.width),Object(o.a)(this,"_height",i.b.height),Object(o.a)(this,"sensitivity",1),Object(o.a)(this,"target",[0,0,0]),Object(o.a)(this,"offset",[0,0,0]),Object(o.a)(this,"radius",5),Object(o.a)(this,"_targetRadius",5),Object(o.a)(this,"_updateWheel",!1),this.cameraPos=e,this.up=t,this.projMatrix=a.b.create(),a.b.perspective(this.projMatrix,Object(i.d)(45),i.b.clientWidth/i.b.clientHeight,.1,100),this._addEvents()}setProj(e,t,n){a.b.perspective(this.projMatrix,Object(i.d)(e),i.b.clientWidth/i.b.clientHeight,t,n)}_addEvents(){i.b.addEventListener("mousedown",e=>this._down(e)),i.b.addEventListener("mousemove",e=>this._move(e)),document.addEventListener("mouseup",e=>this._up(e)),i.b.addEventListener("mousewheel",e=>this._onWheel(e)),i.b.addEventListener("DOMMouseScroll",e=>this._onWheel(e))}_down(e){this._mousedown=!0,s(e,this._mouse),s(e,this._preMouse),this._preRx=this._targetRx,this._preRy=this._targetRy}_move(e){if(this._mousedown){s(e,this._mouse);let t=(this._mouse.x-this._preMouse.x)/this._width,n=(this._mouse.y-this._preMouse.y)/this._height;this._targetRx=this._preRx+t*Math.PI*2*this.sensitivity,this._targetRy=this._preRy+n*Math.PI*this.sensitivity}}_up(e){this._mousedown=!1}updateMatrix(){this._rx+=.1*(this._targetRx-this._rx),Math.abs(this._targetRx-this._rx)<c&&(this._rx=this._targetRx),this._ry+=.1*(this._targetRy-this._ry),Math.abs(this._targetRy-this._ry)<c&&(this._ry=this._targetRy),this._updateWheel&&(this.radius+=.1*(this._targetRadius-this.radius),Math.abs(this._targetRadius-this.radius)<c&&(this.radius=this._targetRadius)),this.cameraPos[1]=Math.sin(this._ry)*this.radius;let e=Math.abs(Math.cos(this._ry)*this.radius);this.cameraPos[0]=Math.cos(this._rx+.5*Math.PI)*e,this.cameraPos[2]=Math.sin(this._rx+.5*Math.PI)*e,this.cameraPos=[this.cameraPos[0]+this.offset[0],this.cameraPos[1]+this.offset[1],this.cameraPos[2]+this.offset[2]],a.b.lookAt(this._viewMatrix,this.cameraPos,this.target,this.up)}_onWheel(e){const t=e.wheelDelta,n=e.detail;let o=0;o=n?t?t/n/40*n>0?1:-1:-n/3:t/120,this._targetRadius=this.radius+1*-o,this._targetRadius<=1&&(this._targetRadius=1),this._updateWheel=!0}get viewMatrix(){return this._viewMatrix}set rx(e){this._targetRx=e}}var u=n(43);n.d(t,"default",function(){return h});class h{constructor(){Object(o.a)(this,"rotateQ",a.c.create()),Object(o.a)(this,"mousePos",{x:0,y:0}),Object(o.a)(this,"camera",new l),Object(o.a)(this,"pMatrix",a.b.identity(a.b.create())),Object(o.a)(this,"mvpMatrix",a.b.identity(a.b.create())),Object(o.a)(this,"tmpMatrix",a.b.identity(a.b.create())),Object(o.a)(this,"_params",{}),Object(o.a)(this,"gui",new u.a({width:300})),this.vMatrix=this.camera.viewMatrix,i.a.setCamera(this.camera),this.init(),this.attrib(),this.prepare(),this._setGUI(),this._animate=this.animate.bind(this),i.c.enable(i.c.DEPTH_TEST),i.c.depthFunc(i.c.LEQUAL),i.c.enable(i.c.CULL_FACE)}init(){}compile(e,t){return new r.a(e,t)}attrib(){}uniform(){}prepare(){}animate(){requestAnimationFrame(this._animate),this.camera.updateMatrix(),this.uniform(),this.render()}render(){}play(){this.animate()}_setGUI(){}addGUIParams(e){return Object.assign(this._params,e)}get params(){return this._params}set params(e){throw Error("Params has no setter,please use addGUIParams")}}},6:function(e,t,n){"use strict";n.r(t),n.d(t,"Torus",function(){return r}),n.d(t,"hsva",function(){return a}),n.d(t,"Sphere",function(){return i}),n.d(t,"plane",function(){return s}),n.d(t,"QuadData",function(){return c}),n.d(t,"TorusKnot",function(){return l}),n.d(t,"regularPolyhedron",function(){return u});var o=n(3);function r(e,t,n,r,i){let s,c=[],l=[],u=[],h=[],m=[];for(let o=0;o<=e;o++){let l=2*Math.PI/e*o,d=Math.cos(l),f=Math.sin(l);for(let l=0;l<=t;l++){m.push(l/t,o/e);let p=2*Math.PI/t*l,v=(d*n+r)*Math.cos(p),g=f*n,b=(d*n+r)*Math.sin(p);c.push(v,g,b),s=i||a(360/t*l,1,1,1),h.push(s[0],s[1],s[2],s[3]);let x=d*Math.cos(p),T=d*Math.sin(p);u.push(x,f,T)}}for(let n=0;n<e;n++)for(let e=0;e<t;e++){let o=(t+1)*n+e;l.push(o,o+t+1,o+1),l.push(o+t+1,o+t+2,o+1)}let d=new o.a;return d.bufferFlattenData(c,"position",3),d.bufferFlattenData(m,"texCoord",2),d.bufferFlattenData(h,"color",4),d.bufferIndex(l),d.bufferFlattenData(u,"normal",3),d}function a(e,t,n,o){if(t>1||n>1||o>1)return;let r=e%360,a=Math.floor(r/60),i=r/60-a,s=n*(1-t),c=n*(1-t*i),l=n*(1-t*(1-i)),u=[];if(!t>0&&!t<0)u.push(n,n,n,o);else{let e=[n,c,s,s,l,n],t=[l,n,n,c,s,s],r=[s,s,l,n,n,c];u.push(e[a],t[a],r[a],o)}return u}function i(e,t,n,o){for(var r=[],i=[],s=[],c=[],l=[],u=0;u<=e;u++)for(var h=Math.PI/e*u,m=Math.cos(h),d=Math.sin(h),f=0;f<=t;f++){var p=2*Math.PI/t*f,v=d*n*Math.cos(p),g=m*n,b=d*n*Math.sin(p),x=d*Math.cos(p),T=d*Math.sin(p);if(o)var _=o;else _=a(360/e*u,1,1,1);r.push(v,g,b),i.push(x,m,T),s.push(_[0],_[1],_[2],_[3]),c.push(1-1/t*f,1/e*u)}for(h=0,u=0;u<e;u++)for(f=0;f<t;f++)h=(t+1)*u+f,l.push(h,h+1,h+t+2),l.push(h,h+t+2,h+t+1);return{pos:r,normal:i,color:s,uv:c,index:l}}function s(e,t,n){const o=e/2,r=n/2;return[o,t,r,0,1,0,1,0,-o,t,-r,0,1,0,0,1,-o,t,r,0,1,0,0,0,o,t,r,0,1,0,1,0,o,t,-r,0,1,0,1,1,-o,t,-r,0,1,0,0,1]}const c=[-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0];function l(){}function u(){}},60:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return w});var o=n(7),r=n(2),a=n(5),i=n(0),s=n(132),c=n.n(s),l=n(133),u=n.n(l),h=n(134),m=n.n(h),d=n(135),f=n.n(d),p=n(16),v=n.n(p),g=n(21),b=n.n(g),x=n(22),T=n.n(x),_=n(23),N=n.n(_),F=n(24),M=n.n(F),E=n(25),P=n.n(E),L=n(6),R=n(1),y=n(3),C=n(4),D=n.n(C),A=n(9),V=n(12),S=n(18);class w extends a.default{constructor(){super(),Object(r.a)(this,"count",0)}init(){i.c.getExtension("OES_texture_float_linear"),i.c.getExtension("EXT_color_buffer_float"),this.prg=this.compile(c.a,u.a),this.mapPrg=this.compile(m.a,f.a),this.cubePrg=this.compile(v.a,b.a),this.skyboxPrg=this.compile(T.a,N.a),this.brdfPrg=this.compile(M.a,P.a)}attrib(){let e=new y.a;e.bufferData(L.CubeData,["position","normal","texCoord"],[3,3,2]),this.cube=e;let t=new y.a;t.bufferData([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0],["position","texCoord"],[3,2]),this.quad=t,this.orb=(new S.a).parseObj(getAssets.orb)}prepare(){i.c.enable(i.c.DEPTH_TEST),i.c.depthFunc(i.c.LEQUAL),i.c.pixelStorei(i.c.UNPACK_FLIP_Y_WEBGL,!0);let e=R.b.identity(R.b.create()),t=R.b.identity(R.b.create()),n=R.b.identity(R.b.create()),o=R.b.identity(R.b.create());R.b.perspective(e,Object(i.d)(90),1,.1,100);const r=[[R.e.fromValues(0,0,0),R.e.fromValues(1,0,0),R.e.fromValues(0,-1,0)],[R.e.fromValues(0,0,0),R.e.fromValues(-1,0,0),R.e.fromValues(0,-1,0)],[R.e.fromValues(0,0,0),R.e.fromValues(0,1,0),R.e.fromValues(0,0,1)],[R.e.fromValues(0,0,0),R.e.fromValues(0,-1,0),R.e.fromValues(0,0,-1)],[R.e.fromValues(0,0,0),R.e.fromValues(0,0,1),R.e.fromValues(0,-1,0)],[R.e.fromValues(0,0,0),R.e.fromValues(0,0,-1),R.e.fromValues(0,-1,0)]];let a=Object(A.a)(getAssets.equirectangular);console.log("hdrInfo",a),this.hdrTexture=new D.a(i.c),i.c.bindTexture(i.c.TEXTURE_2D,this.hdrTexture.id),i.c.texImage2D(i.c.TEXTURE_2D,0,i.c.RGBA32F,a.shape[0],a.shape[1],0,i.c.RGBA,i.c.FLOAT,a.data),this.hdrTexture.clamp();let s=i.c.createTexture();i.c.bindTexture(i.c.TEXTURE_CUBE_MAP,s);for(var c=0;c<6;c++)i.c.texImage2D(i.c.TEXTURE_CUBE_MAP_POSITIVE_X+c,0,i.c.RGBA32F,512,512,0,i.c.RGBA,i.c.FLOAT,null);i.c.texParameteri(i.c.TEXTURE_CUBE_MAP,i.c.TEXTURE_WRAP_S,i.c.CLAMP_TO_EDGE),i.c.texParameteri(i.c.TEXTURE_CUBE_MAP,i.c.TEXTURE_WRAP_T,i.c.CLAMP_TO_EDGE),i.c.texParameteri(i.c.TEXTURE_CUBE_MAP,i.c.TEXTURE_MIN_FILTER,i.c.LINEAR_MIPMAP_LINEAR),i.c.texParameteri(i.c.TEXTURE_CUBE_MAP,i.c.TEXTURE_MAG_FILTER,i.c.LINEAR),this.cubemapTexture=s,this.cubePrg.use(),this.hdrTexture.bind(0),i.c.viewport(0,0,512,512);let l=i.c.createFramebuffer();i.c.bindFramebuffer(i.c.FRAMEBUFFER,l);for(let a=0;a<6;a++)R.b.lookAt(n,r[a][0],r[a][1],r[a][2]),R.b.multiply(o,e,n),this.cubePrg.style({equirectangularMap:0,vpMatrix:o,mMatrix:t}),i.c.framebufferTexture2D(i.c.FRAMEBUFFER,i.c.COLOR_ATTACHMENT0,i.c.TEXTURE_CUBE_MAP_POSITIVE_X+a,this.cubemapTexture,0),i.c.clear(i.c.COLOR_BUFFER_BIT|i.c.DEPTH_BUFFER_BIT),this.cube.bind(this.cubePrg,["position","texCoord"]),this.cube.draw();const u=i.c.checkFramebufferStatus(i.c.FRAMEBUFFER);u!=i.c.FRAMEBUFFER_COMPLETE&&console.log(`gl.checkFramebufferStatus() returned ${u.toString(16)}`),i.c.bindFramebuffer(i.c.FRAMEBUFFER,null),this.brdfLUTTexture=new D.a(i.c,i.c.RG).fromData(512,512,null,i.c.RG32F),this.brdfLUTTexture.bind(),this.brdfLUTTexture.clamp(),i.c.bindFramebuffer(i.c.FRAMEBUFFER,l),i.c.framebufferTexture2D(i.c.FRAMEBUFFER,i.c.COLOR_ATTACHMENT0,i.c.TEXTURE_2D,this.brdfLUTTexture.id,0),i.c.viewport(0,0,512,512),this.brdfPrg.use(),i.c.clear(i.c.COLOR_BUFFER_BIT|i.c.DEPTH_BUFFER_BIT),this.quad.bind(this.brdfPrg),this.quad.draw(i.c.TRIANGLE_STRIP),i.c.bindFramebuffer(i.c.FRAMEBUFFER,null);let h=Object(A.a)(getAssets.irradiancePosX),m=Object(A.a)(getAssets.irradianceNegX),d=Object(A.a)(getAssets.irradiancePosY),f=Object(A.a)(getAssets.irradianceNegY),p=Object(A.a)(getAssets.irradiancePosZ),v=Object(A.a)(getAssets.irradianceNegZ);this.irradianceMap=new V.a([h,m,d,f,p,v]),this.prefilterMap=V.a.parseDDS(getAssets.radiance)}uniform(){this.vMatrix=this.camera.viewMatrix,this.pMatrix=R.b.identity(R.b.create()),this.tmpMatrix=R.b.create(),R.b.perspective(this.pMatrix,Object(i.d)(45),i.b.clientWidth/i.b.clientHeight,.1,100),R.b.multiply(this.tmpMatrix,this.pMatrix,this.vMatrix)}_setGUI(){this.addGUIParams({roughness:.2,metallic:6/7,lambertDiffuse:!0,orenNayarDiffuse:!1,map:"none"});let e=this.gui.addFolder("material param");e.add(this.params,"roughness",.05,1).step(.01),e.add(this.params,"metallic",0,6/7).step(.01),e.open();let t=this.gui.addFolder("diffuse model");t.add(this.params,"lambertDiffuse").listen().onChange(()=>{this.setChecked("lambertDiffuse")}),t.add(this.params,"orenNayarDiffuse").listen().onChange(()=>{this.setChecked("orenNayarDiffuse")}),t.open();let n=this.gui.addFolder("material map");n.add(this.params,"map",["none","plastic","wall","gold","grass","rusted_iron","wood"]).listen().onChange(()=>{this.setTexture()}),n.open()}setChecked(e){this.params.lambertDiffuse=!1,this.params.orenNayarDiffuse=!1,this.params[e]=!0}setTexture(){let e=this.params.map;"none"!==e&&(this.texture0=new D.a(i.c,i.c.RGBA).fromImage(getAssets[e+"Albedo"]),this.texture1=new D.a(i.c,i.c.RGBA).fromImage(getAssets[e+"Roughness"]),this.texture2=new D.a(i.c,i.c.RGBA).fromImage(getAssets[e+"Metallic"]),this.texture3=new D.a(i.c,i.c.RGBA).fromImage(getAssets[e+"Ao"]),this.texture4=new D.a(i.c,i.c.RGBA).fromImage(getAssets[e+"Normal"]))}render(){i.c.viewport(0,0,i.b.width,i.b.height),i.c.clearColor(.3,.3,.3,1),i.c.clearDepth(1),i.c.clear(i.c.COLOR_BUFFER_BIT|i.c.DEPTH_BUFFER_BIT);let e=R.b.identity(R.b.create()),t={vpMatrix:this.tmpMatrix,lightPositions:[-10,10,10,10,10,10,-10,-10,10,10,-10,10],lightColors:new Array(12).fill(300),camPos:this.camera.cameraPos,lambertDiffuse:this.params.lambertDiffuse};if("none"===this.params.map){this.prg.use(),i.c.activeTexture(i.c.TEXTURE0),i.c.bindTexture(i.c.TEXTURE_CUBE_MAP,this.irradianceMap.texture),i.c.activeTexture(i.c.TEXTURE1),i.c.bindTexture(i.c.TEXTURE_CUBE_MAP,this.prefilterMap.texture),i.c.activeTexture(i.c.TEXTURE2),i.c.bindTexture(i.c.TEXTURE_2D,this.brdfLUTTexture.id),this.prg.style(Object(o.a)({},t,{mMatrix:e,roughness:this.params.roughness,metallic:this.params.metallic,albedo:[.5,0,0],ao:1,irradianceMap:0,prefilterMap:1,brdfLUT:2}));for(let e=0;e<this.orb.length;e++)this.orb[e].bind(this.prg,["position","normal"]),this.orb[e].draw()}else this.mapPrg.use(),this.texture0.bind(0),this.texture1.bind(1),this.texture2.bind(2),this.texture3.bind(3),this.texture4.bind(4),i.c.activeTexture(i.c.TEXTURE5),i.c.bindTexture(i.c.TEXTURE_CUBE_MAP,this.irradianceMap.texture),i.c.activeTexture(i.c.TEXTURE6),i.c.bindTexture(i.c.TEXTURE_CUBE_MAP,this.prefilterMap.texture),i.c.activeTexture(i.c.TEXTURE7),i.c.bindTexture(i.c.TEXTURE_2D,this.brdfLUTTexture),R.b.scale(e,e,[2,2,2]),this.mapPrg.style(Object(o.a)({},t,{mMatrix:e,albedoMap:0,roughnessMap:1,metallicMap:2,aoMap:3,normalMap:4,irradianceMap:5,prefilterMap:6,brdfLUT:7})),this.sphere.bind(this.mapPrg),this.sphere.draw()}}}}]);