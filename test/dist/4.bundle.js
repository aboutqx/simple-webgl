(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{44:function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var o=n(0);class r{constructor(t,e){this._mesh=t,this._shader=e}draw(t){this._shader.bind(),this._shader.style(t),o.a.draw(this._mesh)}get mesh(){return this._mesh}get shader(){return this._shader}}},45:function(t,e,n){"use strict";var o=n(0),r=n(3);let i,s;e.a=class{constructor(t,e,n={},r=1){i=!window.useWebgl2&&o.c.getExtension("WEBGL_depth_texture"),this.width=t||o.b.width,this.height=e||o.b.height,this._numTargets=r,this._multipleTargets=r>1,1==n.hdr?this._parameters={internalFormat:o.c.RGBA16F,type:o.c.HALF_FLOAT,minFilter:n.minFilter,maxFilter:n.magFilter}:this._parameters=n,window.useWebgl2||(s=o.c.getExtension("WEBGL_draw_buffers")),this._multipleTargets&&this._checkMaxNumRenderTarget(),this._init()}_init(){if(this._initTextures(),this.frameBuffer=o.c.createFramebuffer(),o.c.bindFramebuffer(o.c.FRAMEBUFFER,this.frameBuffer),window.useWebgl2){if(0===this._numTargets)o.c.readBuffer(o.c.NONE),o.c.drawBuffers([o.c.NONE]);else{const t=[];for(let e=0;e<this._numTargets;e++)o.c.framebufferTexture2D(o.c.DRAW_FRAMEBUFFER,o.c.COLOR_ATTACHMENT0+e,o.c.TEXTURE_2D,this._textures[e].texture,0),t.push(o.c["COLOR_ATTACHMENT"+e]);o.c.drawBuffers(t)}o.c.framebufferTexture2D(o.c.DRAW_FRAMEBUFFER,o.c.DEPTH_ATTACHMENT,o.c.TEXTURE_2D,this.glDepthTexture.texture,0)}else{for(let t=0;t<this._numTargets;t++)o.c.framebufferTexture2D(o.c.FRAMEBUFFER,o.c.COLOR_ATTACHMENT0+t,o.c.TEXTURE_2D,this._textures[t].texture,0);if(this._multipleTargets){const t=[];for(let e=0;e<this._numTargets;e++)t.push(s[`COLOR_ATTACHMENT${e}_WEBGL`]);s.drawBuffersWEBGL(t)}i&&o.c.framebufferTexture2D(o.c.FRAMEBUFFER,o.c.DEPTH_ATTACHMENT,o.c.TEXTURE_2D,this.glDepthTexture.texture,0)}o.c.checkFramebufferStatus(o.c.FRAMEBUFFER)!=o.c.FRAMEBUFFER_COMPLETE&&console.log("gl.checkFramebufferStatus() returned "+status.toString(16)),o.c.bindTexture(o.c.TEXTURE_2D,null),o.c.bindRenderbuffer(o.c.RENDERBUFFER,null),o.c.bindFramebuffer(o.c.FRAMEBUFFER,null),this.clear()}_checkMaxNumRenderTarget(){const t=window.useWebgl2?o.c.getParameter(o.c.MAX_DRAW_BUFFERS):o.c.getParameter(s.MAX_DRAW_BUFFERS_WEBGL);this._numTargets>t&&(console.error("Over max number of draw buffers supported : ",t),this._numTargets=t)}_initTextures(){this._textures=[];for(let t=0;t<this._numTargets;t++){const t=this._createTexture();this._textures.push(t)}window.useWebgl2?this.glDepthTexture=this._createTexture(o.c.DEPTH_COMPONENT16,o.c.UNSIGNED_SHORT,o.c.DEPTH_COMPONENT,{minFilter:o.c.NEAREST,magFilter:o.c.NEAREST}):this.glDepthTexture=this._createTexture(o.c.DEPTH_COMPONENT,o.c.UNSIGNED_SHORT,o.c.DEPTH_COMPONENT,{minFilter:o.c.LINEAR})}_createTexture(t,e,n,i={}){const s=Object.assign({},this._parameters);s.internalFormat=t||s.internalFormat,s.format=n||s.format||o.c.RGBA,s.type=e||s.type||o.c.UNSIGNED_BYTE;for(const t in i)s[t]=i[t];return new r.a(null,s,this.width,this.height)}bind(t=!0){t&&o.c.viewport(0,0,this.width,this.height),o.c.bindFramebuffer(o.c.FRAMEBUFFER,this.frameBuffer),o.a.clear(0,0,0,1)}unbind(t=!0){t&&o.c.viewport(0,0,o.b.width,o.b.height),o.c.bindFramebuffer(o.c.FRAMEBUFFER,null),this._textures.forEach(t=>{t.generateMipmap()})}clear(t=0,e=0,n=0,r=0){this.bind(),o.a.clear(t,e,n,r),this.unbind()}get textures(){return this._textures}getTexture(t=0){return this._textures[t]}get depthTexture(){return this.glDepthTexture}get minFilter(){return this._textures[0].minFilter}set minFilter(t){this._textures.forEach(e=>{e.minFilter=t})}get magFilter(){return this._textures[0].magFilter}set magFilter(t){this._textures.forEach(e=>{e.magFilter=t})}get wrapS(){return this._textures[0].wrapS}set wrapS(t){this._textures.forEach(e=>{e.wrapS=t})}get wrapT(){return this._textures[0].wrapT}set wrapT(t){this._textures.forEach(e=>{e.wrapT=t})}showParameters(){this._textures[0].showParameters()}get numTargets(){return this._numTargets}}},46:function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));var o=n(13),r=n(15),i=n(42),s=n(44);class a extends s.a{constructor(t){const e=new r.a(o.c,t);super(i.a.bigTriangle(),e)}draw(t){super.draw(t)}}},52:function(t,e,n){"use strict";var o=n(0),r=n(15),i=n(44),s=n(9);class a extends i.a{constructor(t,e,n,i,a){t=s.a.addInstanceMatrix(t);const c=new r.a(t,e,a);n.bufferInstance(i,"instanceMatrix",o.c.DYNAMIC_DRAW),super(n,c)}set instanceMatrix(t){this.mesh.bufferSubData("instanceMatrix",t)}draw(t){super.draw(t)}}e.a=a},54:function(t,e,n){"use strict";var o=n(42),r=n(15),i=n(44);class s extends i.a{constructor(t=50,e="#version 300 es\n// sky.frag\n#define SHADER_NAME SKY_FRAGMENT\n\nprecision highp float;\n#define GLSLIFY 1\n\nin vec3 vPosition;\nin vec2 vTexCoord;\nuniform sampler2D texture0;\nout vec4 FragColor;\nuniform vec3 uFogColor;\n\nfloat contrast(float mValue, float mScale, float mMidPoint) {\n\treturn clamp( (mValue - mMidPoint) * mScale + mMidPoint, 0.0, 1.0);\n}\n\nfloat contrast(float mValue, float mScale) {\n\treturn contrast(mValue,  mScale, .5);\n}\n\nvec3 contrast(vec3 mValue, float mScale, float mMidPoint) {\n\treturn vec3( contrast(mValue.r, mScale, mMidPoint), contrast(mValue.g, mScale, mMidPoint), contrast(mValue.b, mScale, mMidPoint) );\n}\n\nvec3 contrast(vec3 mValue, float mScale) {\n\treturn contrast(mValue, mScale, .5);\n}\n\nfloat fogFactorExp2(const float dist, const float density) {\n\tconst float LOG2 = -1.442695;\n\tfloat d = density * dist;\n\treturn 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\n#define FOG_DENSITY 0.0001\n\nvoid main(void) {\n    \n     vec3 color = texture(texture0, vTexCoord).rgb;\n    // color = contrast(color, 1.) * 1.2;\n\n    //sky fog only has a y direction change\n    float fogDistance = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogAmount = fogFactorExp2(fogDistance, FOG_DENSITY);\n\n\tfloat offset = smoothstep(5., 1., vPosition.y);\n\tcolor.rgb = mix(color.rgb, uFogColor, offset );\n\n    // float grey = (color.r + color.g + color.b) / 3.0;\n\t// color.rgb = mix(color.rgb, vec3(grey), 0.5);\n\n    FragColor = vec4(color , 1.);\n}\n",n=24){super(o.a.sphere(t,n,!0),new r.a("#version 300 es\n// sky.vert\n\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nin vec3 normal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nout vec2 vTexCoord;\nout vec3 vNormal;\nout vec3 vPosition;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\t// cancle camera position x,y,z move effect\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n    vec4 pos = uModelMatrix * vec4(position, 1.0);\n\tgl_Position = uProjectionMatrix * matView * pos;\n    vTexCoord = texCoord;\n    vNormal = normal;\n\tvPosition = position;\n}",e))}draw(t){this.shader.bind(),this.shader.style(t),super.draw()}}e.a=s},58:function(t,e,n){"use strict";e.a="#version 300 es\n// grass.vert\n\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nin vec3 normal;\nin vec3 aPosOffset;\nin vec3 aColor;\nin vec3 aExtra;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform float uMaxHeight;\nuniform float uTerrainSize;\nuniform sampler2D texture0;\nuniform sampler2D textureHeight;\nuniform sampler2D textureNormal;\nuniform sampler2D textureNoise;\nuniform float uDistForward;\n\nout vec2 vTexCoord;\nout vec2 vUV;\nout vec3 vNormal;\nout vec3 vGrassNormal;\nout vec3 vPosition;\nout vec3 vColor;\nout float vHeight;\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n \nvoid main(void) {\n\tvec3 posOffset \t\t= aPosOffset * vec3(1.0, 0.0, 1.0);\n\tposOffset.y \t\t-= 0.2;\n\tposOffset.z \t\t+= uDistForward;\n\tposOffset.z \t\t= mod(posOffset.z, uTerrainSize * 2.0);\n\tposOffset.z \t\t-= uTerrainSize;\n\n\tvec3 cPosition \t\t= position;\n\tcPosition.xz \t\t= rotate(cPosition.xz, aExtra.y);\n\tvPosition \t\t\t= posOffset;\n\tcPosition \t\t\t= posOffset + cPosition * vec3(1.0, aPosOffset.y, 1.0);\n\t\n\tfloat u \t\t\t= (cPosition.x / uTerrainSize * 0.5 + 0.5);\n\tfloat v \t\t\t= 1.0-(cPosition.z / uTerrainSize * 0.5 + 0.5);\n\n\tvec2 uv \t\t\t= vec2(u, v);\n\tfloat colorHeight \t= texture(textureHeight, uv).r;\n\tcPosition.y \t\t\t*= -aPosOffset.y;\n\tcPosition.y \t\t\t+= colorHeight * uMaxHeight;\n\n\tvec2 wind \t\t\t= texture(textureNoise, uv).rg - .5;\n\twind \t\t\t\t*= texCoord.y;\n\tcPosition.xz \t\t+= wind * 2.0;\n\n    gl_Position \t\t= uProjectionMatrix * uViewMatrix * vec4(cPosition, 1.0);\n    vTexCoord \t\t= texCoord;\n    vNormal \t\t\t= normal;\n    vColor \t\t\t\t= aColor;\n    vHeight \t\t\t= colorHeight;\n    vUV\t\t\t\t\t= uv;\n\n    vGrassNormal \t\t= texture(textureNormal, uv).rgb * 2.0 - 1.0;\n}"},59:function(t,e,n){"use strict";e.a="#version 300 es\n//grass.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nin vec2 vTexCoord;\nin vec2 vUV;\nin vec3 vPosition;\nin float vHeight;\nin vec3 vGrassNormal;\nin vec3 vColor;\n\nuniform sampler2D texture0;\nuniform float uTerrainSize;\nuniform vec2 uUVWolf;\nuniform float uLightIntensity;\n\nout vec4 FragColor;\n#define EDGE 2.0\n\nfloat diffuse(vec3 N, vec3 L) {\n\treturn max(dot(N, normalize(L)), 0.0);\n}\n\nvec3 diffuse(vec3 N, vec3 L, vec3 C) {\n\treturn diffuse(N, L) * C;\n}\n\nfloat contrast(float mValue, float mScale, float mMidPoint) {\n\treturn clamp( (mValue - mMidPoint) * mScale + mMidPoint, 0.0, 1.0);\n}\n\nfloat contrast(float mValue, float mScale) {\n\treturn contrast(mValue,  mScale, .5);\n}\n\nfloat getShadow(vec2 uv) {\n\tconst float RANGE = 0.035;\n\tuv.y = contrast(uv.y, 0.5);\n\tfloat distWolf = distance(uv, uUVWolf);\n\tfloat shadowWolf = smoothstep(RANGE, 0.0, distWolf);\n\treturn shadowWolf * 0.2;\n}\n\nvoid main(void) {\n\n\tfloat opacity \t= 1.0;\n\tfloat absz \t\t= abs(vPosition.z);\n\topacity \t\t= smoothstep(uTerrainSize, uTerrainSize - EDGE, absz);\n\t\n\tvec4 color \t\t= texture(texture0, vTexCoord);\n\tcolor.a \t\t*= opacity;\n\t\n\tif(color.a < 1.) discard;\n\t// color.rgb\t\t*= vColor*1.4;\n\n\tfloat d \t\t= diffuse(vGrassNormal, vec3(1.0));\n\td \t\t\t\t= mix(d, 1.0, .56);\n\tcolor.rgb \t\t*= d * uLightIntensity;\n\n\tfloat shadowWolf = getShadow(vUV);\n\tcolor -= shadowWolf;\n\n    FragColor \t= color;\n\n    // FragColor.rgb *= vHeight;\n}"},60:function(t,e,n){"use strict";e.a="#version 300 es\n\n// debug.vert\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nin vec3 normal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform sampler2D texture0;\nuniform float uMaxHeight;\n\nout vec2 vTextureCoord;\nout vec3 vNormal;\nvoid main(void) {\n\tvec3 position \t\t\t= position;\n\tfloat colorHeight \t\t= texture(texture0, texCoord).r;\n\tposition.y \t\t\t\t+= colorHeight * uMaxHeight;\n\n    gl_Position\t\t\t\t= uProjectionMatrix * uViewMatrix * vec4(position, 1.0);\n\n\tvTextureCoord\t\t\t= texCoord;\n\tvNormal \t\t\t\t= normal;\n}"},61:function(t,e,n){"use strict";e.a="#version 300 es\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nin vec2 vTextureCoord;\nuniform sampler2D textureNormal;\nuniform vec3 uBaseColor;\nuniform vec2 uUVWolf;\nuniform float uLightIntensity;\nout vec4 FragColor;\n\nfloat diffuse(vec3 N, vec3 L) {\n\treturn max(dot(N, normalize(L)), 0.0);\n}\n\nvec3 diffuse(vec3 N, vec3 L, vec3 C) {\n\treturn diffuse(N, L) * C;\n}\n\nfloat contrast(float mValue, float mScale, float mMidPoint) {\n\treturn clamp( (mValue - mMidPoint) * mScale + mMidPoint, 0.0, 1.0);\n}\n\nfloat contrast(float mValue, float mScale) {\n\treturn contrast(mValue,  mScale, .5);\n}\n\nfloat getShadow(vec2 uv) {\n\tconst float RANGE = 0.035;\n\tuv.y = contrast(uv.y, 0.5);\n\tfloat distWolf = distance(uv, uUVWolf);\n\tfloat shadowWolf = smoothstep(RANGE, 0.0, distWolf);\n\treturn shadowWolf * 0.2;\n}\n\nvoid main(void) {\n\tvec3 N \t\t= texture(textureNormal, vTextureCoord).rgb * 2.0 - 1.0;\n\tfloat d \t= diffuse(N, vec3(1.0));\n\td \t\t\t= mix(d, 1.0, .6);\n\tvec3 color \t= uBaseColor * d;\n\n\tfloat shadowWolf = getShadow(vTextureCoord);\n\t// color -= shadowWolf;\n\n\tcolor \t\t*= uLightIntensity;\n\n    FragColor = vec4(color, 1.0);\n}"},62:function(t,e,n){"use strict";e.a="#version 300 es\n#define SHADER_NAME NOISE_FRAG\n// noise.frag\n\nprecision highp float;\n#define GLSLIFY 1\nuniform float mTime;\nuniform float uSeed;\nuniform float uNoiseScale;\nin vec2 vTexCoord;\nlayout (location = 0) out vec4 textureHeight;\nlayout (location = 1) out vec4 textureNormal;\nlayout (location = 2) out vec4 textureNoise;\n\nvec4 permute(vec4 x) {  return mod(((x*34.0)+1.0)*x, 289.0);    }\nvec4 taylorInvSqrt(vec4 r) {    return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v){\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 = v - i + dot(i, C.xxx) ;\n    \n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n    \n    i = mod(i, 289.0 );\n    vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n    float n_ = 1.0/7.0;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    \n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);\n    \n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n    \n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    \n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    \n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    \n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    \n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    \n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(float x, float y, float z){\n    return snoise(vec3(x, y, z));\n}\n\nfloat getNoise(vec2 uv) {\n    return snoise(uv.x * uNoiseScale, uv.y * uNoiseScale + mTime, uSeed);\n}\n\nfloat getNoise(vec2 uv, vec2 offset) {\n    return getNoise(uv + offset);\n}\n\nvoid main(void) {\n    const vec2 size     = vec2(2.0, 0.0);\n    const vec3 off      = vec3(-1.0, 0, 1.0);\n    float s11           = getNoise(vTexCoord);\n    float s01           = getNoise(vTexCoord, off.xy);\n    float s21           = getNoise(vTexCoord, off.zy);\n    float s10           = getNoise(vTexCoord, off.yx);\n    float s12           = getNoise(vTexCoord, off.yz);\n\n    vec3 va             = normalize(vec3(size.x, s21-s01, size.y)); \n    vec3 vb             = normalize(vec3(size.y, s12-s10, -size.x));\n    vec4 bump           = vec4( cross(va,vb) * .5 + .5, 1.0 );\n\n    float noise         = s11;\n\n    // float noisex        = snoise(vec3(vTexCoord.xy*uNoiseScale, uTime * 0.25));\n    // float noisey        = snoise(vec3(vTexCoord.yx*uNoiseScale, uTime * 0.25));\n\n    float noisex        = snoise(vTexCoord.x * uNoiseScale, vTexCoord.y * uNoiseScale + mTime, mTime);\n    float noisey        = snoise(vTexCoord.y * uNoiseScale + mTime, vTexCoord.x * uNoiseScale, mTime);\n\n    textureHeight      = vec4(noise, noise, noise, 1.0);\n    textureNormal      = bump;\n    textureNoise      = vec4(noisex, noisey, 0.0, 1.0);\n\n}"},80:function(t,e,n){"use strict";n.r(e),n.d(e,"default",(function(){return E}));var o=n(2),r=n(43),i=n(42),s=n(58),a=n(59),c=n(60),u=n(61),l=n(62),f=n(4),h=n(45),m=n(1),v=n(0),d=n(46),x=n(55),g=n(54),p=n(52);const T=function(t,e){return t+Math.random()*(e-t)},_=[[64/255,109/255,26/255],[97/255,148/255,41/255],[113/255,162/255,55/255],[98/255,154/255,39/255],[128/255,171/255,71/255]],w=function(t,e){let n=t[0]-e[0],o=t[2]-e[2];return Math.sqrt(n*n+o*o)},y=["grass","grass1","grass2","grass3"];class E extends r.a{constructor(){super(),Object(o.a)(this,"_traveled",0),Object(o.a)(this,"_lightIntensity",new x.a(1,.01)),Object(o.a)(this,"_speed",new x.a(.01,.005))}init(){this.prg=this.compile(s.a,a.a),this.floorPrg=this.compile(c.a,u.a),window.params={gamma:2.2,exposure:5,terrainSize:175,maxHeight:1,grassRange:20,speed:-.01,time:0,noiseScale:2.5,isOne:!1,numGrass:800,grassColor:[98,152,83],fogColor:[253,232,153].map(t=>t/255*1)};const t=[0,2.5,-8.5],{terrainSize:e}=params;let n=t[0]/e*.5+.5,o=1-(t[2]/e*.5+.5);this.uvOffset=[n,o],this._vNoise=new d.a(l.a),this.time=255*Math.random(),this.seed=255*Math.random(),this.test=new x.a(0)}_setGUI(){this.addRadio("grass3",y,"grass type",this.attrib.bind(this))}attrib(){this.grass&&(this.grass=null);const t=[],e=[],n=[],o=[];let r=2*params.numGrass;const s=params.terrainSize/2*.8;this.range=s;let a=0;const c=2.5,u=m.b.create();function l(t,e){let n=m.e.clone(t);return m.b.identity(u,u),m.b.rotateY(u,u,e),m.e.transformMat4(n,n,u),n}function h(r){t.push(l([-c,-2.5,0],r)),t.push(l([c,-2.5,0],r)),t.push(l([c,0,0],r)),t.push(l([-c,0,0],r)),e.push([0,0]),e.push([1,0]),e.push([1,1]),e.push([0,1]),o.push(l([0,0,1],r)),o.push(l([0,0,1],r)),o.push(l([0,0,1],r)),o.push(l([0,0,1],r)),n.push(4*a+0),n.push(4*a+1),n.push(4*a+2),n.push(4*a+0),n.push(4*a+2),n.push(4*a+3),a++}const v=Math.PI/180;h(0),h(120*v),h(240*v);const d=params.terrainSize;this.grass=function(r){const i=new f.a(void 0,"grass");i.bufferVertex(t),i.bufferNormal(o),i.bufferTexCoord(e),i.bufferIndex(n);const a=[],c=[],u=[];let l=0;function h(t){if(0==a.length)return!1;let e,n;for(let o=0;o<a.length;o++)if(e=a[o],n=w(e,t),n<1.14)return!0;return!1}for(let t=0;t<r;t++){let t;l=0;do{t=[T(-s,s),T(1.65,1.5),T(-s,s)],l++}while(h(t)&&l<100);a.push(t),c.push(_[Math.floor(Math.random()*_.length)]),u.push([Math.random()>.5?0:.5,Math.random()*Math.PI*2])}return i.bufferInstance(a,"aPosOffset"),i.bufferInstance(c,"aColor"),i.bufferInstance(u,"aExtra"),i}(r),this.floor=i.a.plane(d,d,125,"xz"),this.floorColor=[64/255,122/255,42/255],this.horse&&(this.horse.scale=.08)}prepare(){this.orbital.radius=80,this.orbital.rx.value=-Math.PI/2,this.orbital.ry.value=.25,this.orbital.ry.limit(.2,.3),this.orbital.offset=[0,5,0],this.orbital.target=[0,5,0];this._fboNoise=new h.a(64,64,{},3),v.a.srcBlend(),this.env="studio9",this.textureIrr=getAssets[this.env+"_irradiance"],this.textureRad=getAssets[this.env+"_radiance"],this.textureBrdf=getAssets.brdfLUT;const{gltfInfo:t}=getAssets.horse,{meshes:e}=t.output,n=e[0],{uniforms:o}=n.material;o.uBRDFMap=this.textureBrdf,o.uIrradianceMap=this.textureIrr,o.uRadianceMap=this.textureRad,o.uLightColor=[15,15,15],o.uLightDirection=[0,-2,-1.8],o.uGamma=2.4,n.scale=.08,this.horse=n,this.sky=new g.a(125),this.horseInstance=new p.a(n.material.vs,n.material.fs,n,this._caculateMatrix())}_caculateMatrix(t=10){const e=[];let n,o,r;for(let i=0;i<t;i++){const t=T(.06,.07),i=m.b.create();let s=40*(2*Math.random()-1);n=s,s=1*Math.random(),o=s,s=40*(2*Math.random()-1),r=s,m.b.translate(i,i,[n,o,r]),m.b.scale(i,i,[t,t,t]),e.push(i)}return e}_renderNoise(){const{speed:t,noiseScale:e,isOne:n}=params;this.time+=t,this.test.value=n?1:0,this._vNoise.draw({mTime:this.time,uSeed:this.seed,uNoiseScale:e})}_renderFloor(t,e){const{maxHeight:n}=params,o=params.grassColor.map(t=>t/255);this.floorPrg.use(),this.floorPrg.style({texture0:t,textureNormal:e,uMaxHeight:n,uBaseColor:o,uUVWolf:this.uvOffset,uLightIntensity:this._lightIntensity.value}),v.a.draw(this.floor)}_renderGrass(t,e,n){y.map(t=>{this.params[t]&&(this._textureGrass=getAssets[t])});const{maxHeight:o,terrainSize:r,speed:i,noiseScale:s,isOne:a}=params,c=r/s;this._traveled+=i;const u=this._traveled*c;this.prg.use(),this.prg.style({texture0:this._textureGrass,textureHeight:t,textureNormal:e,textureNoise:n,uMaxHeight:o,uTerrainSize:this.range,uDistForward:u,uUVWolf:this.uvOffset,uLightIntensity:this._lightIntensity.value}),v.a.draw(this.grass)}_renderHorse(){this.horse.animate&&(this.horse.animateSpeed=2.5,this.horse.animate()),this.horseInstance.draw(this.horse.material.uniforms)}render(){params.speed=-this._speed.value,params.time+=params.speed,v.a.clear(),this._fboNoise.bind(),v.a.clear(0,0,0,0),this._renderNoise(),this._fboNoise.unbind();const t=this._fboNoise.getTexture(0),e=this._fboNoise.getTexture(1),n=this._fboNoise.getTexture(2);v.c.disable(v.c.CULL_FACE),this._renderGrass(t,e,n),v.c.enable(v.c.CULL_FACE),this._renderFloor(t,e),this._renderHorse(),this.sky.draw({texture0:getAssets.nightSky,uFogColor:params.fogColor})}}}}]);