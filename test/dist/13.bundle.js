(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{30:function(e,i){e.exports="#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec2 TexCoords;\nout vec3 Normal;\nout vec3 FragPos;\n\nvoid main()\n{\n    FragPos = vec3(mMatrix * vec4(position, 1.0));\n    Normal = mat3(transpose(inverse(mMatrix))) * normal;\n    TexCoords = texCoord;\n\n    gl_Position = pMatrix * vMatrix * vec4(FragPos, 1.0);\n}\n"},40:function(e,i,t){"use strict";t.r(i),t.d(i,"default",function(){return w});var n=t(2),a=t(5),r=t(4),s=t(30),o=t.n(s),l=t(62),c=t.n(l),m=t(63),u=t.n(m),d=t(64),f=t.n(d),h=t(65),p=t.n(h),g=t(66),v=t.n(g),x=t(3),b=t.n(x),P=t(1),L=t(0);let C=P.a.identity(P.a.create()),F=P.a.identity(P.a.create());const D=[.33,.42,.18],M=[.2,-1,-.3].map(e=>50*e),T=[[0,0,0],[2,5,-15],[-1.5,-2.2,-2.5],[-3.8,-2,-12.3],[2.4,-.4,-3.5],[-1.7,3,-7.5],[1.3,-2,-2.5],[1.5,2,-2.5],[1.5,.2,-1.5],[-1.3,1,-1.5]];class w extends a.default{constructor(){super(),Object(n.a)(this,"count",0)}init(){this.prg=this.compile(o.a,c.a),this.pointPrg=this.compile(o.a,u.a),this.spotPrg=this.compile(o.a,f.a),this.lampPrg=this.compile(v.a,p.a)}attrib(){let e=new r.a;e.bufferData([-.5,-.5,-.5,0,0,-1,0,0,.5,-.5,-.5,0,0,-1,1,0,.5,.5,-.5,0,0,-1,1,1,.5,.5,-.5,0,0,-1,1,1,-.5,.5,-.5,0,0,-1,0,1,-.5,-.5,-.5,0,0,-1,0,0,-.5,-.5,.5,0,0,1,0,0,.5,-.5,.5,0,0,1,1,0,.5,.5,.5,0,0,1,1,1,.5,.5,.5,0,0,1,1,1,-.5,.5,.5,0,0,1,0,1,-.5,-.5,.5,0,0,1,0,0,-.5,.5,.5,-1,0,0,1,0,-.5,.5,-.5,-1,0,0,1,1,-.5,-.5,-.5,-1,0,0,0,1,-.5,-.5,-.5,-1,0,0,0,1,-.5,-.5,.5,-1,0,0,0,0,-.5,.5,.5,-1,0,0,1,0,.5,.5,.5,1,0,0,1,0,.5,.5,-.5,1,0,0,1,1,.5,-.5,-.5,1,0,0,0,1,.5,-.5,-.5,1,0,0,0,1,.5,-.5,.5,1,0,0,0,0,.5,.5,.5,1,0,0,1,0,-.5,-.5,-.5,0,-1,0,0,1,.5,-.5,-.5,0,-1,0,1,1,.5,-.5,.5,0,-1,0,1,0,.5,-.5,.5,0,-1,0,1,0,-.5,-.5,.5,0,-1,0,0,0,-.5,-.5,-.5,0,-1,0,0,1,-.5,.5,-.5,0,1,0,0,1,.5,.5,-.5,0,1,0,1,1,.5,.5,.5,0,1,0,1,0,.5,.5,.5,0,1,0,1,0,-.5,.5,.5,0,1,0,0,0,-.5,.5,-.5,0,1,0,0,1],["position","normal","texCoord"],[3,3,2]),this.cube=e,this.lampVao=L.d.createVertexArray(),L.d.bindVertexArray(this.lampVao),L.d.bindBuffer(L.d.ARRAY_BUFFER,this.cube._buffers[0].buffer.buffer),L.d.vertexAttribPointer(0,3,L.d.FLOAT,!1,32,0),L.d.enableVertexAttribArray(0)}prepare(){L.d.enable(L.d.DEPTH_TEST),L.d.depthFunc(L.d.LEQUAL),L.d.clearColor(.3,.3,.3,1),L.d.clearDepth(1),this.diffuseTexture=new b.a(L.d,L.d.RGBA).fromImage(getAssets.cubeDiffuse),this.specularTexture=new b.a(L.d,L.d.RGBA).fromImage(getAssets.cubeSpecular),this.emissionTexture=new b.a(L.d,L.d.RGBA).fromImage(getAssets.cubeEmission),this.camera.radius=6}_setGUI(){this.addGUIParams({directionalLight:!0,pointLight:!1,spotLight:!1});let e=this.gui.addFolder("diffuse model");e.add(this.params,"directionalLight").listen().onChange(()=>{this.setChecked("directionalLight")}),e.add(this.params,"pointLight").listen().onChange(()=>{this.setChecked("pointLight")}),e.add(this.params,"spotLight").listen().onChange(()=>{this.setChecked("spotLight")}),e.open()}setChecked(e){this.params.directionalLight=!1,this.params.pointLight=!1,this.params.spotLight=!1,this.params[e]=!0}uniform(){C=this.camera.viewMatrix,P.a.perspective(F,Object(L.e)(60),L.a.clientWidth/L.a.clientHeight,.1,100)}render(){L.d.clear(L.d.COLOR_BUFFER_BIT|L.d.DEPTH_BUFFER_BIT),this.diffuseTexture.bind(0),this.specularTexture.bind(1),this.emissionTexture.bind(2),this.params.directionalLight?(this.prg.use(),this.cube.bind(this.prg),this.prg.style({vMatrix:C,pMatrix:F,camPos:this.camera.cameraPos,"material.shininess":30,"material.diffuse":0,"material.specular":1,"material.emission":2,"light.ambient":[.2,.2,.2],"light.diffuse":[.5,.5,.5],"light.specular":[1,1,1],"light.direction":[-M[0],-M[1],-M[2]]}),T.map((e,i)=>{let t=P.a.create();P.a.rotate(t,t,Object(L.e)(20*i),M),P.a.translate(t,t,e),this.prg.style({mMatrix:t}),this.cube.draw()})):this.params.pointLight?(this.pointPrg.use(),this.cube.bind(this.pointPrg),this.pointPrg.style({vMatrix:C,pMatrix:F,camPos:this.camera.cameraPos,"material.shininess":30,"material.diffuse":0,"material.specular":1,"material.emission":2,"light.ambient":[.2,.2,.2],"light.diffuse":[.5,.5,.5],"light.specular":[1,1,1],"light.position":[0,0,1],"light.constant":1,"light.linear":.09,"light.quadratic":.032}),T.map((e,i)=>{let t=P.a.create();P.a.rotate(t,t,Object(L.e)(20*i),M),P.a.translate(t,t,e),this.pointPrg.style({mMatrix:t}),this.cube.draw()})):this.params.spotLight&&(this.spotPrg.use(),this.cube.bind(this.spotPrg),this.spotPrg.style({vMatrix:C,pMatrix:F,camPos:this.camera.cameraPos,"material.shininess":30,"material.diffuse":0,"material.specular":1,"material.emission":2,"light.ambient":[.1,.1,.1],"light.diffuse":[.5,.5,.5],"light.specular":[1,1,1],"light.position":this.camera.cameraPos,"light.direction":[-this.camera.cameraPos[0],-this.camera.cameraPos[1],-this.camera.cameraPos[2]],"light.cutOff":Object(L.e)(12.5)}),T.map((e,i)=>{let t=P.a.create();P.a.rotate(t,t,Object(L.e)(20*i),M),P.a.translate(t,t,e),this.spotPrg.style({mMatrix:t}),this.cube.draw()}));let e=P.a.identity(P.a.create());P.a.scale(e,e,[.05,.05,.05]),P.a.translate(e,e,M),this.lampPrg.use(),this.lampPrg.style({mMatrix:e,vMatrix:C,pMatrix:F,lightColor:D}),L.d.bindVertexArray(this.lampVao),L.d.drawArrays(L.d.TRIANGLES,0,36)}}},62:function(e,i){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    sampler2D emission;\n    float shininess;\n};\nstruct Light {\n    // vec3 position; // directional light only has direction\n    vec3 direction;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\n\nvoid main()\n{\n  // ambient\n  vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\n\n  // diffuse\n  vec3 norm = normalize(Normal);\n  // vec3 lightDir = normalize(light.position - FragPos);\n  vec3 lightDir = normalize(-light.direction);\n  float diff = max(dot(norm, lightDir), 0.0);\n   vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\n\n  // specular\n  vec3 viewDir = normalize(camPos - FragPos);\n  vec3 reflectDir = reflect(-lightDir, norm);\n  float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n  vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\n\n  vec3 emission = vec3(0.);//texture(material.emission, TexCoords).rgb;\n\n  vec3 result = ambient + diffuse + specular + emission;\n  FragColor = vec4(result, 1.0);\n}\n"},63:function(e,i){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    float shininess;\n};\n\nstruct Light {\n    vec3 position;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\n    float constant;\n    float linear;\n    float quadratic;\n};\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\nvoid main()\n{\n    // ambient\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\n\n    // diffuse\n    vec3 norm = normalize(Normal);\n    vec3 lightDir = normalize(light.position - FragPos);\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\n\n    // specular\n    vec3 viewDir = normalize(camPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\n\n    // attenuation\n    float distance    = length(light.position - FragPos);\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n\n    ambient  *= attenuation;\n    diffuse   *= attenuation;\n    specular *= attenuation;\n\n    vec3 result = ambient + diffuse + specular;\n    FragColor = vec4(result, 1.0);\n}\n"},64:function(e,i){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    float shininess;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 direction;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\n    float cutOff;\n};\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\nvoid main()\n{\n  vec3 result;\n  vec3 lightDir = normalize(light.position - FragPos);\n  float theta = dot(lightDir, normalize(-light.direction));\n  if(theta > light.cutOff)\n  {\n    // ambient\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\n\n    // diffuse\n    vec3 norm = normalize(Normal);\n\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\n\n    // specular\n    vec3 viewDir = normalize(camPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\n\n    result = ambient + diffuse + specular;\n  }\n  else {\n    // 否则，使用环境光，让场景在聚光之外时不至于完全黑暗\n    result = light.ambient * vec3(texture(material.diffuse, TexCoords));\n  }\n\n  FragColor = vec4(result, 1.0);\n}\n"},65:function(e,i){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\n\nvoid main() {\n  FragColor = vec4(1.0);\n}\n"},66:function(e,i){e.exports="#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"}}]);