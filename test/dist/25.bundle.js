(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{106:function(e,n,o){"use strict";o.r(n),o.d(n,"default",(function(){return l}));var t=o(43),r=o(4),a=o(53),i=o(1),s=o(0);const c=[0,0,3];class l extends t.a{constructor(){super()}init(){this.prg=this.compile(a.a,"#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec3 vPosition;\nin vec2 vTexCoord;\nin vec3 TangentLightPos;\nin vec3 TangentViewPos;\nin vec3 TangentFragPos;\n\nuniform sampler2D diffuseMap;\nuniform sampler2D normalMap;\nuniform sampler2D heightMap;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nuniform float heightScale;\n\nvec2 textureOffset(vec2 vTexCoord, vec3 viewDir)\n{ \n    float height =  texture(heightMap, vTexCoord).r;    \n    vec2 p = viewDir.xy / viewDir.z * (height * heightScale);\n    return vTexCoord - p;    \n} \n\nvoid main()\n{\n    \n\n    vec3 viewDir = normalize(TangentViewPos - TangentFragPos);\n    vec2 vTexCoord = textureOffset(vTexCoord,  viewDir);\n    if(vTexCoord.x > 1.0 || vTexCoord.y > 1.0 || vTexCoord.x < 0.0 || vTexCoord.y < 0.0)\n    discard;\n\n     // obtain normal from normal map in range [0,1]\n    vec3 normal = texture(normalMap, vTexCoord).rgb;\n    // transform normal vector to range [-1,1]\n    normal = normalize(normal * 2.0 - 1.0);  // this normal is in tangent space\n\n    // get diffuse color\n    vec3 color = texture(diffuseMap, vTexCoord).rgb;\n    // ambient\n    vec3 ambient = 0.1 * color;\n    // diffuse\n    vec3 lightDir = normalize(TangentLightPos - TangentFragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * color;\n    // specular\n    \n\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n\n    vec3 specular = vec3(0.2) * spec;\n    FragColor = vec4(ambient + diffuse + specular, 1.0);\n}\n")}attrib(){const e=(e=>{const n=i.e.fromValues(-1,0,-1),o=i.e.fromValues(-1,0,1),t=i.e.fromValues(1,0,1),r=i.e.fromValues(1,0,-1),a=i.d.fromValues(0,1),s=i.d.fromValues(0,0),c=i.d.fromValues(1,0),l=i.d.fromValues(1,1),u=i.e.fromValues(0,1,0),m=i.e.create(),f=i.e.create(),v=i.d.create(),g=i.d.create();i.e.subtract(m,o,n),i.e.subtract(f,t,n),i.d.subtract(v,s,a),i.d.subtract(g,c,a);let d=1/(v[0]*g[1]-g[0]*v[1]);const h=i.e.create(),p=i.e.create(),T=i.e.create(),x=i.e.create();h[0]=d*(g[1]*m[0]-v[1]*f[0]),h[1]=d*(g[1]*m[1]-v[1]*f[1]),h[2]=d*(g[1]*m[2]-v[1]*f[2]),i.e.normalize(h,h),p[0]=d*(-g[0]*m[0]+v[0]*f[0]),p[1]=d*(-g[0]*m[1]+v[0]*f[1]),p[2]=d*(-g[0]*m[2]+v[0]*f[2]),i.e.normalize(p,p),i.e.subtract(m,t,n),i.e.subtract(f,r,n),i.d.subtract(v,c,a),i.d.subtract(g,l,a),d=1/(v[0]*g[1]-g[0]*v[1]),T[0]=d*(g[1]*m[0]-v[1]*f[0]),T[1]=d*(g[1]*m[1]-v[1]*f[1]),T[2]=d*(g[1]*m[2]-v[1]*f[2]),i.e.normalize(T,T),x[0]=d*(-g[0]*m[0]+v[0]*f[0]),x[1]=d*(-g[0]*m[1]+v[0]*f[1]),x[2]=d*(-g[0]*m[2]+v[0]*f[2]),i.e.normalize(x,x);const b=[[n,o,t,n,t,r],Array.from({length:6}).fill(u),[a,s,c,a,c,l],[h,h,h,T,T,T],[Array.from({length:3}).fill(p),Array.from({length:3}).fill(x)]];return console.log(b),b})();this.quad=new r.a,this.quad.bufferVertex(e[0]),this.quad.bufferNormal(e[1]),this.quad.bufferTexCoord(e[2]),this.quad.bufferData(e[3],"tangent",3),this.quad.bufferData(e[4],"bitangent",3),this.quad.bufferIndex([0,1,2,3,4,5])}prepare(){this.orbital.target=[0,0,0],s.c.enable(s.c.DEPTH_TEST),s.c.depthFunc(s.c.LEQUAL),s.c.clearColor(.3,.3,.3,1),s.c.clearDepth(1)}uniform(){let e=i.b.create();i.b.rotateX(e,e,Object(s.d)(90)),i.b.scale(e,e,[1.8,1.8,1.8]),this.prg.use(),this.prg.style({mMatrix:e,viewPos:this.camera.position,lightPos:c,diffuseMap:getAssets.bricks2,normalMap:getAssets.bricks2Normal,heightMap:getAssets.bricks2Disp,heightScale:.1})}render(){s.c.clear(s.c.COLOR_BUFFER_BIT|s.c.DEPTH_BUFFER_BIT),this.prg.use(),s.a.draw(this.quad)}}},53:function(e,n,o){"use strict";n.a="#version 300 es\n// normal map\nprecision highp float;\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\nlayout (location = 3) in vec3 tangent;\nlayout (location = 4) in vec3 bitangent;\n\nout vec3 vPosition;\nout vec2 vTexCoord;\nout vec3 TangentLightPos;\nout vec3 TangentViewPos;\nout vec3 TangentFragPos;\n\nuniform mat4 uProjectionMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 mMatrix;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nvoid main() {\n  vPosition = vec3(mMatrix * vec4(position, 1.));\n  vTexCoord = texCoord;\n\n  mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n  vec3 T = normalize(normalMatrix * tangent);\n  vec3 N = normalize(normalMatrix * normal);\n  T = normalize(T - dot(T, N) * N);\n  vec3 B = cross(N, T);\n\n  mat3 TBN = transpose(mat3(T, B, N));\n  TangentLightPos = TBN * lightPos;\n  TangentViewPos  = TBN * viewPos;\n  TangentFragPos  = TBN * vPosition;\n\n  gl_Position = uProjectionMatrix * uViewMatrix * mMatrix * vec4(position, 1.0);\n}\n"}}]);