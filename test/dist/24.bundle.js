(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{103:function(n,t,e){"use strict";e.r(t),e.d(t,"default",(function(){return d}));var o=e(2),a=e(43),r=e(0),i=e(8),s=e(68),l=e(1);function c(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,o)}return e}function m(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?c(Object(e),!0).forEach((function(t){Object(o.a)(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):c(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}const f=[[-10,10,10],[10,10,10],[-10,-10,10],[10,-10,10]],u=[[10,10,10],[10,10,10],[10,10,10],[10,10,10]];class d extends a.a{constructor(){super()}init(){this.prg=this.compile(i.a,"#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\nuniform bool lambertDiffuse;\nstruct Light {\n    int Type;\n    vec3 Position;\n    vec3 Direction;\n    vec3 Color;\n\n    float Linear;\n    float Quadratic;\n};\nconst int NR_LIGHTS = 4;\n\nuniform Light lights[NR_LIGHTS];\nuniform vec3 uCameraPos;\nuniform float uGamma;\nuniform float uExposure;\n\nin vec3 vNormal;\nin vec3 vPosition;\nout vec4 FragColor;\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\nfloat AnisotropicDis(float x, float y, vec3 N, vec3 wh)\n{\n    float ex = x;\n    float ey = y;\n    if(ex > 1000.) ex = 1000.;\n    if(ey > 1000.) ey = 1000.;\n    float cosTheta = max(dot(N, wh), 0.0);\n    float d = 1. - cosTheta * cosTheta;\n    if(d == 0.) return 0.;\n    float e = (ex * wh.x * wh.x + ey * wh.y * wh.y) / d;\n    float INV_TWOPI = .5 * PI;\n    return sqrt((ex + 2.) * (ey + 2.)) * INV_TWOPI * pow(cosTheta, e);\n}\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\n// Filmic tonemapping from\n// http://filmicgames.com/archives/75\n\nconst float A = 0.15;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\n\nvec3 Uncharted2Tonemap( vec3 x )\n{\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(uCameraPos - vPosition);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < NR_LIGHTS; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L;\n        if(lights[i].Type == 0) { // point light\n            L = normalize(lights[i].Position - vPosition);\n        } else {\n            L = normalize(-lights[i].Direction);\n        }\n        \n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        vec3 radiance;\n        if(lights[i].Type == 0) {\n            float distance = length(lights[i].Position - vPosition);\n            float attenuation = 1.0 / (1.0 + lights[i].Linear * distance + lights[i].Quadratic * distance * distance);\n            radiance = lights[i].Color * attenuation;\n        } else {\n            radiance = lights[i].Color;\n        }\n\n        \n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        // float NDF = AnisotropicDis(20. ,1000., N, H);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n\t// apply the tone-mapping\n\tcolor\t\t\t\t= Uncharted2Tonemap( color * uExposure );\n\t// white balance\n\tcolor\t\t\t\t= color * ( 1.0 / Uncharted2Tonemap( vec3( 20.0 ) ) );\n\n    // gamma correct\n    color = pow(color, vec3(1.0/uGamma));\n\n    FragColor = vec4(color, 1.0);\n\n}\n"),this.mapPrg=this.compile(i.a,s.a)}attrib(){this.mesh=getAssets.orb}prepare(){this.orbital.radius=16,this.orbital.target=[0,5,0]}uniform(){}_setGUI(){this.addGUIParams({map:"none"}),this.addRadio("orenNayar",["lambert","orenNayar"],"diffuse model");const n=this.gui.addFolder("material map");n.add(this.params,"map",["none","plastic","wall","gold","grass","rusted_iron","wood"]).listen().onChange(()=>{this.setTexture()}),n.open(),this.addPbrParams({metallic:.88,roughness:.26,color:[230,206,24],gamma:2.2,exposure:1})}setTexture(){let n=this.params.map;"none"!==n&&(this.texture0=getAssets[n+"Albedo"],this.texture1=getAssets[n+"Roughness"],this.texture2=getAssets[n+"Metallic"],this.texture3=getAssets[n+"Ao"],this.texture4=getAssets[n+"Normal"])}render(){r.a.clear();const{metallic:n,lambert:t,roughness:e,color:o,gamma:a,exposure:i}=this.params,s=l.b.create(),c={uGamma:a,uExposure:i,lambertDiffuse:t};if("none"===this.params.map){this.prg.use();for(let t=0;t<f.length;t++)this.prg.uniform(`lights[${t}].Type`,"uniform1i",1),this.prg.style(m(m({[`lights[${t}].Position`]:f[t],[`lights[${t}].Direction`]:this.camera.position.map(n=>-n),[`lights[${t}].Color`]:u[t],[`lights[${t}].Linear`]:.1,[`lights[${t}].Quadratic`]:.12},c),{},{albedo:o.map(n=>n/255),ao:.1,metallic:n,roughness:e,mMatrix:s}));r.a.draw(this.mesh)}else this.mapPrg.use(),this.mapPrg.style(m(m({},c),{},{mMatrix:s,albedoMap:this.texture0,roughnessMap:this.texture1,metallicMap:this.texture2,aoMap:this.texture3,normalMap:this.texture4})),r.a.draw(this.mesh)}}},68:function(n,t,e){"use strict";t.a="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n// material map\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 uCameraPos;\n\nin vec3 vNormal;\nin vec3 vPosition;\nin vec2 vTexCoord;\nout vec4 FragColor;\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture(normalMap, vTexCoord).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(vPosition);\n    vec3 Q2  = dFdy(vPosition);\n    vec2 st1 = dFdx(vTexCoord);\n    vec2 st2 = dFdy(vTexCoord);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture(albedoMap, vTexCoord).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture(metallicMap, vTexCoord).r;\n    float roughness = texture(roughnessMap, vTexCoord).r;\n    float ao        = texture(aoMap, vTexCoord).r;\n    vec3 V = normalize(uCameraPos - vPosition);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - vPosition);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - vPosition);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    FragColor = vec4(color, 1.);\n\n}\n"}}]);