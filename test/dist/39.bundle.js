(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{105:function(n,t,o){"use strict";o.r(t),o.d(t,"default",(function(){return s}));var e=o(43),i=o(42),r=o(1),a=o(0);class s extends e.a{constructor(){super()}init(){this.prg=this.basicColor("#version 300 es\n// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n#define NUM_OCTAVES 5\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise_0(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise_0(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise_0(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise_0(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise_0(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise_0(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nin vec3 normal;\n\nuniform mat4 mMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float terrainHeight;\nuniform float uTime;\n\nout vec2 vTexCoord;\nout vec3 vNormal;\n\nfloat random(float _x) {\n    return fract(sin(_x)*1e4);\n}\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid main(void) {\n    vec3 Position = position;\n\n    // Position = vec3(position.x, noise(position.xz - vec2(cos(uTime*0.15/50.),sin(uTime*0.1/50.))) * terrainHeight, position.z);\n    float height = fbm(vec3(texCoord, uTime / 1000.));\n    Position.y += height * 2.;\n\n    gl_Position = uProjectionMatrix * uViewMatrix * mMatrix * vec4(Position, 1.0);\n    gl_PointSize = 3.;\n    vTexCoord = texCoord;\n    vNormal = normal;\n}")}attrib(){this.plane=i.a.plane(8,8,125,"xz",a.c.LINES),this.points=i.a.points([0,0,0],[1,1,1],[2,2,2],[-1,-1,-1])}prepare(){this.orbital.radius=5,this.orbital.offset=[0,2,3]}_setGUI(){this.addRadio("plane",["point","plane"],"mesh type")}uniform(){}render(){a.a.clear(),this.params.point?this.mesh=this.points:this.mesh=this.plane;const n=r.b.create();this.prg.use(),this.prg.style({mMatrix:n,color:[0,.5,.6],terrainHeight:.6}),a.a.draw(this.mesh)}}}}]);