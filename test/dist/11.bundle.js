(window.webpackJsonp=window.webpackJsonp||[]).push([[11,21],{22:function(t,e,i){var r=i(3);function n(t,e){this.gl=t,this.width=0,this.height=0,this.fbo=null;var i=(e=e||a).depth|e.stencil<<1,n=e.type||t.UNSIGNED_BYTE;this.types=Array.isArray(n)?n:[n],this.color=new r(t,e.format),this.attachment=new o(this,i)}function o(t,e){this.fbo=t,this.flags=e,this.buffer=null}n.prototype={resize:function(t,e){this.width===t&&this.height===e||(this.width=0|t,this.height=0|e,null===this.fbo&&this._init(),this._allocate())},bindColor:function(t,e){var i=this.gl;i.activeTexture(i.TEXTURE0+e),i.bindTexture(i.TEXTURE_2D,this.color.id),i.uniform1i(t,e)},bind:function(){var t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,this.fbo),t.viewport(0,0,this.width,this.height)},unbind:function(){var t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null)},clear:function(){var t=this.gl,e=t.COLOR_BUFFER_BIT|this.attachment.clearBits();t.clear(e)},isValid:function(){var t=this.gl;return t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE},getActualType:function(){return this.color.type},dispose:function(){this.gl.deleteFramebuffer(this.fbo),this.color.dispose(),this.attachment.dispose(),this.valid=!1,this.fbo=null,this.gl=null},_init:function(){var t=this.gl;this.fbo=t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this.fbo),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.color.id,0),this.attachment._init()},_allocate:function(){var t=this.gl;this.attachment._allocate(),t.bindFramebuffer(t.FRAMEBUFFER,this.fbo);var e=0,i=this.types[e];do{this.color.fromData(this.width,this.height,null,i),t.getError()}while(!(this.valid=this.isValid())&&(i=this.types[++e]));t.bindFramebuffer(t.FRAMEBUFFER,null)}},o.prototype={_init:function(){var t=this.fbo.gl,e=3&this.flags,i=null;0!==e&&(i=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,i),t.framebufferRenderbuffer(t.FRAMEBUFFER,function(t,e){switch(e){case 1:return 36096;case 2:return 36128;case 3:return 33306;default:throw new Error("unknown attachment type "+e)}}(0,e),t.RENDERBUFFER,i)),this.buffer=i},_allocate:function(){var t=this.fbo.gl,e=3&this.flags;0!==e&&(t.bindRenderbuffer(t.RENDERBUFFER,this.buffer),t.renderbufferStorage(t.RENDERBUFFER,function(t,e){switch(e){case 1:return 33189;case 2:return 36168;case 3:return 34041;default:throw new Error("unknown attachment type "+e)}}(0,e),this.fbo.width,this.fbo.height),t.bindRenderbuffer(t.RENDERBUFFER,null))},dispose:function(){this.buffer&&this.fbo.gl.deleteRenderbuffer(this.buffer),this.buffer=null},clearBits:function(){return(1&this.flags?256:0)|(2&this.flags?1024:0)}};var a={};t.exports=n},44:function(t,e,i){"use strict";i.r(e),i.d(e,"default",function(){return F});var r=i(2),n=i(5),o=i(0),a=i(71),s=i.n(a),l=i(72),c=i.n(l),h=i(73),u=i.n(h),f=i(74),d=i.n(f),v=i(6),p=i(1),m=i(22),b=i.n(m),E=i(4);class F extends n.default{constructor(){super(),Object(r.a)(this,"count",0),Object(r.a)(this,"ortMatrix",p.a.identity(p.a.create()))}init(){this.prg=this.compile(s.a,c.a),this.mPrg=this.compile(u.a,d.a)}attrib(){let{pos:t,index:e,normal:i,color:r}=Object(v.Torus)(64,64,.2,.7),n=new E.a;n.bufferVertex(t),n.bufferIndices(e),n.bufferNormal(i),n.bufferColor(r),this.torus=n;r=[.3,.5,.5,1,.5,.5,.1,1,.5,.5,.1,1,.5,.5,.1,1];e=[0,2,1,1,2,3];let o=new E.a;o.bufferVertex([-1,1,0,1,1,0,-1,-1,0,1,-1,0]),o.bufferIndices(e),o.bufferTexCoord([0,0,1,0,0,1,1,1]),o.bufferColor(r),this.plane=o}prepare(){this.fbo=new b.a(o.d),this.fbo.resize(512,512),o.d.enable(o.d.DEPTH_TEST),o.d.depthFunc(o.d.LEQUAL),o.d.enable(o.d.CULL_FACE)}uniform(){let t=p.a.identity(p.a.create()),e=p.a.identity(p.a.create());this.tmpMatrix=p.a.identity(p.a.create());let i=[],r=[];p.d.transformQuat(i,[0,5,5],this.rotateQ),p.d.transformQuat(r,[0,1,-1],this.rotateQ),this.eyeDirection=i,p.a.lookAt(t,i,[0,0,0],r),p.a.perspective(e,45,o.a.clientWidth/o.a.clientHeight,.1,100),p.a.multiply(this.tmpMatrix,e,t),p.a.lookAt(t,[0,0,.1],[0,0,0],[0,1,0]),p.a.ortho(e,-1,1,-1,1,.1,1),p.a.multiply(this.ortMatrix,e,t)}render(){this.fbo.bind(),this.fbo.clear(),o.d.clearColor(.3,.8,.4,.3),o.d.clearDepth(1),o.d.clear(o.d.COLOR_BUFFER_BIT|o.d.DEPTH_BUFFER_BIT),o.d.cullFace(o.d.FRONT);let t=p.a.identity(p.a.create());p.a.rotate(t,t,2*Math.PI/9,[0,1,0]);let e=p.a.identity(p.a.create());p.a.invert(e,t),this.prg.use(),this.prg.style({vpMatrix:this.tmpMatrix,mMatrix:t,invMatrix:e,lightDirection:[0,-.5,.577],eyeDirection:this.eyeDirection,ambientColor:[0,0,0,0],mirror:!0}),this.torus.bind(this.prg),this.torus.draw(),this.fbo.unbind(),o.d.clearColor(0,.7,.7,1),o.d.clearDepth(1),o.d.clearStencil(0),o.d.clear(o.d.COLOR_BUFFER_BIT|o.d.DEPTH_BUFFER_BIT|o.d.STENCIL_BUFFER_BIT),o.d.cullFace(o.d.BACK),o.d.enable(o.d.STENCIL_TEST),o.d.stencilFunc(o.d.ALWAYS,1,-1),o.d.stencilOp(o.d.KEEP,o.d.KEEP,o.d.REPLACE),t=p.a.identity(t),p.a.translate(t,t,[0,1,0]),p.a.scale(t,t,[1.7,1.7,1.7]),p.a.rotate(t,t,1.5*Math.PI,[1,0,0]),p.a.invert(e,t),this.prg.style({mMatrix:t,invMatrix:e}),this.plane.bind(this.prg,["position","color","normal"]),this.plane.draw(),o.d.stencilFunc(o.d.EQUAL,1,-1),o.d.stencilOp(o.d.KEEP,o.d.KEEP,o.d.KEEP),this.mPrg.use(),this.fbo.bindColor(this.mPrg.texture(),0),this.mPrg.style({alpha:.9,texture:0,ortMatrix:this.ortMatrix}),this.plane.bind(this.mPrg,["position","texCoord"]),this.plane.draw(),o.d.disable(o.d.STENCIL_TEST)}}},6:function(t,e,i){"use strict";function r(t,e,i,r,o){let a,s=[],l=[],c=[],h=[];for(let l=0;l<=t;l++){let u=2*Math.PI/t*l,f=Math.cos(u),d=Math.sin(u);for(let t=0;t<=e;t++){let l=2*Math.PI/e*t,u=(f*i+r)*Math.cos(l),v=d*i,p=(f*i+r)*Math.sin(l);s.push(u,v,p),a=o||n(360/e*t,1,1,1),h.push(a[0],a[1],a[2],a[3]);let m=f*Math.cos(l),b=f*Math.sin(l);c.push(m,d,b)}}for(let i=0;i<t;i++)for(let t=0;t<e;t++){let r=(e+1)*i+t;l.push(r,r+e+1,r+1),l.push(r+e+1,r+e+2,r+1)}return{pos:s,index:l,normal:c,color:h}}function n(t,e,i,r){if(e>1||i>1||r>1)return;let n=t%360,o=Math.floor(n/60),a=n/60-o,s=i*(1-e),l=i*(1-e*a),c=i*(1-e*(1-a)),h=[];if(!e>0&&!e<0)h.push(i,i,i,r);else{let t=[i,l,s,s,c,i],e=[c,i,i,l,s,s],n=[s,s,c,i,i,l];h.push(t[o],e[o],n[o],r)}return h}function o(t,e,i,r){for(var o=[],a=[],s=[],l=[],c=[],h=0;h<=t;h++)for(var u=Math.PI/t*h,f=Math.cos(u),d=Math.sin(u),v=0;v<=e;v++){var p=2*Math.PI/e*v,m=d*i*Math.cos(p),b=f*i,E=d*i*Math.sin(p),F=d*Math.cos(p),g=d*Math.sin(p);if(r)var x=r;else x=n(360/t*h,1,1,1);o.push(m,b,E),a.push(F,f,g),s.push(x[0],x[1],x[2],x[3]),l.push(1-1/e*v,1/t*h)}for(u=0,h=0;h<t;h++)for(v=0;v<e;v++)u=(e+1)*h+v,c.push(u,u+1,u+e+2),c.push(u,u+e+2,u+e+1);return{pos:o,normal:a,color:s,uv:l,index:c}}function a(t,e,i){const r=t/2,n=i/2;return[r,e,n,0,1,0,1,0,-r,e,-n,0,1,0,0,1,-r,e,n,0,1,0,0,0,r,e,n,0,1,0,1,0,r,e,-n,0,1,0,1,1,-r,e,-n,0,1,0,0,1]}i.r(e),i.d(e,"Torus",function(){return r}),i.d(e,"hsva",function(){return n}),i.d(e,"Sphere",function(){return o}),i.d(e,"plane",function(){return a}),i.d(e,"QuadData",function(){return s}),i.d(e,"CubeData",function(){return l});const s=[-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0],l=[-1,-1,-1,0,0,-1,0,0,1,1,-1,0,0,-1,1,1,1,-1,-1,0,0,-1,1,0,1,1,-1,0,0,-1,1,1,-1,-1,-1,0,0,-1,0,0,-1,1,-1,0,0,-1,0,1,-1,-1,1,0,0,1,0,0,1,-1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,-1,1,1,0,0,1,0,1,-1,-1,1,0,0,1,0,0,-1,1,1,-1,0,0,1,0,-1,1,-1,-1,0,0,1,1,-1,-1,-1,-1,0,0,0,1,-1,-1,-1,-1,0,0,0,1,-1,-1,1,-1,0,0,0,0,-1,1,1,-1,0,0,1,0,1,1,1,1,0,0,1,0,1,-1,-1,1,0,0,0,1,1,1,-1,1,0,0,1,1,1,-1,-1,1,0,0,0,1,1,1,1,1,0,0,1,0,1,-1,1,1,0,0,0,0,-1,-1,-1,0,-1,0,0,1,1,-1,-1,0,-1,0,1,1,1,-1,1,0,-1,0,1,0,1,-1,1,0,-1,0,1,0,-1,-1,1,0,-1,0,0,0,-1,-1,-1,0,-1,0,0,1,-1,1,-1,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,-1,0,1,0,1,1,1,1,1,0,1,0,1,0,-1,1,-1,0,1,0,0,1,-1,1,1,0,1,0,0,0]},71:function(t,e){t.exports="precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\nuniform   bool mirror;\nvarying   vec3 vNormal;\nvarying   vec4 vColor;\nuniform vec3 eyeDirection;\nvarying float dist;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tif(mirror){pos = vec4(pos.x, -pos.y, pos.zw);}\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = normal;\n  vColor      = color;\n  dist = distance(position.xyz, eyeDirection);\n}\n"},72:function(t,e){t.exports="\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform mat4 invMatrix;\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform vec4 ambientColor;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying float dist;\n\nvoid main(void){\n    vec3  invLight  = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n    vec3  invEye    = normalize(invMatrix * vec4(eyeDirection, 0.0)).xyz;\n    vec3  halfLE    = normalize(invLight + invEye);\n    float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0);\n    float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0); // 50.0来模仿粗糙度\n    vec4  destColor = vColor * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;\n    // float gamma = 2.2; // 我们本身用的已经是数字颜色，而不是看到的颜色，所以不需要gamma校正\n    // destColor.rgb = pow(destColor.rgb, vec3(1.0/gamma));\n    gl_FragColor    = destColor;\n    // gl_FragColor = vec4(700.,0.3,1.,1.);\n}\n"},73:function(t,e){t.exports="#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nuniform   mat4 ortMatrix;\nvarying   vec2 vTexCoord;\n\nvoid main(void){\n    vTexCoord   = texCoord;\n    gl_Position = ortMatrix * vec4(position, 1.0);\n}\n"},74:function(t,e){t.exports="precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\nuniform float     alpha;\nvarying vec2      vTexCoord;\n\nvoid main(void){\n    vec2 tc      = vec2(vTexCoord.s, 1. - vTexCoord.t);\n    gl_FragColor = vec4(texture2D(texture, tc).rgb, alpha);\n    // gl_FragColor = vec4(vec3(vTexCoord.t),1.);\n}\n"}}]);