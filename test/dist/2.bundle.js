(window.webpackJsonp=window.webpackJsonp||[]).push([[2,22],{13:function(t,e,n){"use strict";var s=n(71),o=n.n(s),r=n(72),i=n.n(r),a=n(73),u=n.n(a),h=n(74),c=n.n(h),p=n(75),l=n.n(p);const f={skyboxVert:i(),skyboxFrag:o(),gltfVert:c(),gltfFrag:u(),bigTriangleVert:l()};e.a=f},142:function(t,e){t.exports="// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nattribute vec3 normal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n    vTextureCoord = texCoord;\n    vNormal = normal;\n}"},143:function(t,e){t.exports="// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"},28:function(t,e,n){"use strict";var s=n(0),o=n(14),r=n(12);n(144);const i=(t,e)=>{if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0},a=t=>{const e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=`${t+1}: ${e[t]}`;return e.join("\n")},u=t=>t.slice?t.slice(0):new Float32Array(t),h=n(142),c=n(143),p={float:"uniform1f",vec2:"uniform2fv",vec3:"uniform3fv",vec4:"uniform4fv",int:"uniform1i",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"};class l{constructor(t=h,e=c,n){this.parameters=[],this._uniformTextures=[],this._varyings=n,t||(t=h),e||(e=h);const s=this._createShaderProgram(t,!0),o=this._createShaderProgram(e,!1);this._attachShaderProgram(s,o)}use(){this.bind()}bind(){s.c.useProgram(this.shaderProgram),s.a.useShader(this)}uniform(t,e,n){if("object"==typeof t)return void this.uniformObject(t);const o=p[e]||e;let r,a=!1,h=-1;for(let e=0;e<this.parameters.length;e++)if((r=this.parameters[e]).name===t){a=!0,h=e;break}let c=!1;if(a?(this.shaderProgram[t]=r.uniformLoc,c=r.isNumber):(c="uniform1i"===o||"uniform1f"===o,this.shaderProgram[t]=s.c.getUniformLocation(this.shaderProgram,t),c?this.parameters.push({name:t,type:o,value:n,uniformLoc:this.shaderProgram[t],isNumber:c}):this.parameters.push({name:t,type:o,value:u(n),uniformLoc:this.shaderProgram[t],isNumber:c}),h=this.parameters.length-1),this.parameters[h].uniformLoc)if(-1===o.indexOf("Matrix"))if(c){(this.parameters[h].value!==n||!a)&&(s.c[o](this.shaderProgram[t],n),this.parameters[h].value=n)}else i(this.parameters[h].value,n)&&a||(s.c[o](this.shaderProgram[t],n),this.parameters[h].value=u(n));else i(this.parameters[h].value,n)&&a||(s.c[o](this.shaderProgram[t],!1,n),this.parameters[h].value=u(n))}style(t){this.uniformObject(t)}uniformObject(t){for(const e in t)if(t[e]instanceof o.a||t[e]instanceof r.a){const n=t[e];let s=-1;this._uniformTextures.forEach((t,o)=>{t.name===e&&(s=o,t.texture=n)}),-1===s&&(s=this._uniformTextures.length,this._uniformTextures.push({name:e,texture:n})),this.uniform(e,"uniform1i",s),n.bind(s)}else{let n=t[e];const s=l.getUniformType(n);if(n.concat&&n[0].concat){let t=[];for(let e=0;e<n.length;e++)t=t.concat(n[e]);n=t}this.uniform(e,s,n)}}_createShaderProgram(t,e){const n=e?s.c.VERTEX_SHADER:s.c.FRAGMENT_SHADER,o=s.c.createShader(n);return s.c.shaderSource(o,t),s.c.compileShader(o),s.c.getShaderParameter(o,s.c.COMPILE_STATUS)?o:(console.warn("Error in Shader : ",s.c.getShaderInfoLog(o)),console.log(a(t)),null)}_attachShaderProgram(t,e){this.shaderProgram=s.c.createProgram(),s.c.attachShader(this.shaderProgram,t),s.c.attachShader(this.shaderProgram,e),s.c.deleteShader(t),s.c.deleteShader(e),this._varyings&&(console.log("Transform feedback setup : ",this._varyings),s.c.transformFeedbackVaryings(this.shaderProgram,this._varyings,s.c.SEPARATE_ATTRIBS)),s.c.linkProgram(this.shaderProgram)}}l.getUniformType=function(t){const e=function(t){return 9===t.length?"uniformMatrix3fv":16===t.length?"uniformMatrix4fv":`vec${t.length}`};return!!t.length?t[0].concat?e(t[0]):e(t):"float"},e.a=l},5:function(t,e,n){"use strict";n.r(e);var s=n(2),o=n(28),r=n(1),i=n(0);const a=function(t,e,n){const s=e||{};return t.touches&&!n?(s.x=t.touches[0].pageX,s.y=t.touches[0].pageY):t.touches?t.touches&&n&&(s.x=t.touches[1].pageX,s.y=t.touches[1].pageY):(s.x=t.clientX,s.y=t.clientY),s},u=1e-4;class h{constructor(t=[0,0,0],e=[0,1,0]){Object(s.a)(this,"cameraPos",void 0),Object(s.a)(this,"up",void 0),Object(s.a)(this,"cameraFront",[0,0,-1]),Object(s.a)(this,"_mouse",{}),Object(s.a)(this,"_preMouse",{}),Object(s.a)(this,"_mousedown",!1),Object(s.a)(this,"_rx",0),Object(s.a)(this,"_ry",0),Object(s.a)(this,"_preRx",0),Object(s.a)(this,"_preRy",0),Object(s.a)(this,"_targetRx",0),Object(s.a)(this,"_targetRy",0),Object(s.a)(this,"_viewMatrix",r.b.identity(r.b.create())),Object(s.a)(this,"_width",i.b.width),Object(s.a)(this,"_height",i.b.height),Object(s.a)(this,"sensitivity",1),Object(s.a)(this,"target",[0,0,0]),Object(s.a)(this,"offset",[0,0,0]),Object(s.a)(this,"radius",5),Object(s.a)(this,"_targetRadius",5),Object(s.a)(this,"_updateWheel",!1),this.cameraPos=t,this.up=e,this.projMatrix=r.b.create(),r.b.perspective(this.projMatrix,Object(i.d)(45),i.b.clientWidth/i.b.clientHeight,.1,100),this._addEvents()}setProj(t,e,n){r.b.perspective(this.projMatrix,Object(i.d)(t),i.b.clientWidth/i.b.clientHeight,e,n)}_addEvents(){i.b.addEventListener("mousedown",t=>this._down(t)),i.b.addEventListener("mousemove",t=>this._move(t)),document.addEventListener("mouseup",t=>this._up(t)),i.b.addEventListener("mousewheel",t=>this._onWheel(t)),i.b.addEventListener("DOMMouseScroll",t=>this._onWheel(t))}_down(t){this._mousedown=!0,a(t,this._mouse),a(t,this._preMouse),this._preRx=this._targetRx,this._preRy=this._targetRy}_move(t){if(this._mousedown){a(t,this._mouse);let e=(this._mouse.x-this._preMouse.x)/this._width,n=(this._mouse.y-this._preMouse.y)/this._height;this._targetRx=this._preRx+e*Math.PI*2*this.sensitivity,this._targetRy=this._preRy+n*Math.PI*this.sensitivity}}_up(t){this._mousedown=!1}updateMatrix(){this._rx+=.1*(this._targetRx-this._rx),Math.abs(this._targetRx-this._rx)<u&&(this._rx=this._targetRx),this._ry+=.1*(this._targetRy-this._ry),Math.abs(this._targetRy-this._ry)<u&&(this._ry=this._targetRy),this._updateWheel&&(this.radius+=.1*(this._targetRadius-this.radius),Math.abs(this._targetRadius-this.radius)<u&&(this.radius=this._targetRadius)),this.cameraPos[1]=Math.sin(this._ry)*this.radius;let t=Math.abs(Math.cos(this._ry)*this.radius);this.cameraPos[0]=Math.cos(this._rx+.5*Math.PI)*t,this.cameraPos[2]=Math.sin(this._rx+.5*Math.PI)*t,this.cameraPos=[this.cameraPos[0]+this.offset[0],this.cameraPos[1]+this.offset[1],this.cameraPos[2]+this.offset[2]],r.b.lookAt(this._viewMatrix,this.cameraPos,this.target,this.up)}_onWheel(t){const e=t.wheelDelta,n=t.detail;let s=0;s=n?e?e/n/40*n>0?1:-1:-n/3:e/120,this._targetRadius=this.radius+1*-s,this._targetRadius<=1&&(this._targetRadius=1),this._updateWheel=!0}get viewMatrix(){return this._viewMatrix}set rx(t){this._targetRx=t}}var c=n(43);n.d(e,"default",function(){return p});class p{constructor(){Object(s.a)(this,"rotateQ",r.c.create()),Object(s.a)(this,"mousePos",{x:0,y:0}),Object(s.a)(this,"camera",new h),Object(s.a)(this,"pMatrix",r.b.identity(r.b.create())),Object(s.a)(this,"mvpMatrix",r.b.identity(r.b.create())),Object(s.a)(this,"tmpMatrix",r.b.identity(r.b.create())),Object(s.a)(this,"_params",{}),Object(s.a)(this,"gui",new c.a({width:300})),this.vMatrix=this.camera.viewMatrix,i.a.setCamera(this.camera),this.init(),this.attrib(),this.prepare(),this._setGUI(),this._animate=this.animate.bind(this),i.c.enable(i.c.DEPTH_TEST),i.c.depthFunc(i.c.LEQUAL),i.c.enable(i.c.CULL_FACE)}init(){}compile(t,e){return new o.a(t,e)}attrib(){}uniform(){}prepare(){}animate(){requestAnimationFrame(this._animate),this.camera.updateMatrix(),this.uniform(),this.render()}render(){}play(){this.animate()}_setGUI(){}addGUIParams(t){return Object.assign(this._params,t)}get params(){return this._params}set params(t){throw Error("Params has no setter,please use addGUIParams")}}},71:function(t,e){t.exports="#version 300 es\n#define SHADER_NAME SKYBOX_FRAGMENT\n\nprecision highp float;\n#define GLSLIFY 1\nin   vec2 TexCoords;\nin vec3 vertex;\nuniform samplerCube tex;\nuniform float uGamma;\nuniform float uExposure;\nout vec4 outColor;\n\n// Filmic tonemapping from\n// http://filmicgames.com/archives/75\n\nconst float A = 0.15;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\n\nvec3 Uncharted2Tonemap( vec3 x )\n{\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvoid main(void){\n    vec3 color = texture(tex, vertex).rgb;\n    color\t\t\t\t= Uncharted2Tonemap( color * uExposure );\n\t// white balance\n\tcolor\t\t\t\t= color * ( 1.0 / Uncharted2Tonemap( vec3( 20.0 ) ) );\n\t\n\t// gamma correction\n\tcolor\t\t\t\t= pow( color, vec3( 1.0 / uGamma ) );\n\n    outColor = vec4(color, 1.);\n}\n"},72:function(t,e){t.exports="#version 300 es\n#define SHADER_NAME SKYBOX_VERTEX\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nuniform   mat4 mvpMatrix;\nout   vec2 TexCoords;\nout vec3 vertex;\n\n\nvoid main(void){\n    TexCoords = texCoord;\n    vertex = position;\n    vec4 pos = mvpMatrix * vec4(position, 1.0);\n    gl_Position = pos.xyww;\n}\n"},73:function(t,e){t.exports="#version 300 es\n#define SHADER_NAME gltf_frag\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D \tuBRDFMap;\nuniform samplerCube uRadianceMap;\nuniform samplerCube uIrradianceMap;\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D uColorMap;\n#endif\n\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D uMetallicRoughnessMap;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D uAoMap;\nuniform float uOcclusionStrength;\n#endif\n\n#ifdef HAS_NORMALMAP\nuniform sampler2D uNormalMap;\nuniform float uNormalScale;\n#endif\n\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D uEmissiveMap;\nuniform vec3 uEmissiveFactor;\n#endif\n\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\nuniform vec3 uCameraPos;\n\nuniform vec4 uScaleDiffBaseMR;\nuniform vec4 uScaleFGDSpec;\nuniform vec4 uScaleIBLAmbient;\n\nuniform vec3 uBaseColor;\nuniform float uRoughness;\nuniform float uMetallic;\nuniform float uGamma;\n\nin vec2 vTextureCoord;\nin vec3 vPosition;\n\n#ifdef HAS_NORMALS\nin vec3 vNormal;\n#endif\nout vec4 FragColor;\n\n//\tFrom GLTF WebGL PBR :\n//\thttps://github.com/KhronosGroup/glTF-WebGL-PBR\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n\tfloat NdotL;                  // cos angle between normal and light direction\n\tfloat NdotV;                  // cos angle between normal and view direction\n\tfloat NdotH;                  // cos angle between normal and half vector\n\tfloat LdotH;                  // cos angle between light direction and half vector\n\tfloat VdotH;                  // cos angle between view direction and half vector\n\tfloat perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n\tfloat metalness;              // metallic value at the surface\n\tvec3 reflectance0;            // full reflectance color (normal incidence angle)\n\tvec3 reflectance90;           // reflectance color at grazing angle\n\tfloat alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n\tvec3 diffuseColor;            // color contribution from diffuse lighting\n\tvec3 specularColor;           // color contribution from specular lighting\n};\n\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n\t#ifdef MANUAL_SRGB\n\t#ifdef SRGB_FAST_APPROXIMATION\n\tvec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n\t#else //SRGB_FAST_APPROXIMATION\n\tvec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n\tvec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n\t#endif //SRGB_FAST_APPROXIMATION\n\treturn vec4(linOut,srgbIn.w);;\n\t#else //MANUAL_SRGB\n\treturn srgbIn;\n\t#endif //MANUAL_SRGB\n}\n\n\nvec3 getNormal() {\n\tvec3 pos_dx = dFdx(vPosition);\n\tvec3 pos_dy = dFdy(vPosition);\n\tvec3 tex_dx = dFdx(vec3(vTextureCoord, 0.0));\n\tvec3 tex_dy = dFdy(vec3(vTextureCoord, 0.0));\n\tvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n\t\n#ifdef HAS_NORMALS\n\tvec3 ng = normalize(vNormal);\n#else\n\tvec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n\tt = normalize(t - ng * dot(ng, t));\n\tvec3 b = normalize(cross(ng, t));\n\tmat3 tbn = mat3(t, b, ng);\n\n#ifdef HAS_NORMALMAP\n\tvec3 n = texture(uNormalMap, vTextureCoord).rgb;\n\tn = normalize(tbn * ((2.0 * n - 1.0) * vec3(uNormalScale, uNormalScale, 1.0)));\n#else\n\t// The tbn matrix is linearly interpolated, so we need to re-normalize\n\tvec3 n = normalize(tbn[2].xyz);\n#endif\n\n\treturn n;\n}\n\n\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n\tfloat mipCount = 7.0; // resolution of 512x512\n\tfloat lod = (pbrInputs.perceptualRoughness * mipCount);\n\t// retrieve a scale and bias to F0. See [1], Figure 3\n\tvec2 brdf = SRGBtoLINEAR(texture(uBRDFMap, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rg;\n\tvec3 diffuseLight = SRGBtoLINEAR(texture(uIrradianceMap, n)).rgb;\n\n\tvec3 specularLight = SRGBtoLINEAR(texture(uRadianceMap, reflection, lod)).rgb;\n\n\tvec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n\tvec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n\n\t// For presentation, this allows us to disable IBL terms\n\tdiffuse *= uScaleIBLAmbient.x;\n\tspecular *= uScaleIBLAmbient.y;\n\n\treturn diffuse + specular;\n}\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.diffuseColor / M_PI;\n}\n\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n\tfloat NdotL = pbrInputs.NdotL;\n\tfloat NdotV = pbrInputs.NdotV;\n\tfloat r = pbrInputs.alphaRoughness;\n\n\tfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n\tfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n\treturn attenuationL * attenuationV;\n}\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n\tfloat roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n\tfloat f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n\treturn roughnessSq / (M_PI * f * f);\n}\n\nvoid main() {\n\n\tfloat perceptualRoughness   = uRoughness;\n\tfloat metallic              = uMetallic;\n#ifdef HAS_METALROUGHNESSMAP\n\t// Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n\t// This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n\tvec4 mrSample = texture(uMetallicRoughnessMap, vTextureCoord);\n\tperceptualRoughness = mrSample.g * perceptualRoughness;\n\tmetallic = mrSample.b * metallic;\n#endif\t\n\tperceptualRoughness         = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n\tmetallic                    = clamp(metallic, 0.0, 1.0);\n\tfloat alphaRoughness        = perceptualRoughness * perceptualRoughness;\n\n#ifdef HAS_BASECOLORMAP\t\n\tvec4 baseColor = SRGBtoLINEAR(texture(uColorMap, vTextureCoord));\n#else\n\tvec4 baseColor              = vec4(uBaseColor, 1.0);\n#endif\t\n\t\n\tvec3 f0                     = vec3(0.04);\n\tvec3 diffuseColor           = baseColor.rgb * (vec3(1.0) - f0);\n\tdiffuseColor                *= 1.0 - metallic;\n\tvec3 specularColor          = mix(f0, baseColor.rgb, metallic);\n\t\n\t// Compute reflectance.\n\tfloat reflectance           = max(max(specularColor.r, specularColor.g), specularColor.b);\n\t\n\t// For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n\t// For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n\tfloat reflectance90         = clamp(reflectance * 50.0, 0.0, 1.0);\n\tvec3 specularEnvironmentR0  = specularColor.rgb;\n\tvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\t\n\tvec3 n                      = getNormal();                             // normal at surface point\n\tvec3 v                      = normalize(uCameraPos - vPosition);        // Vector from surface point to camera\n\tvec3 l                      = normalize(uLightDirection);             // Vector from surface point to light\n\tvec3 h                      = normalize(l+v);                          // Half vector between both l and v\n\tvec3 reflection             = -normalize(reflect(v, n));\n\t\n\tfloat NdotL                 = clamp(dot(n, l), 0.001, 1.0);\n\tfloat NdotV                 = abs(dot(n, v)) + 0.001;\n\tfloat NdotH                 = clamp(dot(n, h), 0.0, 1.0);\n\tfloat LdotH                 = clamp(dot(l, h), 0.0, 1.0);\n\tfloat VdotH                 = clamp(dot(v, h), 0.0, 1.0);\n\n\tPBRInfo pbrInputs = PBRInfo(\n\t\tNdotL,\n\t\tNdotV,\n\t\tNdotH,\n\t\tLdotH,\n\t\tVdotH,\n\t\tperceptualRoughness,\n\t\tmetallic,\n\t\tspecularEnvironmentR0,\n\t\tspecularEnvironmentR90,\n\t\talphaRoughness,\n\t\tdiffuseColor,\n\t\tspecularColor\n\t);\n\n\t// Calculate the shading terms for the microfacet specular shading model\n\tvec3 F              = specularReflection(pbrInputs);\n\tfloat G             = geometricOcclusion(pbrInputs);\n\tfloat D             = microfacetDistribution(pbrInputs);\n\t\n\t// Calculation of analytical lighting contribution\n\tvec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n\tvec3 specContrib    = F * G * D / (4.0 * NdotL * NdotV);\n\t// Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n\tvec3 color          = NdotL * uLightColor * (diffuseContrib + specContrib);\n\t\n#ifdef USE_IBL\n\tcolor += getIBLContribution(pbrInputs, n, reflection);\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\t\n\tfloat ao            = texture(uAoMap, vTextureCoord).r;\n\tcolor               = mix(color, color * ao, uOcclusionStrength);\n#endif\t\n\n#ifdef HAS_EMISSIVEMAP\n\tvec3 emissive = SRGBtoLINEAR(texture(uEmissiveMap, vTextureCoord)).rgb * uEmissiveFactor;\n\tcolor += emissive;\n#endif\n\t\n\t// This section uses mix to override final color for reference app visualization\n\t// of various parameters in the lighting equation.\n\tcolor               = mix(color, F, uScaleFGDSpec.x);\n\tcolor               = mix(color, vec3(G), uScaleFGDSpec.y);\n\tcolor               = mix(color, vec3(D), uScaleFGDSpec.z);\n\tcolor               = mix(color, specContrib, uScaleFGDSpec.w);\n\t\n\tcolor               = mix(color, diffuseContrib, uScaleDiffBaseMR.x);\n\tcolor               = mix(color, baseColor.rgb, uScaleDiffBaseMR.y);\n\tcolor               = mix(color, vec3(metallic), uScaleDiffBaseMR.z);\n\tcolor               = mix(color, vec3(perceptualRoughness), uScaleDiffBaseMR.w);\n\t\n\t// output the fragment color\n\tFragColor        = vec4(pow(color,vec3(1.0/uGamma)), baseColor.a);\n\t//FragColor        = vec4(vec3(baseColor), 1.0);\n\n}"},74:function(t,e){t.exports="#version 300 es\n#define SHADER_NAME gltf_vert\n\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\n\n#ifdef HAS_UV\nin vec2 texCoord;\n#endif\n\n#ifdef HAS_NORMALS\nin vec3 normal;\n#endif\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform mat3 uModelViewMatrixInverse;\n\n\nout vec3 vPosition;\nout vec2 vTextureCoord;\n\n#ifdef HAS_NORMALS\nout vec3 vNormal;\n#endif\n\n\nvoid main(void) {\n\tvec4 tPosition = uModelMatrix * vec4(position, 1.0);\n\tvPosition     = tPosition.xyz / tPosition.w;\n\t\n\t#ifdef HAS_UV\n\tvTextureCoord = vec2(texCoord.x, texCoord.y);\n\t#else\n\tvTextureCoord = vec2(0.,0.);\n\t#endif\n\n\t#ifdef HAS_NORMALS\n\tvNormal       = normalize(vec3(uModelMatrix * vec4(normal, 0.0)));\n\t#endif\n\t\n\tgl_Position   = uProjectionMatrix * uViewMatrix * tPosition;\n}\n"},75:function(t,e){t.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec2 position;\nout vec2 TexCoords;\n\n\n\nvoid main(void){\n\n\n\tgl_Position    = vec4(position, 0., 1.);\n\tTexCoords = position * .5 + .5;\n}\n"},8:function(t,e,n){"use strict";var s=n(3);const o={};let r;o.plane=function(t,e,n,o="xy",r=4){const i=[],a=[],u=[],h=[],c=t/n,p=e/n,l=1/n,f=.5*-t,d=.5*-e;let m=0;for(let t=0;t<n;t++)for(let e=0;e<n;e++){const s=c*t+f,r=p*e+d,v=t/n,g=e/n;"xz"===o?(i.push([s,0,r+p]),i.push([s+c,0,r+p]),i.push([s+c,0,r]),i.push([s,0,r]),a.push([v,1-(g+l)]),a.push([v+l,1-(g+l)]),a.push([v+l,1-g]),a.push([v,1-g]),h.push([0,1,0]),h.push([0,1,0]),h.push([0,1,0]),h.push([0,1,0])):"yz"===o?(i.push([0,r,s]),i.push([0,r,s+c]),i.push([0,r+p,s+c]),i.push([0,r+p,s]),a.push([v,g]),a.push([v+l,g]),a.push([v+l,g+l]),a.push([v,g+l]),h.push([1,0,0]),h.push([1,0,0]),h.push([1,0,0]),h.push([1,0,0])):(i.push([s,r,0]),i.push([s+c,r,0]),i.push([s+c,r+p,0]),i.push([s,r+p,0]),a.push([v,g]),a.push([v+l,g]),a.push([v+l,g+l]),a.push([v,g+l]),h.push([0,0,1]),h.push([0,0,1]),h.push([0,0,1]),h.push([0,0,1])),u.push(4*m+0),u.push(4*m+1),u.push(4*m+2),u.push(4*m+0),u.push(4*m+2),u.push(4*m+3),m++}const v=new s.a(r);return v.bufferVertex(i),v.bufferTexCoord(a),v.bufferIndex(u),v.bufferNormal(h),v},o.sphere=function(t,e,n=!1,o=4){const r=[],i=[],a=[],u=[],h=1/e;let c=0;function p(n,s,o=!1){const r=n/e*Math.PI-.5*Math.PI,i=s/e*Math.PI*2,a=o?1:t,u=[];u[1]=Math.sin(r)*a;const h=Math.cos(r)*a;u[0]=Math.cos(i)*h,u[2]=Math.sin(i)*h;return u[0]=Math.floor(1e4*u[0])/1e4,u[1]=Math.floor(1e4*u[1])/1e4,u[2]=Math.floor(1e4*u[2])/1e4,u}for(let t=0;t<e;t++)for(let n=0;n<e;n++){r.push(p(t,n)),r.push(p(t+1,n)),r.push(p(t+1,n+1)),r.push(p(t,n+1)),u.push(p(t,n,!0)),u.push(p(t+1,n,!0)),u.push(p(t+1,n+1,!0)),u.push(p(t,n+1,!0));const s=n/e,o=t/e;i.push([1-s,o]),i.push([1-s,o+h]),i.push([1-s-h,o+h]),i.push([1-s-h,o]),a.push(4*c+0),a.push(4*c+1),a.push(4*c+2),a.push(4*c+0),a.push(4*c+2),a.push(4*c+3),c++}n&&a.reverse();const l=new s.a(o);return l.bufferVertex(r),l.bufferTexCoord(i),l.bufferIndex(a),l.bufferNormal(u),l},o.cube=function(t,e,n,o=4){const r=t/2,i=(e=e||t)/2,a=(n=n||t)/2,u=[],h=[],c=[],p=[];let l=0;u.push([-r,i,-a]),u.push([r,i,-a]),u.push([r,-i,-a]),u.push([-r,-i,-a]),p.push([0,0,-1]),p.push([0,0,-1]),p.push([0,0,-1]),p.push([0,0,-1]),h.push([0,0]),h.push([1,0]),h.push([1,1]),h.push([0,1]),c.push(4*l+0),c.push(4*l+1),c.push(4*l+2),c.push(4*l+0),c.push(4*l+2),c.push(4*l+3),l++,u.push([r,i,-a]),u.push([r,i,a]),u.push([r,-i,a]),u.push([r,-i,-a]),p.push([1,0,0]),p.push([1,0,0]),p.push([1,0,0]),p.push([1,0,0]),h.push([0,0]),h.push([1,0]),h.push([1,1]),h.push([0,1]),c.push(4*l+0),c.push(4*l+1),c.push(4*l+2),c.push(4*l+0),c.push(4*l+2),c.push(4*l+3),l++,u.push([r,i,a]),u.push([-r,i,a]),u.push([-r,-i,a]),u.push([r,-i,a]),p.push([0,0,1]),p.push([0,0,1]),p.push([0,0,1]),p.push([0,0,1]),h.push([0,0]),h.push([1,0]),h.push([1,1]),h.push([0,1]),c.push(4*l+0),c.push(4*l+1),c.push(4*l+2),c.push(4*l+0),c.push(4*l+2),c.push(4*l+3),l++,u.push([-r,i,a]),u.push([-r,i,-a]),u.push([-r,-i,-a]),u.push([-r,-i,a]),p.push([-1,0,0]),p.push([-1,0,0]),p.push([-1,0,0]),p.push([-1,0,0]),h.push([0,0]),h.push([1,0]),h.push([1,1]),h.push([0,1]),c.push(4*l+0),c.push(4*l+1),c.push(4*l+2),c.push(4*l+0),c.push(4*l+2),c.push(4*l+3),l++,u.push([r,i,-a]),u.push([-r,i,-a]),u.push([-r,i,a]),u.push([r,i,a]),p.push([0,1,0]),p.push([0,1,0]),p.push([0,1,0]),p.push([0,1,0]),h.push([0,0]),h.push([1,0]),h.push([1,1]),h.push([0,1]),c.push(4*l+0),c.push(4*l+1),c.push(4*l+2),c.push(4*l+0),c.push(4*l+2),c.push(4*l+3),l++,u.push([r,-i,a]),u.push([-r,-i,a]),u.push([-r,-i,-a]),u.push([r,-i,-a]),p.push([0,-1,0]),p.push([0,-1,0]),p.push([0,-1,0]),p.push([0,-1,0]),h.push([0,0]),h.push([1,0]),h.push([1,1]),h.push([0,1]),c.push(4*l+0),c.push(4*l+1),c.push(4*l+2),c.push(4*l+0),c.push(4*l+2),c.push(4*l+3),l++;const f=new s.a(o);return f.bufferVertex(u),f.bufferTexCoord(h),f.bufferIndex(c),f.computeNormals(p),f},o.skybox=function(t,e=4){const n=[],o=[],r=[],i=[];let a=0;n.push([t,t,-t]),n.push([-t,t,-t]),n.push([-t,-t,-t]),n.push([t,-t,-t]),i.push([0,0,-1]),i.push([0,0,-1]),i.push([0,0,-1]),i.push([0,0,-1]),o.push([0,0]),o.push([1,0]),o.push([1,1]),o.push([0,1]),r.push(4*a+0),r.push(4*a+1),r.push(4*a+2),r.push(4*a+0),r.push(4*a+2),r.push(4*a+3),a++,n.push([t,-t,-t]),n.push([t,-t,t]),n.push([t,t,t]),n.push([t,t,-t]),i.push([1,0,0]),i.push([1,0,0]),i.push([1,0,0]),i.push([1,0,0]),o.push([0,0]),o.push([1,0]),o.push([1,1]),o.push([0,1]),r.push(4*a+0),r.push(4*a+1),r.push(4*a+2),r.push(4*a+0),r.push(4*a+2),r.push(4*a+3),a++,n.push([-t,t,t]),n.push([t,t,t]),n.push([t,-t,t]),n.push([-t,-t,t]),i.push([0,0,1]),i.push([0,0,1]),i.push([0,0,1]),i.push([0,0,1]),o.push([0,0]),o.push([1,0]),o.push([1,1]),o.push([0,1]),r.push(4*a+0),r.push(4*a+1),r.push(4*a+2),r.push(4*a+0),r.push(4*a+2),r.push(4*a+3),a++,n.push([-t,-t,t]),n.push([-t,-t,-t]),n.push([-t,t,-t]),n.push([-t,t,t]),i.push([-1,0,0]),i.push([-1,0,0]),i.push([-1,0,0]),i.push([-1,0,0]),o.push([0,0]),o.push([1,0]),o.push([1,1]),o.push([0,1]),r.push(4*a+0),r.push(4*a+1),r.push(4*a+2),r.push(4*a+0),r.push(4*a+2),r.push(4*a+3),a++,n.push([t,t,t]),n.push([-t,t,t]),n.push([-t,t,-t]),n.push([t,t,-t]),i.push([0,1,0]),i.push([0,1,0]),i.push([0,1,0]),i.push([0,1,0]),o.push([0,0]),o.push([1,0]),o.push([1,1]),o.push([0,1]),r.push(4*a+0),r.push(4*a+1),r.push(4*a+2),r.push(4*a+0),r.push(4*a+2),r.push(4*a+3),a++,n.push([t,-t,-t]),n.push([-t,-t,-t]),n.push([-t,-t,t]),n.push([t,-t,t]),i.push([0,-1,0]),i.push([0,-1,0]),i.push([0,-1,0]),i.push([0,-1,0]),o.push([0,0]),o.push([1,0]),o.push([1,1]),o.push([0,1]),r.push(4*a+0),r.push(4*a+1),r.push(4*a+2),r.push(4*a+0),r.push(4*a+2),r.push(4*a+3);const u=new s.a(e);return u.bufferVertex(n),u.bufferTexCoord(o),u.bufferIndex(r),u.bufferNormal(i),u},o.bigTriangle=function(){if(!r){const t=[2,1,0],e=[[-1,-1],[-1,4],[4,-1]];(r=new s.a).bufferData(e,"position",2),r.bufferIndex(t)}return r},e.a=o}}]);