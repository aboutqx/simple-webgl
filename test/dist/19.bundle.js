(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{45:function(t,e,n){"use strict";n.r(e),n.d(e,"default",function(){return g});var r=n(2),i=n(5),o=n(8),a=n(13),s=n(81),c=n.n(s),m=n(82),l=n.n(m),v=n(83),p=n.n(v),u=n(84),x=n.n(u),f=n(85),h=n.n(f),M=n(86),b=n.n(M),d=n(1),P=n(0);class g extends i.default{constructor(){super(),Object(r.a)(this,"count",0)}init(){this.prg=this.compile(a.a.skyboxVert,a.a.skyboxFrag),this.specularPrg=this.compile(c.a,l.a),this.refractPrg=this.compile(p.a,x.a),this.frenellPrg=this.compile(h.a,b.a)}attrib(){this.skybox=o.a.skybox(40)}prepare(){this.skyMap=getAssets.outputskybox,this.venus=getAssets.statue,this.camera.radius=6}uniform(){d.b.perspective(this.pMatrix,Object(P.d)(45),P.b.clientWidth/P.b.clientHeight,.1,100),d.b.multiply(this.tmpMatrix,this.pMatrix,this.vMatrix);let t=d.b.identity(d.b.create());d.b.multiply(this.mvpMatrix,this.tmpMatrix,t),P.c.activeTexture(P.c.TEXTURE0),P.c.bindTexture(P.c.TEXTURE_CUBE_MAP,this.skyMap.texture),this.prg.use(),this.prg.style({mvpMatrix:this.mvpMatrix,uGamma:2.2,uExposure:5,tex:0})}render(){P.c.clearColor(.3,.3,.3,1),P.c.clearDepth(1),P.c.clear(P.c.COLOR_BUFFER_BIT|P.c.DEPTH_BUFFER_BIT),this.prg.use(),P.a.draw(this.skybox);let t=d.b.identity(d.b.create());d.b.translate(t,t,[-3,0,0]),d.b.multiply(this.mvpMatrix,this.tmpMatrix,t),this.specularPrg.use(),this.specularPrg.style({mMatrix:t,vMatrix:this.vMatrix,pMatrix:this.pMatrix,skybox:0,cameraPos:this.camera.cameraPos});for(let t=0;t<this.venus.length;t++)P.a.draw(this.venus[t],!0);t=d.b.identity(d.b.create()),d.b.translate(t,t,[3,0,0]),d.b.multiply(this.mvpMatrix,this.tmpMatrix,t),this.refractPrg.use(),this.refractPrg.style({mMatrix:t,vMatrix:this.vMatrix,pMatrix:this.pMatrix,skybox:0,cameraPos:this.camera.cameraPos});for(let t=0;t<this.venus.length;t++)P.a.draw(this.venus[t],!0);t=d.b.identity(d.b.create()),d.b.translate(t,t,[0,0,0]),d.b.multiply(this.mvpMatrix,this.tmpMatrix,t),this.refractPrg.use(),this.refractPrg.style({mMatrix:t,vMatrix:this.vMatrix,pMatrix:this.pMatrix,skybox:0,cameraPos:this.camera.cameraPos,etaRatio:[.65,.67,.69],fresnelPower:.8,fresnelBias:.1,fresnelScale:.9});for(let t=0;t<this.venus.length;t++)P.a.draw(this.venus[t],!0)}}},81:function(t,e){t.exports="#version 300 es\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec3 Normal;\nout vec3 Position;\n\nvoid main()\n{\n    Normal = mat3(transpose(inverse(mMatrix))) * normal;\n    Position = vec3(mMatrix * vec4(position, 1.0));\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}  "},82:function(t,e){t.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin vec3 Normal;\nin vec3 Position;\nuniform vec3 cameraPos;\nuniform samplerCube skybox;\nout vec4 FragColor;\n\nvec3 reflect (vec3  I, vec3 N)\n{\n  return I - 2.0 * N * dot(N, I);\n}\n\nvoid main()\n{             \n    vec3 I = normalize(Position - cameraPos);\n    vec3 R = reflect(I, normalize(Normal));\n    FragColor = vec4(texture(skybox, R).rgb, 1.0);\n}"},83:function(t,e){t.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec3 normal;\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec3 Normal;\nout vec3 Position;\n\nvoid main()\n{\n    Normal = mat3(transpose(inverse(mMatrix))) * normal;\n    Position = vec3(mMatrix * vec4(position, 1.0));\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}  "},84:function(t,e){t.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec3 Normal;\nin vec3 Position;\nuniform vec3 cameraPos;\nuniform samplerCube skybox;\nout vec4 FragColor;\n\nvoid main()\n{             \n    float ratio = 1.00 / 1.52;\n    vec3 I = normalize(Position - cameraPos);\n    vec3 R = refract(I, normalize(Normal), ratio);\n    FragColor = vec4(texture(skybox, R).rgb, 1.0);\n}  "},85:function(t,e){t.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec3 Normal;\nout vec3 Position;\n\nvoid main()\n{\n    Normal = mat3(transpose(inverse(mMatrix))) * normal;\n    Position = vec3(mMatrix * vec4(position, 1.0));\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}  "},86:function(t,e){t.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec3 Normal;\nin vec3 Position;\nuniform vec3 cameraPos;\nuniform samplerCube skybox;\nuniform float fresnelBias;\n\nuniform float fresnelScale;\n\nuniform float fresnelPower;\n\nuniform vec3 etaRatio;\n\nout vec4 FragColor;\n\nvoid main()\n{             \n    float ratio = 1.00 / 1.52;\n    vec3 I = normalize(Position - cameraPos);\n    vec3 N = normalize(Normal);\n    vec3 R = refract(I, N, ratio);\n    \n    vec3 TRed   = refract(I, N, etaRatio.x);\n\n    vec3 TGreen = refract(I, N, etaRatio.y);\n\n    vec3 TBlue  = refract(I, N, etaRatio.z);\n\n     // Compute the reflection factor\n\n    float reflectionFactor = fresnelBias + fresnelScale * pow(1. + dot(I, N), fresnelPower);\n    vec4 reflectedColor = texture(skybox, R);\n\n\n    // Compute the refracted environment color\n\n    vec4 refractedColor;\n\n    refractedColor.r = texture(skybox, TRed).r;\n\n    refractedColor.g = texture(skybox, TGreen).g;\n\n    refractedColor.b = texture(skybox, TBlue).b;\n\n    refractedColor.a = 1.;\n\n\n    // Compute the final color\n\n    FragColor = mix(refractedColor, reflectedColor, vec4(reflectionFactor));\n\n}  "}}]);