(window.webpackJsonp=window.webpackJsonp||[]).push([[14,21],{26:function(n,t){n.exports="precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"},27:function(n,t){n.exports="#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\n#define GLSLIFY 1\n// material map\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture2D(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture2D(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture2D(metallicMap, TexCoords).r;\n    float roughness = texture2D(roughnessMap, TexCoords).r;\n    float ao        = texture2D(aoMap, TexCoords).r;\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"},47:function(n,t,e){"use strict";e.r(t),e.d(t,"default",function(){return D});var o=e(8),a=e(2),r=e(5),i=e(0),s=e(85),l=e.n(s),c=e(86),d=e.n(c),m=e(26),f=e.n(m),u=e(27),h=e.n(u),p=e(6),g=e(1),v=e(4),N=e(3),x=e.n(N);const b=7,L=7,y=.8;class D extends r.default{constructor(){super(),Object(a.a)(this,"count",0)}init(){i.d.getExtension("OES_standard_derivatives"),this.prg=this.compile(l.a,d.a),this.mapPrg=this.compile(f.a,h.a)}attrib(){let{pos:n,index:t,normal:e,uv:o}=Object(p.Sphere)(256,256,.25),a=new v.a;a.bufferVertex(n),a.bufferIndices(t),a.bufferNormal(e),a.bufferTexCoord(o),this.sphere=a}prepare(){i.d.enable(i.d.DEPTH_TEST),i.d.depthFunc(i.d.LEQUAL)}uniform(){let n=g.a.identity(g.a.create()),t=g.a.identity(g.a.create());this.tmpMatrix=g.a.identity(g.a.create());let e=[],o=[];g.d.transformQuat(e,[0,0,5],this.rotateQ),g.d.transformQuat(o,[0,1,0],this.rotateQ),this.eyeDirection=e,g.a.lookAt(n,e,[0,0,0],o),g.a.perspective(t,Object(i.e)(45),i.a.clientWidth/i.a.clientHeight,.1,100),g.a.multiply(this.tmpMatrix,t,n)}_setGUI(){this.addGUIParams({lambertDiffuse:!0,orenNayarDiffuse:!1,map:"none"});let n=this.gui.addFolder("diffuse model");n.add(this.params,"lambertDiffuse").listen().onChange(()=>{this.setChecked("lambertDiffuse")}),n.add(this.params,"orenNayarDiffuse").listen().onChange(()=>{this.setChecked("orenNayarDiffuse")}),n.open();let t=this.gui.addFolder("material map");t.add(this.params,"map",["none","plastic","wall","gold","grass","rusted_iron","wood"]).listen().onChange(()=>{this.setTexture()}),t.open()}setChecked(n){this.params.lambertDiffuse=!1,this.params.orenNayarDiffuse=!1,this.params[n]=!0}setTexture(){let n=this.params.map;"none"!==n&&(this.texture0=new x.a(i.d,i.d.RGBA).fromImage(getAssets[n+"Albedo"]),this.texture1=new x.a(i.d,i.d.RGBA).fromImage(getAssets[n+"Roughness"]),this.texture2=new x.a(i.d,i.d.RGBA).fromImage(getAssets[n+"Metallic"]),this.texture3=new x.a(i.d,i.d.RGBA).fromImage(getAssets[n+"Ao"]),this.texture4=new x.a(i.d,i.d.RGBA).fromImage(getAssets[n+"Normal"]))}render(){i.d.clearColor(.3,.3,.3,1),i.d.clearDepth(1),i.d.clear(i.d.COLOR_BUFFER_BIT|i.d.DEPTH_BUFFER_BIT);let n=g.a.identity(g.a.create()),t={vpMatrix:this.tmpMatrix,lightPositions:[-10,10,10,10,10,10,-10,-10,10,10,-10,10],lightColors:new Array(12).fill(300),camPos:this.eyeDirection,lambertDiffuse:this.params.lambertDiffuse};if("none"===this.params.map){this.prg.use(),this.prg.style(Object(o.a)({},t,{albedo:[.5,0,0],ao:1})),this.sphere.bind(this.prg,["position","normal"]);for(let t=0;t<b;t++){this.prg.style({metallic:t/b});for(let e=0;e<L;e++)g.a.translate(n,g.a.create(),[(e-L/2)*y,(t-b/2)*y,0]),this.prg.style({roughness:V(e/L,.05,1),mMatrix:n}),this.sphere.draw()}}else this.mapPrg.use(),this.texture0.bind(0),this.texture1.bind(1),this.texture2.bind(2),this.texture3.bind(3),this.texture4.bind(4),this.mapPrg.style(Object(o.a)({},t,{mMatrix:n,albedoMap:0,roughnessMap:1,metallicMap:2,aoMap:3,normalMap:4})),this.sphere.bind(this.mapPrg),this.sphere.draw()}}function V(n,t,e){return t>e?V(n,e,t):n<t?t:n>e?e:n}},6:function(n,t,e){"use strict";function o(n,t,e,o,r){let i,s=[],l=[],c=[],d=[];for(let l=0;l<=n;l++){let m=2*Math.PI/n*l,f=Math.cos(m),u=Math.sin(m);for(let n=0;n<=t;n++){let l=2*Math.PI/t*n,m=(f*e+o)*Math.cos(l),h=u*e,p=(f*e+o)*Math.sin(l);s.push(m,h,p),i=r||a(360/t*n,1,1,1),d.push(i[0],i[1],i[2],i[3]);let g=f*Math.cos(l),v=f*Math.sin(l);c.push(g,u,v)}}for(let e=0;e<n;e++)for(let n=0;n<t;n++){let o=(t+1)*e+n;l.push(o,o+t+1,o+1),l.push(o+t+1,o+t+2,o+1)}return{pos:s,index:l,normal:c,color:d}}function a(n,t,e,o){if(t>1||e>1||o>1)return;let a=n%360,r=Math.floor(a/60),i=a/60-r,s=e*(1-t),l=e*(1-t*i),c=e*(1-t*(1-i)),d=[];if(!t>0&&!t<0)d.push(e,e,e,o);else{let n=[e,l,s,s,c,e],t=[c,e,e,l,s,s],a=[s,s,c,e,e,l];d.push(n[r],t[r],a[r],o)}return d}function r(n,t,e,o){for(var r=[],i=[],s=[],l=[],c=[],d=0;d<=n;d++)for(var m=Math.PI/n*d,f=Math.cos(m),u=Math.sin(m),h=0;h<=t;h++){var p=2*Math.PI/t*h,g=u*e*Math.cos(p),v=f*e,N=u*e*Math.sin(p),x=u*Math.cos(p),b=u*Math.sin(p);if(o)var L=o;else L=a(360/n*d,1,1,1);r.push(g,v,N),i.push(x,f,b),s.push(L[0],L[1],L[2],L[3]),l.push(1-1/t*h,1/n*d)}for(m=0,d=0;d<n;d++)for(h=0;h<t;h++)m=(t+1)*d+h,c.push(m,m+1,m+t+2),c.push(m,m+t+2,m+t+1);return{pos:r,normal:i,color:s,uv:l,index:c}}function i(n,t,e){const o=n/2,a=e/2;return[o,t,a,0,1,0,1,0,-o,t,-a,0,1,0,0,1,-o,t,a,0,1,0,0,0,o,t,a,0,1,0,1,0,o,t,-a,0,1,0,1,1,-o,t,-a,0,1,0,0,1]}e.r(t),e.d(t,"Torus",function(){return o}),e.d(t,"hsva",function(){return a}),e.d(t,"Sphere",function(){return r}),e.d(t,"plane",function(){return i}),e.d(t,"QuadData",function(){return s}),e.d(t,"CubeData",function(){return l});const s=[-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0],l=[-1,-1,-1,0,0,-1,0,0,1,1,-1,0,0,-1,1,1,1,-1,-1,0,0,-1,1,0,1,1,-1,0,0,-1,1,1,-1,-1,-1,0,0,-1,0,0,-1,1,-1,0,0,-1,0,1,-1,-1,1,0,0,1,0,0,1,-1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,-1,1,1,0,0,1,0,1,-1,-1,1,0,0,1,0,0,-1,1,1,-1,0,0,1,0,-1,1,-1,-1,0,0,1,1,-1,-1,-1,-1,0,0,0,1,-1,-1,-1,-1,0,0,0,1,-1,-1,1,-1,0,0,0,0,-1,1,1,-1,0,0,1,0,1,1,1,1,0,0,1,0,1,-1,-1,1,0,0,0,1,1,1,-1,1,0,0,1,1,1,-1,-1,1,0,0,0,1,1,1,1,1,0,0,1,0,1,-1,1,1,0,0,0,0,-1,-1,-1,0,-1,0,0,1,1,-1,-1,0,-1,0,1,1,1,-1,1,0,-1,0,1,0,1,-1,1,0,-1,0,1,0,-1,-1,1,0,-1,0,0,0,-1,-1,-1,0,-1,0,0,1,-1,1,-1,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,-1,0,1,0,1,1,1,1,1,0,1,0,1,0,-1,1,-1,0,1,0,0,1,-1,1,1,0,1,0,0,0]},85:function(n,t){n.exports="precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying   vec3 vNormal;\nvarying vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"},86:function(n,t){n.exports="\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"}}]);