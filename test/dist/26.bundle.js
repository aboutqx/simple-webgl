(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{107:function(n,e,o){"use strict";o.r(e),o.d(e,"default",(function(){return l}));var t=o(43),a=o(4),r=o(53),i=o(1),s=o(0);const c=[0,3,0];class l extends t.a{constructor(){super()}init(){this.prg=this.compile(r.a,"#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec3 vPosition;\nin vec2 vTexCoord;\nin vec3 TangentLightPos;\nin vec3 TangentViewPos;\nin vec3 TangentFragPos;\n\nuniform sampler2D diffuseMap;\nuniform sampler2D normalMap;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nvoid main()\n{\n     // obtain normal from normal map in range [0,1]\n    vec3 normal = texture(normalMap, vTexCoord).rgb;\n    // transform normal vector to range [-1,1]\n    normal = normalize(normal * 2.0 - 1.0);  // this normal is in tangent space\n\n    // get diffuse color\n    vec3 color = texture(diffuseMap, vTexCoord).rgb;\n    // ambient\n    vec3 ambient = 0.1 * color;\n    // diffuse\n    vec3 lightDir = normalize(TangentLightPos - TangentFragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * color;\n    // specular\n    vec3 viewDir = normalize(TangentViewPos - TangentFragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n\n    vec3 specular = vec3(0.2) * spec;\n    FragColor = vec4(ambient + diffuse + specular, 1.0);\n}\n")}attrib(){const n=(n=>{const e=i.e.fromValues(-1,0,-1),o=i.e.fromValues(-1,0,1),t=i.e.fromValues(1,0,1),a=i.e.fromValues(1,0,-1),r=i.d.fromValues(0,1),s=i.d.fromValues(0,0),c=i.d.fromValues(1,0),l=i.d.fromValues(1,1),u=i.e.fromValues(0,1,0),m=i.e.create(),f=i.e.create(),v=i.d.create(),g=i.d.create();i.e.subtract(m,o,e),i.e.subtract(f,t,e),i.d.subtract(v,s,r),i.d.subtract(g,c,r);let d=1/(v[0]*g[1]-g[0]*v[1]);const p=i.e.create(),h=i.e.create(),T=i.e.create(),b=i.e.create();p[0]=d*(g[1]*m[0]-v[1]*f[0]),p[1]=d*(g[1]*m[1]-v[1]*f[1]),p[2]=d*(g[1]*m[2]-v[1]*f[2]),i.e.normalize(p,p),h[0]=d*(-g[0]*m[0]+v[0]*f[0]),h[1]=d*(-g[0]*m[1]+v[0]*f[1]),h[2]=d*(-g[0]*m[2]+v[0]*f[2]),i.e.normalize(h,h),i.e.subtract(m,t,e),i.e.subtract(f,a,e),i.d.subtract(v,c,r),i.d.subtract(g,l,r),d=1/(v[0]*g[1]-g[0]*v[1]),T[0]=d*(g[1]*m[0]-v[1]*f[0]),T[1]=d*(g[1]*m[1]-v[1]*f[1]),T[2]=d*(g[1]*m[2]-v[1]*f[2]),i.e.normalize(T,T),b[0]=d*(-g[0]*m[0]+v[0]*f[0]),b[1]=d*(-g[0]*m[1]+v[0]*f[1]),b[2]=d*(-g[0]*m[2]+v[0]*f[2]),i.e.normalize(b,b);const P=[[e,o,t,e,t,a],Array.from({length:6}).fill(u),[r,s,c,r,c,l],[p,p,p,T,T,T],[Array.from({length:3}).fill(h),Array.from({length:3}).fill(b)]];return console.log(P),P})();this.quad=new a.a,this.quad.bufferVertex(n[0]),this.quad.bufferNormal(n[1]),this.quad.bufferTexCoord(n[2]),this.quad.bufferData(n[3],"tangent",3),this.quad.bufferData(n[4],"bitangent",3),this.quad.bufferIndex([0,1,2,3,4,5])}prepare(){this.orbital.offset=[0,2,0],s.c.enable(s.c.DEPTH_TEST),s.c.depthFunc(s.c.LEQUAL),s.c.clearColor(.3,.3,.3,1),s.c.clearDepth(1)}uniform(){let n=i.b.create();i.b.scale(n,n,[1.8,1.8,1.8]),this.prg.use(),this.prg.style({mMatrix:n,viewPos:this.camera.position,lightPos:c,diffuseMap:getAssets.brickwall,normalMap:getAssets.brickwallNormal})}render(){s.c.clear(s.c.COLOR_BUFFER_BIT|s.c.DEPTH_BUFFER_BIT),this.prg.use(),s.a.draw(this.quad)}}},53:function(n,e,o){"use strict";e.a="#version 300 es\n// normal map\nprecision highp float;\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\nlayout (location = 3) in vec3 tangent;\nlayout (location = 4) in vec3 bitangent;\n\nout vec3 vPosition;\nout vec2 vTexCoord;\nout vec3 TangentLightPos;\nout vec3 TangentViewPos;\nout vec3 TangentFragPos;\n\nuniform mat4 uProjectionMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 mMatrix;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nvoid main() {\n  vPosition = vec3(mMatrix * vec4(position, 1.));\n  vTexCoord = texCoord;\n\n  mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n  vec3 T = normalize(normalMatrix * tangent);\n  vec3 N = normalize(normalMatrix * normal);\n  T = normalize(T - dot(T, N) * N);\n  vec3 B = cross(N, T);\n\n  mat3 TBN = transpose(mat3(T, B, N));\n  TangentLightPos = TBN * lightPos;\n  TangentViewPos  = TBN * viewPos;\n  TangentFragPos  = TBN * vPosition;\n\n  gl_Position = uProjectionMatrix * uViewMatrix * mMatrix * vec4(position, 1.0);\n}\n"}}]);