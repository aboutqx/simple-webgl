(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{26:function(t,e,i){var n=i(4);function r(t,e){this.gl=t,this.width=0,this.height=0,this.fbo=null;var i=(e=e||s).depth|e.stencil<<1,r=e.type||t.UNSIGNED_BYTE;this.types=Array.isArray(r)?r:[r],this.color=new n(t,e.format),this.attachment=new o(this,i)}function o(t,e){this.fbo=t,this.flags=e,this.buffer=null}r.prototype={resize:function(t,e){this.width===t&&this.height===e||(this.width=0|t,this.height=0|e,null===this.fbo&&this._init(),this._allocate())},bindColor:function(t,e){var i=this.gl;i.activeTexture(i.TEXTURE0+e),i.bindTexture(i.TEXTURE_2D,this.color.id),i.uniform1i(t,e)},bind:function(){var t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,this.fbo),t.viewport(0,0,this.width,this.height)},unbind:function(){var t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null)},clear:function(){var t=this.gl,e=t.COLOR_BUFFER_BIT|this.attachment.clearBits();t.clear(e)},isValid:function(){var t=this.gl;return t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE},getActualType:function(){return this.color.type},dispose:function(){this.gl.deleteFramebuffer(this.fbo),this.color.dispose(),this.attachment.dispose(),this.valid=!1,this.fbo=null,this.gl=null},_init:function(){var t=this.gl;this.fbo=t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this.fbo),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.color.id,0),this.attachment._init()},_allocate:function(){var t=this.gl;this.attachment._allocate(),t.bindFramebuffer(t.FRAMEBUFFER,this.fbo);var e=0,i=this.types[e];do{this.color.fromData(this.width,this.height,null,i),t.getError()}while(!(this.valid=this.isValid())&&(i=this.types[++e]));t.bindFramebuffer(t.FRAMEBUFFER,null)}},o.prototype={_init:function(){var t=this.fbo.gl,e=3&this.flags,i=null;0!==e&&(i=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,i),t.framebufferRenderbuffer(t.FRAMEBUFFER,function(t,e){switch(e){case 1:return 36096;case 2:return 36128;case 3:return 33306;default:throw new Error("unknown attachment type "+e)}}(0,e),t.RENDERBUFFER,i)),this.buffer=i},_allocate:function(){var t=this.fbo.gl,e=3&this.flags;0!==e&&(t.bindRenderbuffer(t.RENDERBUFFER,this.buffer),t.renderbufferStorage(t.RENDERBUFFER,function(t,e){switch(e){case 1:return 33189;case 2:return 36168;case 3:return 34041;default:throw new Error("unknown attachment type "+e)}}(0,e),this.fbo.width,this.fbo.height),t.bindRenderbuffer(t.RENDERBUFFER,null))},dispose:function(){this.buffer&&this.fbo.gl.deleteRenderbuffer(this.buffer),this.buffer=null},clearBits:function(){return(1&this.flags?256:0)|(2&this.flags?1024:0)}};var s={};t.exports=r},4:function(t,e){var i=0,n=3553;function r(t,e,i){return 9728|+t|+e<<8|+(e&&i)<<1}function o(t,e){return this._uid=i++,this.gl=t,this.id=this.gl.createTexture(),this.width=0,this.height=0,this.format=e||t.RGB,this.type=t.UNSIGNED_BYTE,this.img=null,t.bindTexture(n,this.id),this.setFilter(!0),this}o.prototype={fromImage:function(t){var e=this.gl;return this.img=t,this.width=t.width,this.height=t.height,e.bindTexture(n,this.id),e.texImage2D(n,0,this.format,this.format,this.type,t),this},fromData:function(t,e,i,r){var o=this.gl;return this.width=t,this.height=e,i=i||null,this.type=r||o.UNSIGNED_BYTE,o.bindTexture(n,this.id),window.useWebgl2?r===o.RGBA16F?o.texImage2D(o.TEXTURE_2D,0,this.type,t,e,0,this.format,o.HALF_FLOAT,i):r===o.RG32F||r===o.RGBA32F||r===o.RGB32F?o.texImage2D(o.TEXTURE_2D,0,this.type,t,e,0,this.format,o.FLOAT,i):o.texImage2D(n,0,this.format,t,e,0,this.format,this.type,i):o.texImage2D(n,0,this.format,t,e,0,this.format,this.type,i),this},bind:function(t){var e=this.gl;void 0!==t&&e.activeTexture(e.TEXTURE0+(0|t)),e.bindTexture(n,this.id)},dispose:function(){this.gl&&this.gl.deleteTexture(this.id),this.id=null,this.gl=null},setFilter:function(t,e,i){var o=this.gl,s=r(!!t,!!e,!!i);o.texParameteri(n,o.TEXTURE_MAG_FILTER,r(!!t,!1,!1)),o.texParameteri(n,o.TEXTURE_MIN_FILTER,s)},repeat:function(){this.wrap(this.gl.REPEAT)},clamp:function(){this.wrap(this.gl.CLAMP_TO_EDGE)},mirror:function(){this.wrap(this.gl.MIRRORED_REPEAT)},wrap:function(t){var e=this.gl;e.texParameteri(n,e.TEXTURE_WRAP_S,t),e.texParameteri(n,e.TEXTURE_WRAP_T,t)}},t.exports=o},48:function(t,e,i){"use strict";i.r(e),i.d(e,"default",function(){return I});var n=i(10),r=i.n(n),o=i(2),s=i(5),a=i(0),c=i(89),l=i.n(c),u=i(90),h=i.n(u),f=i(17),m=i.n(f),d=i(91),E=i.n(d),g=i(92),b=i.n(g),T=i(93),R=i.n(T),p=i(6),F=i(1),x=i(3),v=i(18),_=i(35),D=i(26),P=i.n(D),A=i(4),U=i.n(A),B=i(8);const w=[0,-1,0],M=[.2,.2,.7];let N=new Float32Array(192),C=new Float32Array(48);const y=()=>{for(let t=0;t<64;t++){let e=F.e.fromValues(2*Math.random()-1,2*Math.random()-1,Math.random());N[3*t]=e[0],N[3*t+1]=e[1],N[3*t+2]=e[2]}},L=()=>{for(let t=0;t<16;t++){let e=F.e.fromValues(2*Math.random()-1,2*Math.random()-1,0);C[3*t]=e[0],C[3*t+1]=e[1],C[3*t+2]=e[2]}};class I extends s.default{constructor(){super(),Object(o.a)(this,"count",0)}init(){a.c.getExtension("OES_texture_float_linear"),a.c.getExtension("EXT_color_buffer_float"),a.c.getExtension("OES_texture_half_float_linear"),this.gBufferPrg=this.compile(l.a,h.a),this.ssaoPrg=this.compile(m.a,E.a),this.blurPrg=this.compile(m.a,b.a),this.prg=this.compile(m.a,R.a)}attrib(){var t,e;return r.a.async(function(i){for(;;)switch(i.prev=i.next){case 0:return this.cube=B.a.cube(2),(t=new x.a).bufferData(p.QuadData,["position","texCoord"],[3,2]),this.quad=t,i.next=6,r.a.awrap(new _.a("nanosuit.mtl","./assets/models/nanosuit").parse(getAssets.nanosuitMTL));case 6:e=i.sent,this.nanosuit=(new v.a).parseObj(getAssets.nanosuit,e);case 8:case"end":return i.stop()}},null,this)}prepare(){a.c.clearColor(0,0,0,1),a.c.clearDepth(1),a.c.enable(a.c.DEPTH_TEST),a.c.depthFunc(a.c.LEQUAL),this.mrt=function(t,e,i){let n=a.c.createFramebuffer();a.c.bindFramebuffer(a.c.FRAMEBUFFER,n);let r=[];const o=[];for(let n=0;n<i.length;++n)r[n]=a.c.createTexture(),a.c.bindTexture(a.c.TEXTURE_2D,r[n]),"16f"===i[n]?a.c.texImage2D(a.c.TEXTURE_2D,0,a.c.RGBA16F,t,e,0,a.c.RGBA,a.c.HALF_FLOAT,null):a.c.texImage2D(a.c.TEXTURE_2D,0,a.c.RGBA,t,e,0,a.c.RGBA,a.c.UNSIGNED_BYTE,null),a.c.texParameteri(a.c.TEXTURE_2D,a.c.TEXTURE_MAG_FILTER,a.c.LINEAR),a.c.texParameteri(a.c.TEXTURE_2D,a.c.TEXTURE_MIN_FILTER,a.c.LINEAR),a.c.texParameteri(a.c.TEXTURE_2D,a.c.TEXTURE_WRAP_S,a.c.CLAMP_TO_EDGE),a.c.texParameteri(a.c.TEXTURE_2D,a.c.TEXTURE_WRAP_T,a.c.CLAMP_TO_EDGE),a.c.framebufferTexture2D(a.c.FRAMEBUFFER,a.c.COLOR_ATTACHMENT0+n,a.c.TEXTURE_2D,r[n],0),o.push(a.c.COLOR_ATTACHMENT0+n);a.c.drawBuffers(o);const s=a.c.createRenderbuffer();a.c.bindRenderbuffer(a.c.RENDERBUFFER,s),a.c.renderbufferStorage(a.c.RENDERBUFFER,a.c.DEPTH24_STENCIL8,t,e),a.c.framebufferRenderbuffer(a.c.FRAMEBUFFER,a.c.DEPTH_ATTACHMENT,a.c.RENDERBUFFER,s);const c=a.c.checkFramebufferStatus(a.c.FRAMEBUFFER);c!=a.c.FRAMEBUFFER_COMPLETE&&console.log(`gl.checkFramebufferStatus() returned ${c.toString(16)}`);return a.c.bindTexture(a.c.TEXTURE_2D,null),a.c.bindRenderbuffer(a.c.RENDERBUFFER,null),a.c.bindFramebuffer(a.c.FRAMEBUFFER,null),{frameBuffer:n,depthBuffer:s,texture:r}}(a.b.width,a.b.height,["16f","16f","rgba"]),this.ssaoFbo=new P.a(a.c),this.ssaoFbo.resize(a.b.width,a.b.height),this.blurFbo=new P.a(a.c),this.blurFbo.resize(a.b.width,a.b.height),y(),L(),this.noiseTexture=new U.a(a.c,a.c.RGB).fromData(4,4,C,a.c.RGB32F),this.noiseTexture.bind(),this.noiseTexture.repeat(),this.camera.target=[0,-1,0],this.camera.offset=[0,0,0],this.camera.radius=3,this.camera.rx=-1.5}uniform(){this.vMatrix=this.camera.viewMatrix,this.pMatrix=F.b.identity(F.b.create()),F.b.perspective(this.pMatrix,Object(a.d)(60),a.b.clientWidth/a.b.clientHeight,.1,100)}render(){if(a.c.bindFramebuffer(a.c.FRAMEBUFFER,this.mrt.frameBuffer),a.c.clear(a.c.COLOR_BUFFER_BIT|a.c.DEPTH_BUFFER_BIT),this.gBufferPrg.use(),this.gBufferPrg.style({vMatrix:this.vMatrix,pMatrix:this.pMatrix}),this.nanosuit){let t=F.b.identity(F.b.create());F.b.translate(t,t,[-1,-3.3,3]),F.b.scale(t,t,[.4,.4,.4]),F.b.rotate(t,t,-Math.PI/2,[1,0,0]),this.gBufferPrg.style({mMatrix:t,invertedNormals:0});for(let t=0;t<this.nanosuit.length;t++)this.nanosuit[t].bind(this.gBufferPrg,["position","normal","texCoord"]),this.nanosuit[t].draw()}let t=F.b.identity(F.b.create());F.b.scale(t,t,[8,4,8]),this.gBufferPrg.style({mMatrix:t,invertedNormals:1}),this.cube.bind(this.gBufferPrg,["position","normal","texCoord"]),this.cube.draw(),a.c.bindFramebuffer(a.c.FRAMEBUFFER,null),this.ssaoFbo.bind(),a.c.clear(a.c.COLOR_BUFFER_BIT),a.c.activeTexture(a.c.TEXTURE0),a.c.bindTexture(a.c.TEXTURE_2D,this.mrt.texture[0]),a.c.activeTexture(a.c.TEXTURE1),a.c.bindTexture(a.c.TEXTURE_2D,this.mrt.texture[1]),this.noiseTexture.bind(2),this.ssaoPrg.use(),this.ssaoPrg.style({gPositionDepth:0,gNormal:1,texNoise:2,samples:N,pMatrix:this.pMatrix}),this.quad.bind(this.ssaoPrg,["position","texCoord"]),this.quad.draw(a.c.TRIANGLE_STRIP),this.ssaoFbo.unbind(),this.blurFbo.bind(),this.ssaoFbo.color.bind(0),this.blurPrg.use(),this.blurPrg.style({ssaoInput:0}),this.quad.bind(this.blurPrg,["position","texCoord"]),this.quad.draw(a.c.TRIANGLE_STRIP),this.blurFbo.unbind(),a.c.clear(a.c.COLOR_BUFFER_BIT|a.c.DEPTH_BUFFER_BIT),a.c.activeTexture(a.c.TEXTURE0),a.c.bindTexture(a.c.TEXTURE_2D,this.mrt.texture[0]),a.c.activeTexture(a.c.TEXTURE1),a.c.bindTexture(a.c.TEXTURE_2D,this.mrt.texture[1]),a.c.activeTexture(a.c.TEXTURE2),a.c.bindTexture(a.c.TEXTURE_2D,this.mrt.texture[2]),this.blurFbo.color.bind(3),this.prg.use(),this.prg.style({gPosition:0,gNormal:1,gAlbedoSpec:2,ssao:3,viewPos:this.camera.cameraPos,"lights.Position":w,"lights.Color":M,"lights.Linear":.09,"lights.Quadratic":.032}),this.quad.bind(this.prg,["position","texCoord"]),this.quad.draw(a.c.TRIANGLE_STRIP)}}},89:function(t,e){t.exports="#version 300 es\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\nout vec3 FragPos;\nout vec2 TexCoords;\nout vec3 Normal;\n\nuniform bool invertedNormals;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    vec4 viewPos = vMatrix * mMatrix * vec4(position, 1.0);\n    FragPos = vec3(viewPos);\n    TexCoords = texCoord;\n\n    mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n    Normal = normalMatrix * (invertedNormals ? -normal : normal);\n\n    gl_Position = pMatrix * viewPos;\n}\n"},90:function(t,e){t.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nlayout (location = 0) out vec3 gPositionDepth;\nlayout (location = 1) out vec3 gNormal;\nlayout (location = 2) out vec4 gAlbedoSpec;\n\nin vec2 TexCoords;\nin vec3 FragPos;\nin vec3 Normal;\n\nconst float NEAR = 0.1; // 投影矩阵的近平面\nconst float FAR = 50.0f; // 投影矩阵的远平面\nfloat LinearizeDepth(float depth)\n{\n    float z = depth * 2.0 - 1.0; // 回到NDC\n    return (2.0 * NEAR * FAR) / (FAR + NEAR - z * (FAR - NEAR));\n}\n\n\nvoid main()\n{\n    // store the fragment position vector in the first gbuffer texture\n    gPositionDepth.xyz = FragPos;\n    // // 储存线性深度到gPositionDepth的alpha分量\n    // gPositionDepth.a = LinearizeDepth(gl_FragCoord.z);\n    // also store the per-fragment normals into the gbuffer\n    gNormal = normalize(Normal);\n    // and the diffuse per-fragment color\n    gAlbedoSpec.rgb = vec3(0.95);\n}\n"},91:function(t,e){t.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout float FragColor;\nin vec2 TexCoords;\n\nuniform sampler2D gPositionDepth;\nuniform sampler2D gNormal;\nuniform sampler2D texNoise;\n\nuniform vec3 samples[64];\nuniform mat4 pMatrix;\n\nint kernelSize = 64;\nfloat radius = 0.5;\nfloat bias = 0.025;\n// 屏幕的平铺噪声纹理会根据屏幕分辨率除以噪声大小的值来决定\nconst vec2 noiseScale = vec2(960.0/4.0, 640.0/4.0);\n\nvoid main() {\n    vec3 fragPos = texture(gPositionDepth, TexCoords).xyz;\n    vec3 normal = texture(gNormal, TexCoords).rgb;\n    vec3 randomVec = texture(texNoise, TexCoords * noiseScale).xyz;\n\n    // Gramm-Schmidt正交化\n    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\n    vec3 bitangent = cross(normal, tangent);\n    mat3 TBN = mat3(tangent, bitangent, normal);\n\n    float occlusion = 0.0;\n    for(int i = 0; i < kernelSize; ++i)\n    {\n        // 获取样本位置\n        vec3 sample1 = TBN * samples[i]; // 切线->观察空间\n        sample1 = fragPos + sample1 * radius;\n\n        vec4 offset = vec4(sample1, 1.0);\n        offset = pMatrix * offset; // 观察->裁剪空间\n        offset.xyz /= offset.w; // 透视划分\n        offset.xyz = offset.xyz * 0.5 + 0.5; // 变换到0.0 - 1.0的值域\n\n        float sampleDepth = texture(gPositionDepth, offset.xy).z;\n        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));\n        occlusion += (sampleDepth >= sample1.z ? 1.0 : 0.0) * rangeCheck;\n\n    }\n    occlusion = 1.0 - (occlusion / float(kernelSize));\n    FragColor = occlusion;\n}\n"},92:function(t,e){t.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin vec2 TexCoords;\nout float FragColor;\nuniform sampler2D ssaoInput;\n\nvoid main() {\n  // simple box filter\n  vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0));\n  float result = 0.0;\n  for (int x = -2; x < 2; ++x)\n  {\n    for (int y = -2; y < 2; ++y)\n    {\n        vec2 offset = vec2(float(x), float(y)) * texelSize;\n        result += texture(ssaoInput, TexCoords + offset).r;\n    }\n  }\n  FragColor = result / (4.0 * 4.0);\n\n}\n"},93:function(t,e){t.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nout vec4 outColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedoSpec;\nuniform sampler2D ssao;\n\nstruct Light {\n    vec3 Position;\n    vec3 Color;\n\n    float Linear;\n    float Quadratic;\n};\nuniform Light lights;\nuniform vec3 viewPos;\n\nvoid main() {\n    vec3 FragPos = texture(gPosition, TexCoords).rgb;\n    vec3 Normal = texture(gNormal, TexCoords).rgb;\n    vec3 Diffuse = texture(gAlbedoSpec, TexCoords).rgb;\n    float AmbientOcclusion = texture(ssao, TexCoords).r;\n\n    // then calculate lighting as usual\n    vec3 ambient = vec3(0.3 * Diffuse * AmbientOcclusion);\n    vec3 lighting  = ambient;\n    vec3 viewDir  = normalize(- FragPos);\n\n\n    // diffuse\n    vec3 lightDir = normalize(lights.Position - FragPos);\n    vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * lights.Color;\n    // specular\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(Normal, halfwayDir), 0.0), 16.0);\n    vec3 specular = lights.Color * spec;\n    // attenuation\n    float distance = length(lights.Position - FragPos);\n    float attenuation = 1.0 / (1.0 + lights.Linear * distance + lights.Quadratic * distance * distance);\n    diffuse *= attenuation;\n    specular *= attenuation;\n    lighting += diffuse + specular;\n\n    outColor = vec4(lighting, 1.0);\n}\n"}}]);