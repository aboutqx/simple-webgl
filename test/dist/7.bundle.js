(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{44:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var r=n(0);class s{constructor(t,e){this._mesh=t,this._shader=e}draw(t){this._shader.bind(),this._shader.style(t),r.a.draw(this._mesh)}get mesh(){return this._mesh}get shader(){return this._shader}}},45:function(t,e,n){"use strict";var r=n(0),s=n(3);let i,a;e.a=class{constructor(t,e,n={},s=1){i=!window.useWebgl2&&r.c.getExtension("WEBGL_depth_texture"),this.width=t||r.b.width,this.height=e||r.b.height,this._numTargets=s,this._multipleTargets=s>1,1==n.hdr?this._parameters={internalFormat:r.c.RGBA16F,type:r.c.HALF_FLOAT,minFilter:n.minFilter,maxFilter:n.magFilter}:this._parameters=n,window.useWebgl2||(a=r.c.getExtension("WEBGL_draw_buffers")),this._multipleTargets&&this._checkMaxNumRenderTarget(),this._init()}_init(){if(this._initTextures(),this.frameBuffer=r.c.createFramebuffer(),r.c.bindFramebuffer(r.c.FRAMEBUFFER,this.frameBuffer),window.useWebgl2){if(0===this._numTargets)r.c.readBuffer(r.c.NONE),r.c.drawBuffers([r.c.NONE]);else{const t=[];for(let e=0;e<this._numTargets;e++)r.c.framebufferTexture2D(r.c.DRAW_FRAMEBUFFER,r.c.COLOR_ATTACHMENT0+e,r.c.TEXTURE_2D,this._textures[e].texture,0),t.push(r.c["COLOR_ATTACHMENT"+e]);r.c.drawBuffers(t)}r.c.framebufferTexture2D(r.c.DRAW_FRAMEBUFFER,r.c.DEPTH_ATTACHMENT,r.c.TEXTURE_2D,this.glDepthTexture.texture,0)}else{for(let t=0;t<this._numTargets;t++)r.c.framebufferTexture2D(r.c.FRAMEBUFFER,r.c.COLOR_ATTACHMENT0+t,r.c.TEXTURE_2D,this._textures[t].texture,0);if(this._multipleTargets){const t=[];for(let e=0;e<this._numTargets;e++)t.push(a[`COLOR_ATTACHMENT${e}_WEBGL`]);a.drawBuffersWEBGL(t)}i&&r.c.framebufferTexture2D(r.c.FRAMEBUFFER,r.c.DEPTH_ATTACHMENT,r.c.TEXTURE_2D,this.glDepthTexture.texture,0)}r.c.checkFramebufferStatus(r.c.FRAMEBUFFER)!=r.c.FRAMEBUFFER_COMPLETE&&console.log("gl.checkFramebufferStatus() returned "+status.toString(16)),r.c.bindTexture(r.c.TEXTURE_2D,null),r.c.bindRenderbuffer(r.c.RENDERBUFFER,null),r.c.bindFramebuffer(r.c.FRAMEBUFFER,null),this.clear()}_checkMaxNumRenderTarget(){const t=window.useWebgl2?r.c.getParameter(r.c.MAX_DRAW_BUFFERS):r.c.getParameter(a.MAX_DRAW_BUFFERS_WEBGL);this._numTargets>t&&(console.error("Over max number of draw buffers supported : ",t),this._numTargets=t)}_initTextures(){this._textures=[];for(let t=0;t<this._numTargets;t++){const t=this._createTexture();this._textures.push(t)}window.useWebgl2?this.glDepthTexture=this._createTexture(r.c.DEPTH_COMPONENT16,r.c.UNSIGNED_SHORT,r.c.DEPTH_COMPONENT,{minFilter:r.c.NEAREST,magFilter:r.c.NEAREST}):this.glDepthTexture=this._createTexture(r.c.DEPTH_COMPONENT,r.c.UNSIGNED_SHORT,r.c.DEPTH_COMPONENT,{minFilter:r.c.LINEAR})}_createTexture(t,e,n,i={}){const a=Object.assign({},this._parameters);a.internalFormat=t||a.internalFormat,a.format=n||a.format||r.c.RGBA,a.type=e||a.type||r.c.UNSIGNED_BYTE;for(const t in i)a[t]=i[t];return new s.a(null,a,this.width,this.height)}bind(t=!0){t&&r.c.viewport(0,0,this.width,this.height),r.c.bindFramebuffer(r.c.FRAMEBUFFER,this.frameBuffer),r.a.clear(0,0,0,1)}unbind(t=!0){t&&r.c.viewport(0,0,r.b.width,r.b.height),r.c.bindFramebuffer(r.c.FRAMEBUFFER,null),this._textures.forEach(t=>{t.generateMipmap()})}clear(t=0,e=0,n=0,s=0){this.bind(),r.a.clear(t,e,n,s),this.unbind()}get textures(){return this._textures}getTexture(t=0){return this._textures[t]}get depthTexture(){return this.glDepthTexture}get minFilter(){return this._textures[0].minFilter}set minFilter(t){this._textures.forEach(e=>{e.minFilter=t})}get magFilter(){return this._textures[0].magFilter}set magFilter(t){this._textures.forEach(e=>{e.magFilter=t})}get wrapS(){return this._textures[0].wrapS}set wrapS(t){this._textures.forEach(e=>{e.wrapS=t})}get wrapT(){return this._textures[0].wrapT}set wrapT(t){this._textures.forEach(e=>{e.wrapT=t})}showParameters(){this._textures[0].showParameters()}get numTargets(){return this._numTargets}}},46:function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(13),s=n(15),i=n(42),a=n(44);class o extends a.a{constructor(t){const e=new s.a(r.c,t);super(i.a.bigTriangle(),e)}draw(t){super.draw(t)}}},66:function(t,e,n){"use strict";var r=n(57),s=n(1);class i extends r.a{constructor(){super();const t=s.e.clone([0,0,5]),e=s.e.create(),n=s.e.clone([0,1,0]);this.lookAt(t,e,n),this.ortho(-1,1,1,-1)}setBoundary(t,e,n,r,s=.1,i=100){this.ortho(t,e,n,r,s,i)}ortho(t,e,n,r,i=.1,a=100){this.left=t,this.right=e,this.top=n,this.bottom=r,s.b.ortho(this._projection,t,e,r,n,i,a)}}e.a=i},93:function(t,e,n){"use strict";n.r(e),n.d(e,"default",(function(){return h}));var r=n(2),s=n(43),i=n(4),a=n(45),o=n(0),c=n(46),u=n(66);n(42);const x=function(t,e){return t+Math.random()*(e-t)};class h extends s.a{constructor(){super(),Object(r.a)(this,"_count",0)}init(){this.saveprg=this.compile("#version 300 es\n// save.vert\n\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nin vec3 normal;\nin vec3 aExtra;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nout vec2 vTexCoord;\nout vec3 vPos;\nout vec3 vNormal;\nout vec3 vExtra;\n\nvoid main(void) {\n\tvPos      = position;\n\tvec3 pos    = vec3(texCoord, 0.0);\n\tgl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\n    gl_PointSize = 1.0;\n    vNormal = normal;\n\tvExtra  = aExtra;\n}","#version 300 es\n// save.frag\n\nprecision highp float;\n#define GLSLIFY 1\n\nin vec3 vPos;\nin vec3 vExtra;\n\nlayout (location = 0) out vec4 currentPos;\nlayout (location = 1) out vec4 extraPos;\nlayout (location = 2) out vec4 velocity;\nvoid main(void) {\n    currentPos = vec4(vPos, 1.0);\n    extraPos   = vec4(vExtra, 1.0);\n    velocity   =  vec4(0., 0., 0., 1.);\n}"),this.renderPrg=this.basicColor("#version 300 es\n// petal.vert\n\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec3 normal;\nin vec2 aUV;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform sampler2D textureCurr;\nuniform sampler2D textureNext;\nuniform sampler2D textureExtra;\nuniform float percent;\nuniform float time;\nout vec4 vColor;\nout vec3 vNormal;\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nvoid main(void) {\n\n\tvec3 currPos = texture(textureCurr, aUV).rgb;\n\tvec3 nextPos = texture(textureNext, aUV).rgb;\n    vec3 extra   = texture(textureExtra, aUV).rgb;\n\tvec3 pos     = mix(currPos, nextPos, percent);\n\n    float scale = 0.1 + extra.g * 0.3;\n\tvec3 Position = rotate(position, normalize(extra), time * extra.r + extra.b) * scale;\n\tPosition += pos;\n\n\tvec4 V       = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(Position, 1.0);\n\tgl_Position  = V;\n\n\tvNormal = normal;\n}"),window.params={gamma:2.2,exposure:5,numParticles:10,skipCount:2,maxRadius:12.5},this._vSim=new c.a("#version 300 es\n// simVel.frag\n\nprecision highp float;\n#define GLSLIFY 1\n\nin vec2 vTexCoord;\nuniform sampler2D textureVel;\nuniform sampler2D texturePos;\nuniform sampler2D textureExtra;\nuniform float time;\nuniform float maxRadius;\nlayout (location = 0) out vec4 newPos;\nlayout (location = 1) out vec4 extras;\nlayout (location = 2) out vec4 velocity;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;  }\n\nvec4 permute(vec4 x) {  return mod289(((x*34.0)+1.0)*x);  }\n\nvec4 taylorInvSqrt(vec4 r) {  return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v) { \n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\tvec3 i  = floor(v + dot(v, C.yyy) );\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min( g.xyz, l.zxy );\n\tvec3 i2 = max( g.xyz, l.zxy );\n\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\ti = mod289(i); \n\tvec4 p = permute( permute( permute( \n\t\t\t\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t\t\t + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t\t\t + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\tvec3 p0 = vec3(a0.xy,h.x);\n\tvec3 p1 = vec3(a0.zw,h.y);\n\tvec3 p2 = vec3(a1.xy,h.z);\n\tvec3 p3 = vec3(a1.zw,h.w);\n\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ){\n\n\tfloat s  = snoise(vec3( x ));\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n\tvec3 c = vec3( s , s1 , s2 );\n\treturn c;\n\n}\n\nvec3 curlNoise( vec3 p ){\n\t\n\tconst float e = .1;\n\tvec3 dx = vec3( e   , 0.0 , 0.0 );\n\tvec3 dy = vec3( 0.0 , e   , 0.0 );\n\tvec3 dz = vec3( 0.0 , 0.0 , e   );\n\n\tvec3 p_x0 = snoiseVec3( p - dx );\n\tvec3 p_x1 = snoiseVec3( p + dx );\n\tvec3 p_y0 = snoiseVec3( p - dy );\n\tvec3 p_y1 = snoiseVec3( p + dy );\n\tvec3 p_z0 = snoiseVec3( p - dz );\n\tvec3 p_z1 = snoiseVec3( p + dz );\n\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n\tconst float divisor = 1.0 / ( 2.0 * e );\n\treturn normalize( vec3( x , y , z ) * divisor );\n\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nconst float PI = 3.141592653;\n\nvoid main(void) {\n\tvec3 pos        = texture(texturePos, vTexCoord).rgb;\n\tvec3 vel        = texture(textureVel, vTexCoord).rgb;\n\tvec3 extra      = texture(textureExtra, vTexCoord).rgb;\n\tfloat posOffset = mix(extra.r, 1.0, 0.2) * .25;\n\tvec3 acc        = curlNoise(pos * posOffset + time * .3);\n\t\n\tvel += acc * .002;\n\n\t// rotate at xz plane \n\tvec2 v = normalize(pos.xz);\n\tv = rotate(v, PI * 0.6);\n\tvel.xz += v * .005;\n\n\tfloat dist = length(pos);\n\tvec3 dir = normalize(pos);\n\tif(dist > maxRadius) {\n\t\tfloat f = (dist - maxRadius) * .0025;\n\t\tvel -= dir * f;\n\t}\n\n\tconst float minRadius = 2.;\n\tif(dist < minRadius) {\n\t\tfloat f = (minRadius - dist) * 0.1;\n\t\tvel += dir * f;\n\t}\n\n\tconst float decrease = .93;\n\tvel *= decrease;\n\n\tnewPos = vec4(pos + vel, 1.0);\n\textras  = vec4(extra, 1.);\n\tvelocity = vec4(vel, 1.);\n}"),o.a.applyHdrExtension();const t=params.numParticles,e={minFilter:o.c.NEAREST,magFilter:o.c.NEAREST,hdr:!0};this._fboCurrent=new a.a(2*t,2*t,e,3),this._fboTarget=new a.a(2*t,2*t,e,3),this.cameraOrtho=new u.a,this.orbital.radius=5}_setGUI(){}attrib(){this._initRender(),this._initSave(),this.mousePos={x:0,y:0}}prepare(){this.time=255*Math.random(),o.a.srcBlend(),o.a.setCamera(this.cameraOrtho),this._fboCurrent.bind(),this._renderSave(),this._fboCurrent.unbind(),this._fboTarget.bind(),this._renderSave(),this._fboTarget.unbind(),o.a.setCamera(this.camera)}_initRender(){this.mesh=getAssets.petal;const t=[],e=params.numParticles;let n,r;for(let s=0;s<e;s++)for(let i=0;i<e;i++)n=i/e,r=s/e,t.push([n,r]);this.mesh.bufferInstance(t,"aUV")}_initSave(){const t=[],e=[],n=[],r=[];let s=0;const a=params.numParticles;let c,u;for(let i=0;i<a;i++)for(let o=0;o<a;o++)t.push([x(-3,3),x(-3,3),x(-3,3)]),c=o/a-1+.5/a,u=i/a-1+.5/a,e.push([c,u]),n.push(s),r.push([Math.random(),Math.random(),Math.random()]),s++;this.meshSave=new i.a(o.c.POINTS),this.meshSave.bufferData(r,"aExtra",3),this.meshSave.bufferVertex(t),this.meshSave.bufferTexCoord(e),this.meshSave.bufferIndex(n)}_renderPetal(t,e,n,r){this.time+=.05,this.renderPrg.bind(),this.renderPrg.style({textureCurr:t,textureNext:e,textureExtra:r,percent:n,time:this.time,color:[1,1,1]}),o.a.draw(this.mesh)}_renderSave(){this.saveprg.use(),o.a.draw(this.meshSave)}_renderSim(t,e,n){this.time+=.01,this._vSim.draw({textureVel:t,textureExtra:e,texturePos:n,time:this.time,maxRadius:params.maxRadius})}updateFbo(){o.a.setCamera(this.cameraOrtho),this._fboTarget.bind(),this._renderSim(this._fboCurrent.getTexture(2),this._fboCurrent.getTexture(1),this._fboCurrent.getTexture(0)),this._fboTarget.unbind(),o.a.setCamera(this.camera);const t=this._fboTarget;this._fboTarget=this._fboCurrent,this._fboCurrent=t}render(){o.a.clear();let t=0;this._count%params.skipCount==0&&(this._count=0,this.updateFbo()),t=this._count/params.skipCount,this._count++,o.a.setCamera(this.camera),this._renderPetal(this._fboTarget.getTexture(),this._fboCurrent.getTexture(),t,this._fboCurrent.getTexture(1)),this.frameBufferGUI.textureList=[{texture:this._fboCurrent.getTexture(0)}]}}}}]);