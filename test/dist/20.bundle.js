(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{65:function(e,t,r){"use strict";r.r(t);var i=r(2),n=r(5),o=r(67),s=r.n(o),a=r(68),l=r.n(a),c=r(69),u=r.n(c),h=r(70),f=r.n(h),g=r(1),m=r(0),d=r(8),T=r(13),E=r(14);r(20);let b,F,x=!1;const p=function(){return!!window.useWebgl2||!!(F=m.c.getExtension("WEBGL_draw_buffers"))};var _=class{constructor(e,t,r={},i=1){b=!window.useWebgl2&&m.c.getExtension("WEBGL_depth_texture"),this.width=e,this.height=t,this._numTargets=i,this._multipleTargets=i>1,this._parameters=r,x||p(),this._multipleTargets&&this._checkMaxNumRenderTarget(),this._init()}_init(){if(this._initTextures(),this.frameBuffer=m.c.createFramebuffer(),m.c.bindFramebuffer(m.c.FRAMEBUFFER,this.frameBuffer),window.useWebgl2){let e=m.c.createRenderbuffer();m.c.bindRenderbuffer(m.c.RENDERBUFFER,e),m.c.renderbufferStorage(m.c.RENDERBUFFER,m.c.DEPTH24_STENCIL8,this.width,this.height),m.c.framebufferRenderbuffer(m.c.FRAMEBUFFER,m.c.DEPTH_ATTACHMENT,m.c.RENDERBUFFER,e);const t=[];for(let e=0;e<this._numTargets;e++)m.c.framebufferTexture2D(m.c.DRAW_FRAMEBUFFER,m.c.COLOR_ATTACHMENT0+e,m.c.TEXTURE_2D,this._textures[e].texture,0),t.push(m.c[`COLOR_ATTACHMENT${e}`]);m.c.drawBuffers(t)}else{for(let e=0;e<this._numTargets;e++)m.c.framebufferTexture2D(m.c.FRAMEBUFFER,m.c.COLOR_ATTACHMENT0+e,m.c.TEXTURE_2D,this._textures[e].texture,0);if(this._multipleTargets){const e=[];for(let t=0;t<this._numTargets;t++)e.push(F[`COLOR_ATTACHMENT${t}_WEBGL`]);F.drawBuffersWEBGL(e)}b&&m.c.framebufferTexture2D(m.c.FRAMEBUFFER,m.c.DEPTH_ATTACHMENT,m.c.TEXTURE_2D,this.glDepthTexture.texture,0)}m.c.bindTexture(m.c.TEXTURE_2D,null),m.c.bindRenderbuffer(m.c.RENDERBUFFER,null),m.c.bindFramebuffer(m.c.FRAMEBUFFER,null)}_checkMaxNumRenderTarget(){const e=window.useWebgl2?m.c.getParameter(m.c.MAX_DRAW_BUFFERS):m.c.getParameter(F.MAX_DRAW_BUFFERS_WEBGL);this._numTargets>e&&(console.error("Over max number of draw buffers supported : ",e),this._numTargets=e)}_initTextures(){this._textures=[];for(let e=0;e<this._numTargets;e++){const e=this._createTexture();this._textures.push(e)}}_createTexture(e,t,r,i={}){const n=Object.assign({},this._parameters);n.internalFormat=e||n.internalFormat,n.format=r||n.format||m.c.RGBA,n.type=t||n.type||m.c.UNSIGNED_BYTE;for(const e in i)n[e]=i[e];return new E.a(null,n,this.width,this.height)}bind(e=!0){e&&m.c.viewport(0,0,this.width,this.height),m.c.bindFramebuffer(m.c.FRAMEBUFFER,this.frameBuffer)}unbind(e=!0){e&&m.c.viewport(0,0,m.c.width,m.c.height),m.c.bindFramebuffer(m.c.FRAMEBUFFER,null),this._textures.forEach(e=>{e.generateMipmap()})}clear(e=0,t=0,r=0,i=0){this.bind(),m.a.clear(e,t,r,i),this.unbind()}get textures(){return this._textures}getDepthTexture(){return this.glDepthTexture}get minFilter(){return this._textures[0].minFilter}set minFilter(e){this._textures.forEach(t=>{t.minFilter=e})}get magFilter(){return this._textures[0].magFilter}set magFilter(e){this._textures.forEach(t=>{t.magFilter=e})}get wrapS(){return this._textures[0].wrapS}set wrapS(e){this._textures.forEach(t=>{t.wrapS=e})}get wrapT(){return this._textures[0].wrapT}set wrapT(e){this._textures.forEach(t=>{t.wrapT=e})}showParameters(){this._textures[0].showParameters()}get numTargets(){return this._numTargets}};r.d(t,"default",function(){return R});class R extends n.default{constructor(){super(),Object(i.a)(this,"count",0),m.c.getExtension("EXT_color_buffer_float")}init(){this.prg=this.compile(s.a,l.a),this.blurPrg=this.compile(T.a.bigTriangleVert,u.a),this.finalPrg=this.compile(T.a.bigTriangleVert,f.a)}attrib(){this.statue=d.a.cube(1),this.quad=d.a.bigTriangle()}prepare(){this.camera.radius=3.5;let e=new _(m.b.width,m.b.height,{internalFormat:m.c.RGBA16F,type:m.c.FLOAT},2);this.hdrFbo=e.frameBuffer,this.textures=e.textures;let{pingpongFBO:t,pingpongColorbuffers:r}=function(e,t){const r=[],i=[];for(let n=0;n<2;n++)r[n]=m.c.createFramebuffer(),i[n]=m.c.createTexture(),m.c.bindFramebuffer(m.c.FRAMEBUFFER,r[n]),m.c.bindTexture(m.c.TEXTURE_2D,i[n]),m.c.texImage2D(m.c.TEXTURE_2D,0,m.c.RGBA16F,e,t,0,m.c.RGBA,m.c.FLOAT,null),m.c.texParameteri(m.c.TEXTURE_2D,m.c.TEXTURE_MAG_FILTER,m.c.LINEAR),m.c.texParameteri(m.c.TEXTURE_2D,m.c.TEXTURE_MIN_FILTER,m.c.LINEAR),m.c.texParameteri(m.c.TEXTURE_2D,m.c.TEXTURE_WRAP_S,m.c.CLAMP_TO_EDGE),m.c.texParameteri(m.c.TEXTURE_2D,m.c.TEXTURE_WRAP_T,m.c.CLAMP_TO_EDGE),m.c.framebufferTexture2D(m.c.FRAMEBUFFER,m.c.COLOR_ATTACHMENT0,m.c.TEXTURE_2D,i[n],0);return m.c.bindFramebuffer(m.c.FRAMEBUFFER,null),{pingpongFBO:r,pingpongColorbuffers:i}}(m.b.width,m.b.height);this.pingpongFBO=t,this.pingpongColorbuffers=r,m.c.disable(m.c.DEPTH_TEST),m.c.enable(m.c.BLEND),m.c.blendFunc(m.c.SRC_ALPHA,m.c.ONE_MINUS_SRC_ALPHA)}_setGUI(){this.addGUIParams({texOffsetScale:1,blurPassCount:20,lightScale:1,uAlpha:.5}),this.gui.add(this.params,"texOffsetScale",0,4).step(.02),this.gui.add(this.params,"blurPassCount",1,40).step(1),this.gui.add(this.params,"lightScale",.1,10).step(.1),this.gui.add(this.params,"uAlpha",0,1).step(.1)}uniform(){let e=g.b.identity(g.b.create()),t=g.b.identity(g.b.create());g.b.invert(t,e)}renderScene(){let e=[10,10,10].map(e=>e*this.params.lightScale);this.prg.use(),this.prg.style({"lights[0].Position":[1.5,0,0],"lights[0].Color":e,"lights[1].Position":[-1.5,0,0],"lights[1].Color":e,"lights[2].Position":[0,1.5,-2],"lights[2].Color":e,"lights[3].Position":[0,0,2],"lights[3].Color":[10,20,10],"lights[4].Position":[0,-1.5,0],"lights[4].Color":[100,20,10],baseColor:[0,.3,.3],uAlpha:this.params.uAlpha}),this.statue.rotationY=12,m.a.draw(this.statue)}render(){m.c.bindFramebuffer(m.c.FRAMEBUFFER,this.hdrFbo),m.a.clear(0,0,0),m.c.cullFace(m.c.FRONT),this.renderScene(),m.c.cullFace(m.c.BACK),this.renderScene(),m.c.bindFramebuffer(m.c.FRAMEBUFFER,null),this.blurPrg.use();let e=!0,t=!0,r=this.params.blurPassCount;for(let i=0;i<r;i++)m.c.bindFramebuffer(m.c.FRAMEBUFFER,this.pingpongFBO[Number(e)]),t?this.textures[1].bind():m.c.bindTexture(m.c.TEXTURE_2D,this.pingpongColorbuffers[Number(!e)]),this.blurPrg.uniform("image","uniform1i",0),this.blurPrg.style({horizontal:e,texOffsetScale:this.params.texOffsetScale}),m.a.draw(this.quad),e=!e,t&&(t=!1);m.c.bindFramebuffer(m.c.FRAMEBUFFER,null),m.a.clear(0,0,0),this.finalPrg.use(),this.textures[0].bind(0),m.c.activeTexture(m.c.TEXTURE1),m.c.bindTexture(m.c.TEXTURE_2D,this.pingpongColorbuffers[1]),this.finalPrg.uniform("scene","uniform1i",0),this.finalPrg.uniform("bloomBlur","uniform1i",1),this.finalPrg.style({bloom:!0,exposure:.1}),m.a.draw(this.quad)}}},67:function(e,t){e.exports="#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\n\nout vec3 FragPos;\nout vec3 Normal;\nout vec2 TexCoords;\n\n\nuniform mat4 uProjectionMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uModelMatrix;\n\nvoid main()\n{\n    FragPos = vec3(uModelMatrix * vec4(position, 1.0));   \n    TexCoords = texCoord;\n        \n    mat3 normalMatrix = transpose(inverse(mat3(uModelMatrix)));\n    Normal = normalize(normalMatrix * normal);\n    \n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n}"},68:function(e,t){e.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nlayout (location = 0) out vec4 FragColor;\nlayout (location = 1) out vec4 BrightColor;\n\n\nin  vec3 FragPos;\nin  vec3 Normal;\nin  vec2 TexCoords;\n\n\nstruct Light {\n    vec3 Position;\n    vec3 Color;\n};\n\nuniform Light lights[5];\nuniform vec3 baseColor;\nuniform vec3 uCameraPos;\nuniform float uAlpha;\n\nvoid main()\n{           \n    vec3 normal = normalize(Normal);\n    // ambient\n    vec3 ambient = 0.0 * baseColor;\n    // lighting\n    vec3 lighting = vec3(0.0);\n    vec3 viewDir = normalize(uCameraPos - FragPos);\n    for(int i = 0; i < 5; i++)\n    {\n        // diffuse\n        vec3 lightDir = normalize(lights[i].Position - FragPos);\n        float diff = max(dot(lightDir, normal), 0.0);\n        vec3 result = lights[i].Color * diff * baseColor;      \n        // attenuation (use quadratic as we have gamma correction)\n        float distance = length(FragPos - lights[i].Position);\n        result *= 1.0 / (distance * distance);\n        lighting += result;\n                \n    }\n    vec3 result = ambient + lighting;\n    // check whether result is higher than some threshold, if so, output as bloom threshold color\n    // tranform to grayscale\n    float brightness = dot(result, vec3(0.2126, 0.7152, 0.0722));\n    if(brightness > 1.0)\n        BrightColor = vec4(result, uAlpha);\n    else\n        BrightColor = vec4(0.0, 0.0, 0.0, 1.0);\n    FragColor = vec4(result, uAlpha);\n}\n"},69:function(e,t){e.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec2 TexCoords;\n\nuniform sampler2D image;\n\nuniform bool horizontal;\nuniform float texOffsetScale;\nfloat weight[5] = float[] (0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162);\nout vec4 FragColor;\nfloat lod =3.;\n\nvoid main()\n{             \n    vec2 tex_offset = texOffsetScale * vec2(1.0/ float(textureSize(image, 0).x), 1.0/ float(textureSize(image, 0).y)); // gets size of single texel\n    vec3 result = textureLod(image, TexCoords, lod).rgb * weight[0];\n    if(horizontal)\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n        result += textureLod(image, TexCoords + vec2(tex_offset.x * float(i), 0.0), lod).rgb * weight[i];\n        result += textureLod(image, TexCoords - vec2(tex_offset.x * float(i), 0.0), lod).rgb * weight[i];\n        }\n    }\n    else\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n            result += textureLod(image, TexCoords + vec2(0.0, tex_offset.y * float(i)), lod).rgb * weight[i];\n            result += textureLod(image, TexCoords - vec2(0.0, tex_offset.y * float(i)), lod).rgb * weight[i];\n        }\n    }\n    FragColor = vec4(result, 1.0);\n}"},70:function(e,t){e.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D scene;\nuniform sampler2D bloomBlur;\nuniform bool bloom;\nuniform float exposure;\n\nvoid main()\n{             \n    const float gamma = 2.2;\n    vec3 hdrColor = texture(scene, TexCoords).rgb;      \n    vec3 bloomColor = texture(bloomBlur, TexCoords).rgb;\n    if(bloom)\n        hdrColor += bloomColor; // additive blending\n    // tone mapping\n    vec3 result = vec3(1.0) - exp(-hdrColor * exposure);\n    // also gamma correct while we're at it       \n    result = pow(result, vec3(1.0 / gamma));\n    FragColor = vec4(result, 1.0);\n}"}}]);