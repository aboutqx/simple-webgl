(window.webpackJsonp=window.webpackJsonp||[]).push([[17,22],{142:function(t,e){t.exports="// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nattribute vec3 normal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n    vTextureCoord = texCoord;\n    vNormal = normal;\n}"},143:function(t,e){t.exports="// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"},28:function(t,e,i){"use strict";var r=i(0),a=i(14),s=i(12);i(144);const n=(t,e)=>{if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0},o=t=>{const e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=`${t+1}: ${e[t]}`;return e.join("\n")},c=t=>t.slice?t.slice(0):new Float32Array(t),h=i(142),m=i(143),u={float:"uniform1f",vec2:"uniform2fv",vec3:"uniform3fv",vec4:"uniform4fv",int:"uniform1i",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"};class l{constructor(t=h,e=m,i){this.parameters=[],this._uniformTextures=[],this._varyings=i,t||(t=h),e||(e=h);const r=this._createShaderProgram(t,!0),a=this._createShaderProgram(e,!1);this._attachShaderProgram(r,a)}use(){this.bind()}bind(){r.c.useProgram(this.shaderProgram),r.a.useShader(this)}uniform(t,e,i){if("object"==typeof t)return void this.uniformObject(t);const a=u[e]||e;let s,o=!1,h=-1;for(let e=0;e<this.parameters.length;e++)if((s=this.parameters[e]).name===t){o=!0,h=e;break}let m=!1;if(o?(this.shaderProgram[t]=s.uniformLoc,m=s.isNumber):(m="uniform1i"===a||"uniform1f"===a,this.shaderProgram[t]=r.c.getUniformLocation(this.shaderProgram,t),m?this.parameters.push({name:t,type:a,value:i,uniformLoc:this.shaderProgram[t],isNumber:m}):this.parameters.push({name:t,type:a,value:c(i),uniformLoc:this.shaderProgram[t],isNumber:m}),h=this.parameters.length-1),this.parameters[h].uniformLoc)if(-1===a.indexOf("Matrix"))if(m){(this.parameters[h].value!==i||!o)&&(r.c[a](this.shaderProgram[t],i),this.parameters[h].value=i)}else n(this.parameters[h].value,i)&&o||(r.c[a](this.shaderProgram[t],i),this.parameters[h].value=c(i));else n(this.parameters[h].value,i)&&o||(r.c[a](this.shaderProgram[t],!1,i),this.parameters[h].value=c(i))}style(t){this.uniformObject(t)}uniformObject(t){for(const e in t)if(t[e]instanceof a.a||t[e]instanceof s.a){const i=t[e];let r=-1;this._uniformTextures.forEach((t,a)=>{t.name===e&&(r=a,t.texture=i)}),-1===r&&(r=this._uniformTextures.length,this._uniformTextures.push({name:e,texture:i})),this.uniform(e,"uniform1i",r),i.bind(r)}else{let i=t[e];const r=l.getUniformType(i);if(i.concat&&i[0].concat){let t=[];for(let e=0;e<i.length;e++)t=t.concat(i[e]);i=t}this.uniform(e,r,i)}}_createShaderProgram(t,e){const i=e?r.c.VERTEX_SHADER:r.c.FRAGMENT_SHADER,a=r.c.createShader(i);return r.c.shaderSource(a,t),r.c.compileShader(a),r.c.getShaderParameter(a,r.c.COMPILE_STATUS)?a:(console.warn("Error in Shader : ",r.c.getShaderInfoLog(a)),console.log(o(t)),null)}_attachShaderProgram(t,e){this.shaderProgram=r.c.createProgram(),r.c.attachShader(this.shaderProgram,t),r.c.attachShader(this.shaderProgram,e),r.c.deleteShader(t),r.c.deleteShader(e),this._varyings&&(console.log("Transform feedback setup : ",this._varyings),r.c.transformFeedbackVaryings(this.shaderProgram,this._varyings,r.c.SEPARATE_ATTRIBS)),r.c.linkProgram(this.shaderProgram)}}l.getUniformType=function(t){const e=function(t){return 9===t.length?"uniformMatrix3fv":16===t.length?"uniformMatrix4fv":`vec${t.length}`};return!!t.length?t[0].concat?e(t[0]):e(t):"float"},e.a=l},47:function(t,e,i){"use strict";i.r(e),i.d(e,"default",function(){return p});var r=i(2),a=i(5),s=i(3),n=i(87),o=i.n(n),c=i(88),h=i.n(c),m=i(1),u=i(0);let l=m.b.identity(m.b.create()),d=m.b.identity(m.b.create());const f=t=>{const e=m.e.fromValues(-1,0,-1),i=m.e.fromValues(-1,0,1),r=m.e.fromValues(1,0,1),a=m.e.fromValues(1,0,-1),s=m.d.fromValues(0,1),n=m.d.fromValues(0,0),o=m.d.fromValues(1,0),c=m.d.fromValues(1,1),h=m.e.fromValues(0,1,0),u=m.e.create(),l=m.e.create(),d=m.d.create(),f=m.d.create();m.e.subtract(u,i,e),m.e.subtract(l,r,e),m.d.subtract(d,n,s),m.d.subtract(f,o,s);let g=1/(d[0]*f[1]-f[0]*d[1]);const p=m.e.create(),v=m.e.create(),b=m.e.create(),_=m.e.create();return p[0]=g*(f[1]*u[0]-d[1]*l[0]),p[1]=g*(f[1]*u[1]-d[1]*l[1]),p[2]=g*(f[1]*u[2]-d[1]*l[2]),m.e.normalize(p,p),v[0]=g*(-f[0]*u[0]+d[0]*l[0]),v[1]=g*(-f[0]*u[1]+d[0]*l[1]),v[2]=g*(-f[0]*u[2]+d[0]*l[2]),m.e.normalize(v,v),m.e.subtract(u,r,e),m.e.subtract(l,a,e),m.d.subtract(d,o,s),m.d.subtract(f,c,s),g=1/(d[0]*f[1]-f[0]*d[1]),b[0]=g*(f[1]*u[0]-d[1]*l[0]),b[1]=g*(f[1]*u[1]-d[1]*l[1]),b[2]=g*(f[1]*u[2]-d[1]*l[2]),m.e.normalize(b,b),_[0]=g*(-f[0]*u[0]+d[0]*l[0]),_[1]=g*(-f[0]*u[1]+d[0]*l[1]),_[2]=g*(-f[0]*u[2]+d[0]*l[2]),m.e.normalize(_,_),[e[0],e[1],e[2],h[0],h[1],h[2],s[0],s[1],p[0],p[1],p[2],v[0],v[1],v[2],i[0],i[1],i[2],h[0],h[1],h[2],n[0],n[1],p[0],p[1],p[2],v[0],v[1],v[2],r[0],r[1],r[2],h[0],h[1],h[2],o[0],o[1],p[0],p[1],p[2],v[0],v[1],v[2],e[0],e[1],e[2],h[0],h[1],h[2],s[0],s[1],b[0],b[1],b[2],_[0],_[1],_[2],r[0],r[1],r[2],h[0],h[1],h[2],o[0],o[1],b[0],b[1],b[2],_[0],_[1],_[2],a[0],a[1],a[2],h[0],h[1],h[2],c[0],c[1],b[0],b[1],b[2],_[0],_[1],_[2]]},g=[0,3,0];class p extends a.default{constructor(){super(),Object(r.a)(this,"count",0)}init(){this.prg=this.compile(o.a,h.a)}attrib(){const t=f();this.quad=new s.a,this.quad.bufferFlattenData(t,["position","normal","texCoord","tangent","bitangent"],[3,3,2,3,3])}prepare(){this.camera.offset=[0,2,0],u.c.enable(u.c.DEPTH_TEST),u.c.depthFunc(u.c.LEQUAL),u.c.clearColor(.3,.3,.3,1),u.c.clearDepth(1);const t=getAssets.brickwall,e=getAssets.brickwallNormal;t.bind(0),e.bind(1)}uniform(){l=this.camera.viewMatrix,m.b.perspective(d,Object(u.d)(60),u.b.clientWidth/u.b.clientHeight,.1,100);let t=m.b.identity(m.b.create());m.b.scale(t,t,[1.8,1.8,1.8]),this.prg.use(),this.prg.style({mMatrix:t,vMatrix:l,pMatrix:d,viewPos:this.camera.position,lightPos:g,diffuseMap:0,normalMap:1})}render(){u.c.clear(u.c.COLOR_BUFFER_BIT|u.c.DEPTH_BUFFER_BIT),this.prg.use(),this.quad.bind(),u.a.draw(this.quad)}}},5:function(t,e,i){"use strict";i.r(e);var r=i(2),a=i(28),s=i(1),n=i(0);const o=function(t,e,i){const r=e||{};return t.touches&&!i?(r.x=t.touches[0].pageX,r.y=t.touches[0].pageY):t.touches?t.touches&&i&&(r.x=t.touches[1].pageX,r.y=t.touches[1].pageY):(r.x=t.clientX,r.y=t.clientY),r},c=1e-4;class h{constructor(t=[0,0,0],e=[0,1,0]){Object(r.a)(this,"cameraPos",void 0),Object(r.a)(this,"up",void 0),Object(r.a)(this,"cameraFront",[0,0,-1]),Object(r.a)(this,"_mouse",{}),Object(r.a)(this,"_preMouse",{}),Object(r.a)(this,"_mousedown",!1),Object(r.a)(this,"_rx",0),Object(r.a)(this,"_ry",0),Object(r.a)(this,"_preRx",0),Object(r.a)(this,"_preRy",0),Object(r.a)(this,"_targetRx",0),Object(r.a)(this,"_targetRy",0),Object(r.a)(this,"_viewMatrix",s.b.identity(s.b.create())),Object(r.a)(this,"_width",n.b.width),Object(r.a)(this,"_height",n.b.height),Object(r.a)(this,"sensitivity",1),Object(r.a)(this,"target",[0,0,0]),Object(r.a)(this,"offset",[0,0,0]),Object(r.a)(this,"radius",5),Object(r.a)(this,"_targetRadius",5),Object(r.a)(this,"_updateWheel",!1),this.position=t,this.up=e,this.projMatrix=s.b.create(),s.b.perspective(this.projMatrix,Object(n.d)(45),n.b.clientWidth/n.b.clientHeight,.1,100),this._addEvents()}setProj(t,e,i){s.b.perspective(this.projMatrix,Object(n.d)(t),n.b.clientWidth/n.b.clientHeight,e,i)}_addEvents(){n.b.addEventListener("mousedown",t=>this._down(t)),n.b.addEventListener("mousemove",t=>this._move(t)),document.addEventListener("mouseup",t=>this._up(t)),n.b.addEventListener("mousewheel",t=>this._onWheel(t)),n.b.addEventListener("DOMMouseScroll",t=>this._onWheel(t))}_down(t){this._mousedown=!0,o(t,this._mouse),o(t,this._preMouse),this._preRx=this._targetRx,this._preRy=this._targetRy}_move(t){if(this._mousedown){o(t,this._mouse);let e=(this._mouse.x-this._preMouse.x)/this._width,i=(this._mouse.y-this._preMouse.y)/this._height;this._targetRx=this._preRx+e*Math.PI*2*this.sensitivity,this._targetRy=this._preRy+i*Math.PI*this.sensitivity}}_up(t){this._mousedown=!1}updateMatrix(){this._rx+=.1*(this._targetRx-this._rx),Math.abs(this._targetRx-this._rx)<c&&(this._rx=this._targetRx),this._ry+=.1*(this._targetRy-this._ry),Math.abs(this._targetRy-this._ry)<c&&(this._ry=this._targetRy),this._updateWheel&&(this.radius+=.1*(this._targetRadius-this.radius),Math.abs(this._targetRadius-this.radius)<c&&(this.radius=this._targetRadius)),this.position[1]=Math.sin(this._ry)*this.radius;let t=Math.abs(Math.cos(this._ry)*this.radius);this.position[0]=Math.cos(this._rx+.5*Math.PI)*t,this.position[2]=Math.sin(this._rx+.5*Math.PI)*t,this.position=[this.position[0]+this.offset[0],this.position[1]+this.offset[1],this.position[2]+this.offset[2]],s.b.lookAt(this._viewMatrix,this.position,this.target,this.up)}_onWheel(t){const e=t.wheelDelta,i=t.detail;let r=0;r=i?e?e/i/40*i>0?1:-1:-i/3:e/120,this._targetRadius=this.radius+1*-r,this._targetRadius<=1&&(this._targetRadius=1),this._updateWheel=!0}get viewMatrix(){return this._viewMatrix}set rx(t){this._targetRx=t}}var m=i(43);i.d(e,"default",function(){return u});class u{constructor(){Object(r.a)(this,"rotateQ",s.c.create()),Object(r.a)(this,"mousePos",{x:0,y:0}),Object(r.a)(this,"camera",new h),Object(r.a)(this,"pMatrix",s.b.identity(s.b.create())),Object(r.a)(this,"mvpMatrix",s.b.identity(s.b.create())),Object(r.a)(this,"tmpMatrix",s.b.identity(s.b.create())),Object(r.a)(this,"_params",{}),Object(r.a)(this,"gui",new m.a({width:300})),this.vMatrix=this.camera.viewMatrix,n.a.setCamera(this.camera),this.init(),this.attrib(),this.prepare(),this._setGUI(),this._animate=this.animate.bind(this),n.c.enable(n.c.DEPTH_TEST),n.c.depthFunc(n.c.LEQUAL),n.c.enable(n.c.CULL_FACE)}init(){}compile(t,e){return new a.a(t,e)}attrib(){}uniform(){}prepare(){}animate(){requestAnimationFrame(this._animate),this.camera.updateMatrix(),this.uniform(),this.render()}render(){}play(){this.animate()}_setGUI(){}addGUIParams(t){return Object.assign(this._params,t)}get params(){return this._params}set params(t){throw Error("Params has no setter,please use addGUIParams")}}},87:function(t,e){t.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\nlayout (location = 3) in vec3 tangent;\nlayout (location = 4) in vec3 bitangent;\n\n\nout vec3 FragPos;\nout vec2 TexCoords;\nout vec3 TangentLightPos;\nout vec3 TangentViewPos;\nout vec3 TangentFragPos;\n\n\nuniform mat4 pMatrix;\nuniform mat4 vMatrix;\nuniform mat4 mMatrix;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nvoid main() {\n  FragPos = vec3(mMatrix * vec4(position, 1.));\n  TexCoords = texCoord;\n\n  mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n  vec3 T = normalize(normalMatrix * tangent);\n  vec3 N = normalize(normalMatrix * normal);\n  T = normalize(T - dot(T, N) * N);\n  vec3 B = cross(N, T);\n\n   mat3 TBN = transpose(mat3(T, B, N));\n  TangentLightPos = TBN * lightPos;\n  TangentViewPos  = TBN * viewPos;\n  TangentFragPos  = TBN * FragPos;\n\n  gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"},88:function(t,e){t.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec3 FragPos;\nin vec2 TexCoords;\nin vec3 TangentLightPos;\nin vec3 TangentViewPos;\nin vec3 TangentFragPos;\n\n\nuniform sampler2D diffuseMap;\nuniform sampler2D normalMap;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nvoid main()\n{\n     // obtain normal from normal map in range [0,1]\n    vec3 normal = texture(normalMap, TexCoords).rgb;\n    // transform normal vector to range [-1,1]\n    normal = normalize(normal * 2.0 - 1.0);  // this normal is in tangent space\n\n    // get diffuse color\n    vec3 color = texture(diffuseMap, TexCoords).rgb;\n    // ambient\n    vec3 ambient = 0.1 * color;\n    // diffuse\n    vec3 lightDir = normalize(TangentLightPos - TangentFragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * color;\n    // specular\n    vec3 viewDir = normalize(TangentViewPos - TangentFragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n\n    vec3 specular = vec3(0.2) * spec;\n    FragColor = vec4(ambient + diffuse + specular, 1.0);\n}\n"}}]);