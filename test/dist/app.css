__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PbrFlow; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_pbr_flow_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89);
/* harmony import */ var shaders_pbr_flow_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_flow_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_pbr_flow_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90);
/* harmony import */ var shaders_pbr_flow_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_flow_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_pbr_flow_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(91);
/* harmony import */ var shaders_pbr_flow_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_flow_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_pbr_flow_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(92);
/* harmony import */ var shaders_pbr_flow_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_flow_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(14);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(16);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(17);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(18);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(19);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(20);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(7);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(12);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(libs_vao__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var utils_HDRParser__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(10);
/* harmony import */ var libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(13);






















const nrRows = 7;
const nrColumns = 7;
const spacing = .42;
/* irradianceMap, prefilterMap 用cmftStudio生成

*/

class PbrFlow extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension('OES_texture_float_linear'); // Even WebGL2 requires OES_texture_float_linear

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension("EXT_color_buffer_float"); // // gl.getExtension('OES_texture_half_float')
    // gl.getExtension('OES_texture_half_float_linear')
    // gl.getExtension('EXT_shader_texture_lod')

    this.prg = this.compile(shaders_pbr_flow_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_pbr_flow_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.mapPrg = this.compile(shaders_pbr_flow_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_pbr_flow_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.cubePrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
    this.skyboxPrg = this.compile(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default.a, shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default.a);
    this.brdfPrg = this.compile(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12___default.a, shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      uv
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_16__["Sphere"])(256, 256, .15);
    let sphere = new libs_Mesh__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"]();
    sphere.bufferVertex(pos);
    sphere.bufferIndices(index);
    sphere.bufferNormal(normal);
    sphere.bufferTexCoord(uv);
    this.sphere = sphere;
    let cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"]();
    cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_16__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.cube = cube;
    let planeVertices = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, 3.0, 0.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, -3.0, 1.0, 1.0];
    this.planeBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_14__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(planeVertices));
    this.planeBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.planeBuffer.attrib('texCoord', 2, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.planeVao = new libs_vao__WEBPACK_IMPORTED_MODULE_15___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    this.planeVao.setup(this.cubePrg, [this.planeBuffer]);
    let quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"]();
    let quadData = [-1.0, 1.0, 0.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 0.0, 1.0, 0.0];
    quad.bufferData(quadData, ['position', 'texCoord'], [3, 2]);
    this.quad = quad;
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNPACK_FLIP_Y_WEBGL, true);
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create());
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create());
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create());
    let vpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(90), 1., .1, 100);
    const CAMERA_SETTINGS = [[gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(-1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, 1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, -1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, -1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, 1), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, 0, -1), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].fromValues(0, -1, 0)]];
    let hdrInfo = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.equirectangular);
    console.log('hdrInfo', hdrInfo);
    this.hdrTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.hdrTexture.id);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA32F, hdrInfo.shape[0], hdrInfo.shape[1], 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT, hdrInfo.data);
    this.hdrTexture.clamp(); // cubemap

    let cubemapTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, cubemapTexture);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA32F, 512, 512, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR_MIPMAP_LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    this.cubemapTexture = cubemapTexture;
    this.cubePrg.use();
    this.hdrTexture.bind(0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, 512, 512);
    let captureFrameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createFramebuffer();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, captureFrameBuffer);

    for (let i = 0; i < 6; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].multiply(vpMatrix, pMatrix, vMatrix);
      this.cubePrg.style({
        equirectangularMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.cubemapTexture, 0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
      this.cube.bind(this.cubePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER);

    if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER_COMPLETE) {
      console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null); //brdf lookup texture

    this.brdfLUTTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RG).fromData(512, 512, null, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RG32F);
    this.brdfLUTTexture.bind();
    this.brdfLUTTexture.clamp();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, captureFrameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.brdfLUTTexture.id, 0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, 512, 512);
    this.brdfPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.quad.bind(this.brdfPrg);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TRIANGLE_STRIP);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null);
    let irr_posx = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradiancePosX);
    let irr_negx = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradianceNegX);
    let irr_posy = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradiancePosY);
    let irr_negy = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradianceNegY);
    let irr_posz = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradiancePosZ);
    let irr_negz = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradianceNegZ);
    this.irradianceMap = new libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"]([irr_posx, irr_negx, irr_posy, irr_negy, irr_posz, irr_negz]);
    this.prefilterMap = libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"].parseDDS(getAssets.radiance);
  }

  uniform() {
    this.vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create());
    this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create();
    let eyeDirection = [];
    let camUpDirection = [];
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].transformQuat(eyeDirection, [0.0, 0., 3.], this.rotateQ);
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "d"].transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].lookAt(this.vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].perspective(this.pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].multiply(this.tmpMatrix, this.pMatrix, this.vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearColor(0.3, 0.3, 0.3, 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.eyeDirection,
      lambertDiffuse: this.params.lambertDiffuse
    };

    if (this.params.map === 'none') {
      this.prg.use();
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.irradianceMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE1);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.prefilterMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE2);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.brdfLUTTexture.id);
      this.prg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        albedo: [.5, .0, .0],
        ao: 1.,
        irradianceMap: 0,
        prefilterMap: 1,
        brdfLUT: 2
      }));
      this.sphere.bind(this.prg, ['position', 'normal']);

      for (let row = 0; row < nrRows; row++) {
        this.prg.style({
          metallic: row / nrRows
        });

        for (let col = 0; col < nrColumns; col++) {
          gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].translate(mMatrix, gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create(), [(col - nrColumns / 2) * spacing, (row - nrRows / 2) * spacing, 0.0]); // mat4.translate(mMatrix, mMatrix, [1, 0, 0])

          this.prg.style({
            roughness: clamp(col / nrColumns, 0.05, 1.),
            mMatrix
          });
          this.sphere.draw();
        }
      }
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE5);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.irradianceMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE6);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.prefilterMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE7);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.brdfLUTTexture);
      gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [2, 2, 2]);
      this.mapPrg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        mMatrix: mMatrix,
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4,
        irradianceMap: 5,
        prefilterMap: 6,
        brdfLUT: 7
      }));
      this.sphere.bind(this.mapPrg);
      this.sphere.draw();
    } // this.cubePrg.use()
    // this.hdrTexture.bind(0)
    // this.cubePrg.style({
    //   equirectangularMap: 0,
    //   vpMatrix: this.tmpMatrix,
    //   mMatrix: mMatrix
    // })
    // this.cube.bind(this.cubePrg, ['position', 'texCoord'])
    // this.cube.draw()
    // this.planeVao.bind()
    // this.planeBuffer.drawTriangles()
    // this.planeVao.unbind()


    this.skyboxPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.cubemapTexture);
    this.skyboxPrg.style({
      environmentMap: 0,
      vMatrix: this.vMatrix,
      pMatrix: this.pMatrix,
      mMatrix: gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "a"].create())
    });
    this.cube.bind(this.skyboxPrg, ['position']);
    this.cube.draw(); // brdf out为vec2，设置为vec4时显示正常
    // this.brdfPrg.use()
    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    // this.quad.bind(this.brdfPrg)
    // this.quad.draw(gl.TRIANGLE_STRIP)
  }

}

function clamp(value, min, max) {
  if (min > max) {
    return clamp(value, max, min);
  }

  if (value < min) return min;else if (value > max) return max;else return value;
}/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Mesh; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_3__);




class Mesh {
  constructor(mDrawingType, name, material) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "_buffers", []);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "iBuffer", null);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "_useVao", true);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "name", '');

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "material", null);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "textures", {});

    this.drawingType = mDrawingType;
    this.name = name;

    if (material) {
      this.material = material;

      this._setMaterial();
    }
  }

  bufferVertex(mData) {
    this.bufferData(mData, 'position', 3);
  }

  bufferNormal(mData) {
    this.bufferData(mData, 'normal', 3);
  }

  bufferTexCoord(mData) {
    this.bufferData(mData, 'texCoord', 2);
  }

  bufferColor(mData) {
    this.bufferData(mData, 'color', 4);
  }

  bufferData(mData, mName, mItemSize) {
    // support nName as Array, vertex mData like ( vec3 position + vec2 uvs)
    //flatten data
    let bufferData = [];

    if (mData[0].length) {
      for (let i = 0; i < mData.length; i++) {
        for (let j = 0; j < mData[i].length; j++) {
          bufferData.push(mData[i][j]);
        }
      }
    } else bufferData = mData;

    let buffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_1__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"], new Float32Array(bufferData));

    if (!(mName.constructor === Array)) {
      buffer.attrib(mName, mItemSize, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].FLOAT);

      this._buffers.push({
        name: mName,
        buffer
      });
    } else {
      for (let i = 0; i < mName.length; i++) {
        buffer.attrib(mName[i], mItemSize[i], libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].FLOAT);
      }

      this._buffers.push({
        name: mName.toString(),
        buffer
      });
    }
  }

  bufferIndices(mIndex, isDynamic = false) {
    let drawType = isDynamic ? libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DYNAMIC_DRAW : libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].STATIC_DRAW;
    this.iBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_1__[/* IndexBuffer */ "b"](libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].UNSIGNED_SHORT, new Uint16Array(mIndex), drawType);
  } // 针对多个array buffer，list可以只激活部分attribute


  bind(mProgram, list) {
    //所有data在一个arrybuffer里
    if (this._buffers.length === 1) {
      this._buffers[0].buffer.attribPointer(mProgram, list);
    } else if (!list) {
      for (let i = 0; i < this._buffers.length; i++) {
        this._buffers[i].buffer.attribPointer(mProgram);
      }
    } else {
      for (let i = 0; i < this._buffers.length; i++) {
        for (let j = 0; j < list.length; j++) {
          if (list[j] === this._buffers[i].name) this._buffers[i].buffer.attribPointer(mProgram);
        }
      }
    }

    if (this.iBuffer) this.iBuffer.bind();

    if (this.textures) {
      let diffuseNr = 1;
      let specularNr = 1;
      let normalNr = 1;
      let heightNr = 1;
      let i = 0;

      for (let key in this.textures) {
        libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE0 + i);
        let number = '';

        if (key === 'diffuseMap') {
          number = diffuseNr++ + '';
        } else if (key === 'specularMap') {
          number = specularNr++ + '';
        } else if (key === 'normalMap') {
          number = normalNr++ + '';
        } else if (key === 'heightMap' || key === 'bumpMap') {
          // three.js takes bumpMap as heightMap
          number = heightNr++ + '';
        }

        let tmp = {};
        tmp[key + number] = i;
        mProgram.style(tmp);
        libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_2D, this.textures[key]);
        i++;
      }
    }
  }

  draw(mDrawingType) {
    let t;

    if (!this.iBuffer) {
      t = this._buffers[0].buffer;
    } else {
      t = this.iBuffer;
    }

    if (this.drawingType) mDrawingType = this.drawingType;

    if (!mDrawingType) {
      t.drawTriangles();
    } else {
      t.draw(mDrawingType);
    }
  }

  _setMaterial() {
    for (let key in this.material) {
      if (this.material[key].constructor === HTMLImageElement) {
        this.material[key] = new libs_glTexture__WEBPACK_IMPORTED_MODULE_3___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"]).fromImage(this.material[key]).id;
        this.textures[key] = this.material[key];
      }
    }
  }

  get vertexBuffer() {
    let i = has(this._buffers, 'name', 'position');

    if (i === -1) {
      console.warn('no vertex buffer set');
    } else {
      return this._buffers[i].buffer;
    }
  }

}

function has(arr, key, value) {
  // array child object has key-value
  if (!arr || !arr.length) return -1;

  for (let i = 0; i < arr.length; i++) {
    if (arr[i][key] === value) return i;
  }

  return -1;
}/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return IndexBuffer; });
var BufferUtils = {
  getComponentSize: function (type) {
    switch (type) {
      case 0x1400: // gl.BYTE:

      case 0x1401:
        // gl.UNSIGNED_BYTE:
        return 1;

      case 0x1402: // gl.SHORT:

      case 0x1403:
        // gl.UNSIGNED_SHORT:
        return 2;

      case 0x1404: // gl.INT:

      case 0x1405: // gl.UNSIGNED_INT:

      case 0x1406:
        // gl.FLOAT:
        return 4;

      default:
        return 0;
    }
  },
  Drawable: function (proto) {
    proto.drawPoints = function (count, offset) {
      this.draw(0
      /* POINTS         */
      , count, offset);
    };

    proto.drawLines = function (count, offset) {
      this.draw(1
      /* LINES          */
      , count, offset);
    };

    proto.drawLineLoop = function (count, offset) {
      this.draw(2
      /* LINE_LOOP      */
      , count, offset);
    };

    proto.drawLineStrip = function (count, offset) {
      this.draw(3
      /* LINE_STRIP     */
      , count, offset);
    };

    proto.drawTriangles = function (count, offset) {
      this.draw(4
      /* TRIANGLES      */
      , count, offset);
    };

    proto.drawTriangleStrip = function (count, offset) {
      this.draw(5
      /* TRIANGLE_STRIP */
      , count, offset);
    };

    proto.drawTriangleFan = function (count, offset) {
      this.draw(6
      /* TRIANGLE_FAN   */
      , count, offset);
    };
  }
  /*
   * GL_ARRAY_BUFFER */

};
var TGT = 0x8892;
/**
 * @class
 * @implements {Drawable}
 * @param {WebGLRenderingContext} gl      then webgl context this ArrayBuffer belongs to
 * @param {TypedArray|uint} [data]   optional data to copy to buffer, or the size (in bytes)
 * @param {GLenum} [usage=GL_STATIC_DRAW] the usage hint for this buffer.
 *
 */

function ArrayBuffer(gl, data, usage) {
  this.gl = gl;
  this.usage = usage || gl.STATIC_DRAW;
  this.buffer = gl.createBuffer();
  this.attribs = [];
  this.stride = 0;
  this.byteLength = 0;
  this.length = 0;

  if (data) {
    this.data(data);
  }
}

ArrayBuffer.prototype = {
  /**
   * Bind the underlying webgl buffer.
   */
  bind: function () {
    this.gl.bindBuffer(TGT, this.buffer);
  },

  /**
   * Add attribute declaration for this buffer. Once attributes declared, the buffer can be linked to
   * programs attributes using {@link ArrayBuffer#attribPointer}
   *  @param {string} name the name of the program's attribute
   *  @param {uint} size the size of the attribute (3 for a vec3)
   *  @param {GLenum} type the type of data (GL_FLOAT, GL_SHORT etc)
   *  @param {boolean} [normalize=false] indicate if the data must be normalized
   */
  attrib: function (name, size, type, normalize) {
    this.attribs.push({
      name: name,
      type: 0 | type,
      size: 0 | size,
      normalize: !!normalize,
      offset: this.stride
    }); // use only one buffer for multiple attributes

    this.stride += BufferUtils.getComponentSize(type) * size;

    this._computeLength();

    return this;
  },

  /**
   * Fill webgl buffer with the given data. You can also pass a uint  to allocate the buffer to the given size.
   *   @param {TypedArray|uint} array the data to send to the buffer, or a size.
   */
  data: function (array) {
    var gl = this.gl;
    gl.bindBuffer(TGT, this.buffer);
    gl.bufferData(TGT, array, this.usage);
    gl.bindBuffer(TGT, null);
    this.byteLength = array.byteLength === undefined ? array : array.byteLength;

    this._computeLength();
  },

  /**
   * Set a part of the buffer with the given data, starting a offset (in bytes)
   *  @param {typedArray} array the data to send to buffer
   *  @param {uint} offset the offset in byte where the data will be written
   */
  subData: function (array, offset) {
    var gl = this.gl;
    gl.bindBuffer(TGT, this.buffer);
    gl.bufferSubData(TGT, offset, array);
    gl.bindBuffer(TGT, null);
  },

  /**
   * Link given program attributes to this buffer. You should first declare attributes using {@link ArrayBuffer#attrib}
   * before calling this method.
   *   @param {Program} program the nanogl Program
   */
  attribPointer: function (program, list) {
    var gl = this.gl;
    gl.bindBuffer(TGT, this.buffer);

    if (list && list.length) {
      for (let i = 0; i < list.length; i++) {
        for (var j = 0; j < this.attribs.length; j++) {
          let attrib = this.attribs[j];

          if (list[i] === attrib.name) {
            if (program[attrib.name] !== undefined) {
              let aLocation = program[attrib.name]();
              gl.enableVertexAttribArray(aLocation);
              gl.vertexAttribPointer(aLocation, attrib.size, attrib.type, attrib.normalize, this.stride, attrib.offset);
            } else {
              console.warn(`glBuffer can't get Attribute "${attrib.name}" Location.`);
            }
          }
        }
      }

      return;
    }

    for (var i = 0; i < this.attribs.length; i++) {
      var attrib = this.attribs[i];

      if (program[attrib.name] !== undefined) {
        var aLocation = program[attrib.name]();
        gl.enableVertexAttribArray(aLocation);
        gl.vertexAttribPointer(aLocation, attrib.size, attrib.type, attrib.normalize, this.stride, attrib.offset);
      } else {
        console.warn(`glBuffer can't get Attribute "${attrib.name}" Location.`);
      }
    }
  },

  /**
   * Shortcut to gl.drawArrays
   *   @param {GLenum} mode the type of primitive to draw (GL_TRIANGLE, GL_POINTS etc)
   *   @param {uint} [count] the number of vertices to draw (full buffer is used if omited)
   *   @param {uint} [offset=0] the position of the first vertex to draw
   */
  draw: function (mode, count, offset) {
    count = count === undefined ? this.length : count;
    this.gl.drawArrays(mode, offset, 0 | count);
  },

  /**
   * Delete underlying webgl objects
   */
  dispose: function () {
    this.gl && this.gl.deleteBuffer(this.buffer);
    this.buffer = null;
    this.gl = null;
  },
  _computeLength: function () {
    if (this.stride > 0) {
      this.length = this.byteLength / this.stride;
    }
  }
  /*
   * Implement Drawable
   */

};
BufferUtils.Drawable(ArrayBuffer.prototype);
/* GL_ELEMENT_ARRAY_BUFFER 34963 */

var ELEMENT_ARRAY_BUFFER = 0x8893;
/**
 * @class
 * @implements {Drawable}
 * @param {WebGLRenderingContext} gl      then webgl context this ArrayBuffer belongs to
 * @param {GLenum} [type=GL_UNSIGNED_SHORT]  the inetger type of the indices (GL_UNSIGNED_BYTE, GL_UNSIGNED_INT etc)
 * @param {TypedArray|uint} [data]   optional data to copy to buffer, or the size (in bytes)
 * @param {GLenum} [usage=GL_STATIC_DRAW] the usage hint for this buffer.
 *
 */

function IndexBuffer(gl, type, data, usage) {
  this.gl = gl;
  this.buffer = gl.createBuffer();
  this.usage = usage || gl.STATIC_DRAW;
  this.type = 0;
  this.typeSize = 0;
  this.size = 0;
  this.setType(type || gl.UNSIGNED_SHORT);

  if (data) {
    this.data(data);
  }
}

IndexBuffer.prototype = {
  /**
   * Bind the underlying webgl buffer.
   */
  bind: function () {
    this.gl.bindBuffer(ELEMENT_ARRAY_BUFFER, this.buffer);
  },

  /**
   *  Change the type of internal type of the IndexBuffer
   *  @param {GLenum} type  the integer type of the indices (GL_UNSIGNED_BYTE, GL_UNSIGNED_INT etc)
   */
  setType: function (type) {
    this.type = type;
    this.typeSize = BufferUtils.getComponentSize(type);
  },

  /**
   * Fill webgl buffer with the given data. You can also pass a uint  to allocate the buffer to the given size.
   *   @param {TypedArray|uint} array the data to send to the buffer, or a size.
   */
  data: function (array) {
    var gl = this.gl;
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, this.buffer);
    gl.bufferData(ELEMENT_ARRAY_BUFFER, array, this.usage);
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, null);
    this.size = array.byteLength === undefined ? array : array.byteLength;
  },

  /**
   * Set a part of the buffer with the given data, starting a offset (in bytes)
   *  @param {typedArray} array the data to send to buffer
   *  @param {uint} offset the offset in byte where the data will be written
   */
  subData: function (array, offset) {
    var gl = this.gl;
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, this.buffer);
    gl.bufferSubData(ELEMENT_ARRAY_BUFFER, offset, array);
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, null);
  },

  /**
   * Delete underlying webgl objects
   */
  dispose: function () {
    this.gl.deleteBuffer(this.buffer);
    this.buffer = null;
    this.gl = null;
  },

  /**
   * Shortcut to gl.drawArrays
   *   @param {GLenum} mode the type of primitive to draw (GL_TRIANGLE, GL_POINTS etc)
   *   @param {uint} [count] the number of indices to draw (full buffer is used if omited)
   *   @param {uint} [offset=0] the position of the first index to draw
   */
  draw: function (mode, count, offset) {
    count = count === undefined ? this.size / this.typeSize : count;
    this.gl.drawElements(mode, count, this.type, 0 | offset);
  }
  /*
   * Implement Drawable
   */

};
BufferUtils.Drawable(IndexBuffer.prototype);
var _UID = 0;
var T2D = 0x0DE1;
/*
 * compute filtering enum, return one of the following :
 *  NEAREST
 *  LINEAR
 *  NEAREST_MIPMAP_NEAREST
 *  LINEAR_MIPMAP_NEAREST
 *  NEAREST_MIPMAP_LINEAR
 *  LINEAR_MIPMAP_LINEAR
 */

function getFilter(smooth, mipmap, miplinear) {
  return 0x2600 | +smooth | +mipmap << 8 | +(mipmap && miplinear) << 1;
}
/**
 * @class
 * @classdesc Texture class manage TEXTURE_2D types textures
 *
 *  @param {WebGLRenderingContext} gl webgl context the texture belongs to
 *  @param {GLenum} [format=GL_RGB] the pixel format, default to gl.RGB (can be gl.RGB, gl.RGBA, gl.LUMINANCE...)
 */


function Texture(gl, format) {
  this._uid = _UID++;
  this.gl = gl;
  this.id = this.gl.createTexture();
  this.width = 0;
  this.height = 0;
  this.format = format || gl.RGB;
  this.type = gl.UNSIGNED_BYTE;
  this.img = null;
  gl.bindTexture(T2D, this.id);
  this.setFilter(true);
  return this;
}

Texture.prototype = {
  /**
   * set texture data from html source
   *   @param {TexImageSource} img the source. Can be ImageBitmap, ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement
   */
  fromImage: function (img) {
    var gl = this.gl;
    this.img = img;
    this.width = img.width;
    this.height = img.height;
    gl.bindTexture(T2D, this.id);
    gl.texImage2D(T2D, 0, this.format, this.format, this.type, img);
    return this;
  },

  /**
   * Allocate texture to the given size, with optional data (TypedArray) and data type
   *  @param {number} width     the new texture's width
   *  @param {number} height    the new texture's height
   *  @param {TypedArray} [data=null]  TypedArray of texture data, can be null
   *  @param {GLenum} [dataType=GL_UNSIGNED_BYTE] can be gl.UNSIGNED_BYTE, gl.FLOAT, half.HALF_FLOAT_OES etc depending on available extensions
   */
  fromData: function (width, height, data, dataType) {
    var gl = this.gl;
    this.width = width;
    this.height = height;
    data = data || null;
    this.type = dataType || gl.UNSIGNED_BYTE;
    gl.bindTexture(T2D, this.id);

    if (window.useWebgl2) {
      // type = gl.RGBA16F etc..
      if (dataType === gl.RGBA16F) gl.texImage2D(gl.TEXTURE_2D, 0, this.type, width, height, 0, this.format, gl.HALF_FLOAT, data);else if (dataType === gl.RG32F || dataType === gl.RGBA32F || dataType === gl.RGB32F) gl.texImage2D(gl.TEXTURE_2D, 0, this.type, width, height, 0, this.format, gl.FLOAT, data);else gl.texImage2D(T2D, 0, this.format, width, height, 0, this.format, this.type, data);
    } else gl.texImage2D(T2D, 0, this.format, width, height, 0, this.format, this.type, data);

    return this;
  },

  /**
   * Bind the texture
   *   @param {uint} [unit=undefined] optional texture unit to make active before binding
   */
  bind: function (unit) {
    var gl = this.gl;

    if (unit !== undefined) {
      gl.activeTexture(gl.TEXTURE0 + (0 | unit));
    }

    gl.bindTexture(T2D, this.id);
  },

  /**
   * delete the webgl texture
   *
   */
  dispose: function () {
    this.gl && this.gl.deleteTexture(this.id);
    this.id = null;
    this.gl = null;
  },

  /**
   * Change the filtering parameters
   *   @param {boolean} [smooth=false]    if true, use LINEAR filtering
   *   @param {boolean} [mipmap=false]    if true, enable mipmaping
   *   @param {boolean} [miplinear=false] if true, use linear Mipmapping
   */
  setFilter: function (smooth, mipmap, miplinear) {
    var gl = this.gl;
    var filter = getFilter(!!smooth, !!mipmap, !!miplinear);
    gl.texParameteri(T2D, gl.TEXTURE_MAG_FILTER, getFilter(!!smooth, false, false));
    gl.texParameteri(T2D, gl.TEXTURE_MIN_FILTER, filter);
  },

  /**
   * Set both WRAP_S and WRAP_T property to gl.REPEAT
   */
  repeat: function () {
    this.wrap(this.gl.REPEAT);
  },

  /**
   * Set both WRAP_S and WRAP_T property to gl.CLAMP_TO_EDGE
   */
  clamp: function () {
    this.wrap(this.gl.CLAMP_TO_EDGE);
  },

  /**
   * Set both WRAP_S and WRAP_T property to gl.MIRRORED_REPEAT
   */
  mirror: function () {
    this.wrap(this.gl.MIRRORED_REPEAT);
  },

  /**
   * Set both WRAP_S and WRAP_T property to the given value
   *  @param {GLenum} wrap the wrap enum
   */
  wrap: function (wrap) {
    var gl = this.gl;
    gl.texParameteri(T2D, gl.TEXTURE_WRAP_S, wrap);
    gl.texParameteri(T2D, gl.TEXTURE_WRAP_T, wrap);
  }
};
module.exports = Texture;__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Color; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_color_colors_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60);
/* harmony import */ var shaders_color_colors_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_color_colors_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_color_lamp_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(61);
/* harmony import */ var shaders_color_lamp_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_color_lamp_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);








let vMatrix;
let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create());
const lightColor = [0.33, 0.42, 0.18];
class Color extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_color_colors_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
    this.lampPrg = this.compile(shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_color_lamp_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
  }

  attrib() {
    let CubeData = [0.5, -0.5, -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, -0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, -0.5];
    let cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]();
    cube.bufferData(CubeData, ['position'], [3]);
    this.cube = cube;
    this.lampVao = libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].createVertexArray();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].bindVertexArray(this.lampVao);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].bindBuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].ARRAY_BUFFER, this.cube._buffers[0].buffer.buffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].vertexAttribPointer(0, 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].FLOAT, false, 3 * 4, 0); // float size is 4

    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].enableVertexAttribArray(0);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].clearDepth(1.0);
    this.camera.radius = 3;
  }

  uniform() {
    // let eyeDirection = []
    // let camUpDirection = []
    // vec3.transformQuat(eyeDirection, [0.0, 0.0, 3.0], this.rotateQ)
    // vec3.transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ)
    // this.eyeDirection = eyeDirection
    // mat4.lookAt(vMatrix, [0.0, 0.0, 3.0], [0, 0, 0], [0.0, 1.0, 0.0])
    vMatrix = this.camera.viewMatrix; // console.log( vMatrix)

    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* toRadian */ "e"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* canvas */ "a"].clientHeight, .1, 100);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create());
    this.prg.use();
    this.prg.style({
      mMatrix,
      vMatrix,
      pMatrix,
      objectColor: [1., .5, .31],
      lightColor
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.cube.bind(this.prg, ['position']);
    this.cube.draw();
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].translate(mMatrix, mMatrix, [1, .1, 1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [.2, .2, .2]);
    this.lampPrg.use();
    this.lampPrg.style({
      mMatrix,
      vMatrix,
      pMatrix,
      lightColor
    });
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].bindVertexArray(this.lampVao);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].drawArrays(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].TRIANGLES, 0, 36);
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nuniform vec3 objectColor;\nuniform vec3 lightColor;\n\nvoid main()\n{\n    FragColor = vec4(lightColor * objectColor, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\nuniform vec3 lightColor;\nvoid main()\n{\n    FragColor = vec4(lightColor, 1.0); // 将向量的四个分量全部设置为1.0\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LightCaster; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_light_caster_directionalLight_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62);
/* harmony import */ var shaders_light_caster_directionalLight_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_directionalLight_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_light_caster_pointLight_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(63);
/* harmony import */ var shaders_light_caster_pointLight_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_pointLight_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_light_caster_spotLight_frag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(64);
/* harmony import */ var shaders_light_caster_spotLight_frag__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_spotLight_frag__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_light_caster_lamp_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(65);
/* harmony import */ var shaders_light_caster_lamp_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_lamp_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_light_caster_lamp_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(66);
/* harmony import */ var shaders_light_caster_lamp_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_lamp_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(0);












let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
const lightColor = [0.33, 0.42, 0.18];
const ligthPos = [0.2, -1.0, -0.3].map(v => v * 50);
const cubePosition = [[0.0, 0.0, 0.0], [2.0, 5.0, -15.0], [-1.5, -2.2, -2.5], [-3.8, -2.0, -12.3], [2.4, -0.4, -3.5], [-1.7, 3.0, -7.5], [1.3, -2.0, -2.5], [1.5, 2.0, -2.5], [1.5, 0.2, -1.5], [-1.3, 1.0, -1.5]];
class LightCaster extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_light_caster_directionalLight_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
    this.pointPrg = this.compile(shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_light_caster_pointLight_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.spotPrg = this.compile(shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_light_caster_spotLight_frag__WEBPACK_IMPORTED_MODULE_6___default.a);
    this.lampPrg = this.compile(shaders_light_caster_lamp_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_light_caster_lamp_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
  }

  attrib() {
    let CubeData = [// positions          // normals           // texture coords
    -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0, 0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 0.0, 0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0, 0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0, -0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 1.0, -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0, -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0, 0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0, 0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0, -0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0, -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0, -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0, -0.5, 0.5, -0.5, -1.0, 0.0, 0.0, 1.0, 1.0, -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0, -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0, -0.5, -0.5, 0.5, -1.0, 0.0, 0.0, 0.0, 0.0, -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, -0.5, 1.0, 0.0, 0.0, 1.0, 1.0, 0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0, 0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0, 0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0, -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0, 0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 1.0, 1.0, 0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0, 0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0, -0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0, -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0, 0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0, -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0];
    let cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]();
    cube.bufferData(CubeData, ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.cube = cube;
    this.lampVao = libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].createVertexArray();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].bindVertexArray(this.lampVao);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].bindBuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].ARRAY_BUFFER, this.cube._buffers[0].buffer.buffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].vertexAttribPointer(0, 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].FLOAT, false, 8 * 4, 0); // float size is 4

    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].enableVertexAttribArray(0);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].clearDepth(1.0);
    this.diffuseTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].RGBA).fromImage(getAssets.cubeDiffuse);
    this.specularTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].RGBA).fromImage(getAssets.cubeSpecular);
    this.emissionTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].RGBA).fromImage(getAssets.cubeEmission);
    this.camera.radius = 6;
  }

  _setGUI() {
    this.addGUIParams({
      directionalLight: true,
      pointLight: false,
      spotLight: false
    });
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'directionalLight').listen().onChange(() => {
      this.setChecked('directionalLight');
    });
    folder1.add(this.params, 'pointLight').listen().onChange(() => {
      this.setChecked('pointLight');
    });
    folder1.add(this.params, 'spotLight').listen().onChange(() => {
      this.setChecked('spotLight');
    });
    folder1.open();
  }

  setChecked(prop) {
    this.params.directionalLight = false;
    this.params.pointLight = false;
    this.params.spotLight = false;
    this.params[prop] = true;
  }

  uniform() {
    vMatrix = this.camera.viewMatrix;
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "e"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* canvas */ "a"].clientHeight, .1, 100);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.diffuseTexture.bind(0);
    this.specularTexture.bind(1);
    this.emissionTexture.bind(2);

    if (this.params.directionalLight) {
      this.prg.use();
      this.cube.bind(this.prg);
      this.prg.style({
        vMatrix,
        pMatrix,
        camPos: this.camera.cameraPos,
        'material.shininess': 30,
        'material.diffuse': 0,
        'material.specular': 1,
        'material.emission': 2,
        'light.ambient': [.2, .2, .2],
        'light.diffuse': [.5, .5, .5],
        'light.specular': [1., 1., 1.],
        // specular 还和视角有关
        'light.direction': [-ligthPos[0], -ligthPos[1], -ligthPos[2]] //光源方向为从光源出发，因此是坐标向量取负

      });
      cubePosition.map((position, i) => {
        let cubemMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create(); // mat4.scale(cubemMatrix, cubemMatrix, [.5, .5, .5])

        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].rotate(cubemMatrix, cubemMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "e"])(20 * i), ligthPos);
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].translate(cubemMatrix, cubemMatrix, position);
        this.prg.style({
          mMatrix: cubemMatrix
        });
        this.cube.draw();
      });
    } else if (this.params.pointLight) {
      this.pointPrg.use();
      this.cube.bind(this.pointPrg);
      this.pointPrg.style({
        vMatrix,
        pMatrix,
        camPos: this.camera.cameraPos,
        'material.shininess': 30,
        'material.diffuse': 0,
        'material.specular': 1,
        'material.emission': 2,
        'light.ambient': [.2, .2, .2],
        'light.diffuse': [.5, .5, .5],
        'light.specular': [1., 1., 1.],
        'light.position': [0, 0, 1],
        //衰减系数
        'light.constant': 1,
        'light.linear': .09,
        'light.quadratic': .032
      });
      cubePosition.map((position, i) => {
        let cubemMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].rotate(cubemMatrix, cubemMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "e"])(20 * i), ligthPos);
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].translate(cubemMatrix, cubemMatrix, position);
        this.pointPrg.style({
          mMatrix: cubemMatrix
        });
        this.cube.draw();
      });
    } else if (this.params.spotLight) {
      this.spotPrg.use();
      this.cube.bind(this.spotPrg);
      this.spotPrg.style({
        vMatrix,
        pMatrix,
        camPos: this.camera.cameraPos,
        'material.shininess': 30,
        'material.diffuse': 0,
        'material.specular': 1,
        'material.emission': 2,
        'light.ambient': [.1, .1, .1],
        'light.diffuse': [.5, .5, .5],
        'light.specular': [1., 1., 1.],
        'light.position': this.camera.cameraPos,
        'light.direction': [-this.camera.cameraPos[0], -this.camera.cameraPos[1], -this.camera.cameraPos[2]],
        'light.cutOff': Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "e"])(12.5)
      });
      cubePosition.map((position, i) => {
        let cubemMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].rotate(cubemMatrix, cubemMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "e"])(20 * i), ligthPos);
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].translate(cubemMatrix, cubemMatrix, position);
        this.spotPrg.style({
          mMatrix: cubemMatrix
        });
        this.cube.draw();
      });
    }

    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [.05, .05, .05]); //先缩放再位移，防止先位移缩放改变了位移值

    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].translate(mMatrix, mMatrix, ligthPos);
    this.lampPrg.use();
    this.lampPrg.style({
      mMatrix,
      vMatrix,
      pMatrix,
      lightColor
    });
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].bindVertexArray(this.lampVao);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].drawArrays(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "d"].TRIANGLES, 0, 36);
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec2 TexCoords;\nout vec3 Normal;\nout vec3 FragPos;\n\nvoid main()\n{\n    FragPos = vec3(mMatrix * vec4(position, 1.0));\n    Normal = mat3(transpose(inverse(mMatrix))) * normal;\n    TexCoords = texCoord;\n\n    gl_Position = pMatrix * vMatrix * vec4(FragPos, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    sampler2D emission;\n    float shininess;\n};\nstruct Light {\n    // vec3 position; // directional light only has direction\n    vec3 direction;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\n\nvoid main()\n{\n  // ambient\n  vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\n\n  // diffuse\n  vec3 norm = normalize(Normal);\n  // vec3 lightDir = normalize(light.position - FragPos);\n  vec3 lightDir = normalize(-light.direction);\n  float diff = max(dot(norm, lightDir), 0.0);\n   vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\n\n  // specular\n  vec3 viewDir = normalize(camPos - FragPos);\n  vec3 reflectDir = reflect(-lightDir, norm);\n  float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n  vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\n\n  vec3 emission = vec3(0.);//texture(material.emission, TexCoords).rgb;\n\n  vec3 result = ambient + diffuse + specular + emission;\n  FragColor = vec4(result, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    float shininess;\n};\n\nstruct Light {\n    vec3 position;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\n    float constant;\n    float linear;\n    float quadratic;\n};\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\nvoid main()\n{\n    // ambient\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\n\n    // diffuse\n    vec3 norm = normalize(Normal);\n    vec3 lightDir = normalize(light.position - FragPos);\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\n\n    // specular\n    vec3 viewDir = normalize(camPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\n\n    // attenuation\n    float distance    = length(light.position - FragPos);\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n\n    ambient  *= attenuation;\n    diffuse   *= attenuation;\n    specular *= attenuation;\n\n    vec3 result = ambient + diffuse + specular;\n    FragColor = vec4(result, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    float shininess;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 direction;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\n    float cutOff;\n};\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\nvoid main()\n{\n  vec3 result;\n  vec3 lightDir = normalize(light.position - FragPos);\n  float theta = dot(lightDir, normalize(-light.direction));\n  if(theta > light.cutOff)\n  {\n    // ambient\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\n\n    // diffuse\n    vec3 norm = normalize(Normal);\n\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\n\n    // specular\n    vec3 viewDir = normalize(camPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\n\n    result = ambient + diffuse + specular;\n  }\n  else {\n    // 否则，使用环境光，让场景在聚光之外时不至于完全黑暗\n    result = light.ambient * vec3(texture(material.diffuse, TexCoords));\n  }\n\n  FragColor = vec4(result, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\n\nvoid main() {\n  FragColor = vec4(1.0);\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Color; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var shaders_material_material_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(67);
/* harmony import */ var shaders_material_material_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_material_material_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_material_material_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68);
/* harmony import */ var shaders_material_material_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_material_material_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);
/* harmony import */ var shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(25);
/* harmony import */ var shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(0);









let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].create());
let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].create());
const lightColor = [0.33, 0.42, 0.18];
const ligthPos = [1, .1, 1.5];
class Color extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_material_material_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_material_material_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
    this.lampPrg = this.compile(shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
  }

  attrib() {
    let CubeData = [-0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 0.5, 0.5, -0.5, 0.0, 0.0, -1.0, -0.5, 0.5, -0.5, 0.0, 0.0, -1.0, -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 0.5, 0.5, 0.5, 0.0, 0.0, 1.0, -0.5, 0.5, 0.5, 0.0, 0.0, 1.0, -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, -0.5, 0.5, -0.5, -1.0, 0.0, 0.0, -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, -0.5, -0.5, 0.5, -1.0, 0.0, 0.0, -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 0.5, 0.5, -0.5, 1.0, 0.0, 0.0, 0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.5, 0.5, 0.5, 1.0, 0.0, 0.0, -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 0.5, -0.5, 0.5, 0.0, -1.0, 0.0, -0.5, -0.5, 0.5, 0.0, -1.0, 0.0, -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 1.0, 0.0, -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, -0.5, 0.5, -0.5, 0.0, 1.0, 0.0];
    let cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]();
    cube.bufferData(CubeData, ['position', 'normal'], [3, 3]);
    this.cube = cube;
    this.lampVao = libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].createVertexArray();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].bindVertexArray(this.lampVao);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].bindBuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].ARRAY_BUFFER, this.cube._buffers[0].buffer.buffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].vertexAttribPointer(0, 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].FLOAT, false, 6 * 4, 0); // float size is 4,设置为6，虽然后面3位texCoord没用，但不会报错

    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].enableVertexAttribArray(0);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].clearDepth(1.0);
  }

  uniform() {
    let eyeDirection = [];
    let camUpDirection = [];
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* vec3 */ "d"].transformQuat(eyeDirection, [0.0, 0.0, 3.0], this.rotateQ);
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* vec3 */ "d"].transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].lookAt(vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* toRadian */ "e"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* canvas */ "a"].clientHeight, .1, 100);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].create());
    this.prg.use();
    this.prg.style({
      mMatrix,
      vMatrix,
      pMatrix,
      camPos: eyeDirection,
      'light.position': ligthPos,
      'material.ambient': [1, .5, .31],
      'material.diffuse': [1, .5, .31],
      'material.specular': [.5, .5, .5],
      'material.shininess': 50,
      'light.ambient': [.2, .2, .2],
      'light.diffuse': [.5, .5, .5],
      'light.specular': [1., 1., 1.]
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.cube.bind(this.prg, ['position', 'normal']);
    this.cube.draw();
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].translate(mMatrix, mMatrix, ligthPos);
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [.2, .2, .2]);
    this.lampPrg.use();
    this.lampPrg.style({
      mMatrix,
      vMatrix,
      pMatrix,
      lightColor
    });
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].bindVertexArray(this.lampVao);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].drawArrays(libs_GlTools__WEBPACK_IMPORTED_MODULE_8__[/* gl */ "d"].TRIANGLES, 0, 36);
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec3 Normal;\nout vec3 FragPos;\nvoid main()\n{\n  Normal = mat3(transpose(inverse(mMatrix))) * normal; // 法线矩阵 修复不等比缩放\n  FragPos = vec3(mMatrix * vec4(position, 1.0));\n  gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\nstruct Light {\n    vec3 position;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\nin vec3 FragPos;\nin vec3 Normal;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\n\nvoid main()\n{\n  // ambient\n  vec3 ambient = light.ambient * material.ambient;\n\n  // diffuse\n  vec3 norm = normalize(Normal);\n  vec3 lightDir = normalize(light.position - FragPos);\n  float diff = max(dot(norm, lightDir), 0.0);\n  vec3 diffuse = light.diffuse * (diff * material.diffuse);\n\n  // specular\n  vec3 viewDir = normalize(camPos - FragPos);\n  vec3 reflectDir = reflect(-lightDir, norm);\n  float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n  vec3 specular = light.specular * (spec * material.specular);\n\n  vec3 result = ambient + diffuse + specular;\n  FragColor = vec4(result, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\nuniform vec3 lightColor;\nvoid main()\n{\n    FragColor = vec4(lightColor, 1.0); \n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Reflection; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var shaders_reflection_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(69);
/* harmony import */ var shaders_reflection_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_reflection_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_reflection_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70);
/* harmony import */ var shaders_reflection_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_reflection_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);








class Reflection extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_reflection_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_reflection_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      color
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_5__["Torus"])(32, 32, .5, 2.0);
    this.posBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"], new Float32Array(pos));
    this.normalBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"], new Float32Array(normal));
    this.colorBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"], new Float32Array(color));
    this.prg.use();
    this.posBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].FLOAT);
    this.posBuffer.attribPointer(this.prg);
    this.normalBuffer.attrib('normal', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].FLOAT);
    this.normalBuffer.attribPointer(this.prg);
    this.colorBuffer.attrib('color', 4, libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].FLOAT);
    this.colorBuffer.attribPointer(this.prg);
    this.indexBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* IndexBuffer */ "b"](libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].UNSIGNED_SHORT, new Uint16Array(index), libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].STATIC_DRAW);
  }

  prepare() {}

  uniform() {
    let vMatrix = this.camera.viewMatrix;
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create());
    this.mvpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* toRadian */ "e"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* canvas */ "a"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].multiply(this.tmpMatrix, pMatrix, vMatrix);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create()); // this.count++

    let rad = this.count % 360 * Math.PI / 180;
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].rotate(mMatrix, mMatrix, 1 * 2 * Math.PI / 9, [0, 1, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].translate(mMatrix, mMatrix, [0.0, 0.0, -10.0]); // mat4.rotate(mMatrix, mMatrix, rad, [0, 1, 1])

    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
    let invMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].invert(invMatrix, mMatrix);
    this.prg.use();
    this.prg.style({
      mvpMatrix: this.mvpMatrix,
      invMatrix,
      lightDirection: [-0.5, 0.5, 0.5],
      eyeDirection: [0.0, 0.0, 20.0],
      ambientColor: [0.1, 0.1, 0.1, 1.0]
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].CULL_FACE);
    this.prg.use();
    this.indexBuffer.bind();
    this.indexBuffer.drawTriangles();
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\n// 漫射光diffuse不考虑视线\n// 通过取光和眼睛的半矢量和normal的内积来确定反射光的强度\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nuniform   mat4 mvpMatrix;\nout   vec3 vNormal;\nout   vec4 vColor;\n\nvoid main(void){\n    vNormal     = normal;\n    vColor      = color;\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform mat4 invMatrix;\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform vec4 ambientColor;\nin vec3 vNormal;\nin vec4 vColor;\nout vec4 FragColor;\n\nvoid main(void){\n    vec3  invLight  = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n    vec3  invEye    = normalize(invMatrix * vec4(eyeDirection, 0.0)).xyz;\n    vec3  halfLE    = normalize(invLight + invEye);\n    float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0);\n    float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0);\n    vec4  destColor = vColor * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;\n    FragColor    = destColor;\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Torus", function() { return Torus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsva", function() { return hsva; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plane", function() { return plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadData", function() { return QuadData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeData", function() { return CubeData; });
function Torus(circlePoints, circleNum, rdius, Origin2CicleCenter, colors) {
  let pos = [];
  let index = [];
  let normal = [];
  let color = [];
  let tc;

  for (let i = 0; i <= circlePoints; i++) {
    let theta = Math.PI * 2 / circlePoints * i; // 圆平面弧度计算 x,y平面，得到y

    let rr = Math.cos(theta);
    let ry = Math.sin(theta); // Origin2Cicle平面计算 x,z 平面

    for (let j = 0; j <= circleNum; j++) {
      let alpha = Math.PI * 2 / circleNum * j;
      let px = (rr * rdius + Origin2CicleCenter) * Math.cos(alpha);
      let py = ry * rdius;
      let pz = (rr * rdius + Origin2CicleCenter) * Math.sin(alpha);
      pos.push(px, py, pz);
      if (colors) tc = colors;else tc = hsva(360 / circleNum * j, 1, 1, 1); // hue色调，360度，红色为0°，绿色为120°,蓝色为240°

      color.push(tc[0], tc[1], tc[2], tc[3]);
      let rx = rr * Math.cos(alpha);
      let rz = rr * Math.sin(alpha);
      normal.push(rx, ry, rz);
    }
  } // 每4个顶点，6个index，2个三角形


  for (let i = 0; i < circlePoints; i++) {
    for (let j = 0; j < circleNum; j++) {
      let r = (circleNum + 1) * i + j;
      index.push(r, r + circleNum + 1, r + 1);
      index.push(r + circleNum + 1, r + circleNum + 2, r + 1);
    }
  }

  return {
    pos,
    index,
    normal,
    color
  };
}
function hsva(h, s, v, a) {
  if (s > 1 || v > 1 || a > 1) {
    return;
  }

  let th = h % 360;
  let i = Math.floor(th / 60);
  let f = th / 60 - i;
  let m = v * (1 - s);
  let n = v * (1 - s * f);
  let k = v * (1 - s * (1 - f));
  let color = [];

  if (!s > 0 && !s < 0) {
    color.push(v, v, v, a);
  } else {
    let r = [v, n, m, m, k, v];
    let g = [k, v, v, n, m, m];
    let b = [m, m, k, v, v, n];
    color.push(r[i], g[i], b[i], a);
  }

  return color;
} // 从平面到球，也是采用经纬度的方式

function Sphere(row, column, rad, color) {
  var pos = [],
      nor = [],
      col = [],
      st = [],
      idx = [];

  for (var i = 0; i <= row; i++) {
    var r = Math.PI / row * i;
    var ry = Math.cos(r);
    var rr = Math.sin(r);

    for (var ii = 0; ii <= column; ii++) {
      var tr = Math.PI * 2 / column * ii;
      var tx = rr * rad * Math.cos(tr);
      var ty = ry * rad;
      var tz = rr * rad * Math.sin(tr);
      var rx = rr * Math.cos(tr);
      var rz = rr * Math.sin(tr);

      if (color) {
        var tc = color;
      } else {
        tc = hsva(360 / row * i, 1, 1, 1);
      }

      pos.push(tx, ty, tz);
      nor.push(rx, ry, rz);
      col.push(tc[0], tc[1], tc[2], tc[3]);
      st.push(1 - 1 / column * ii, 1 / row * i);
    }
  }

  r = 0;

  for (i = 0; i < row; i++) {
    for (ii = 0; ii < column; ii++) {
      r = (column + 1) * i + ii;
      idx.push(r, r + 1, r + column + 2);
      idx.push(r, r + column + 2, r + column + 1);
    }
  }

  return {
    pos,
    normal: nor,
    color: col,
    uv: st,
    index: idx
  };
} // simply xz空间平面，normal y+

function plane(xSize, yPos, zSize) {
  const xPos = xSize / 2;
  const zPos = zSize / 2;
  return [// Positions          // Normals         // Texture Coords
  xPos, yPos, zPos, 0.0, 1.0, 0.0, 1.0, 0.0, -xPos, yPos, -zPos, 0.0, 1.0, 0.0, 0.0, 1.0, -xPos, yPos, zPos, 0.0, 1.0, 0.0, 0.0, 0.0, xPos, yPos, zPos, 0.0, 1.0, 0.0, 1.0, 0.0, xPos, yPos, -zPos, 0.0, 1.0, 0.0, 1.0, 1.0, -xPos, yPos, -zPos, 0.0, 1.0, 0.0, 0.0, 1.0];
}
const QuadData = [// position texCoord
-1.0, 1.0, 0.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 0.0, 1.0, 0.0];
const CubeData = [// pos normal textCoord
// back face
-1.0, -1.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // bottom-left
1.0, 1.0, -1.0, 0.0, 0.0, -1.0, 1.0, 1.0, // top-right
1.0, -1.0, -1.0, 0.0, 0.0, -1.0, 1.0, 0.0, // bottom-right
1.0, 1.0, -1.0, 0.0, 0.0, -1.0, 1.0, 1.0, // top-right
-1.0, -1.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // bottom-left
-1.0, 1.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, // top-left
// front face
-1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // bottom-left
1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, // bottom-right
1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, // top-right
1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, // top-right
-1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, // top-left
-1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // bottom-left
// left face
-1.0, 1.0, 1.0, -1.0, 0.0, 0.0, 1.0, 0.0, // top-right
-1.0, 1.0, -1.0, -1.0, 0.0, 0.0, 1.0, 1.0, // top-left
-1.0, -1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, // bottom-left
-1.0, -1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, // bottom-left
-1.0, -1.0, 1.0, -1.0, 0.0, 0.0, 0.0, 0.0, // bottom-right
-1.0, 1.0, 1.0, -1.0, 0.0, 0.0, 1.0, 0.0, // top-right
// right face
1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, // top-left
1.0, -1.0, -1.0, 1.0, 0.0, 0.0, 0.0, 1.0, // bottom-right
1.0, 1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0, // top-right
1.0, -1.0, -1.0, 1.0, 0.0, 0.0, 0.0, 1.0, // bottom-right
1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, // top-left
1.0, -1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, // bottom-left
// bottom face
-1.0, -1.0, -1.0, 0.0, -1.0, 0.0, 0.0, 1.0, // top-right
1.0, -1.0, -1.0, 0.0, -1.0, 0.0, 1.0, 1.0, // top-left
1.0, -1.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, // bottom-left
1.0, -1.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, // bottom-left
-1.0, -1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, // bottom-right
-1.0, -1.0, -1.0, 0.0, -1.0, 0.0, 0.0, 1.0, // top-right
// top face
-1.0, 1.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, // top-left
1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, // bottom-right
1.0, 1.0, -1.0, 0.0, 1.0, 0.0, 1.0, 1.0, // top-right
1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, // bottom-right
-1.0, 1.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, // top-left
-1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0 // bottom-left
];__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mask; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_mask_vert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34);
/* harmony import */ var shaders_mask_vert__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_mask_vert__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_mask_frag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71);
/* harmony import */ var shaders_mask_frag__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_mask_frag__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_maskOutline_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(72);
/* harmony import */ var shaders_maskOutline_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_maskOutline_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(12);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(libs_vao__WEBPACK_IMPORTED_MODULE_9__);










class Mask extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.outlinePrg = this.compile(shaders_mask_vert__WEBPACK_IMPORTED_MODULE_5___default.a, shaders_maskOutline_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.prg = this.compile(shaders_mask_vert__WEBPACK_IMPORTED_MODULE_5___default.a, shaders_mask_frag__WEBPACK_IMPORTED_MODULE_6___default.a); // flip texture

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNPACK_FLIP_Y_WEBGL, true);
  }

  attrib() {
    let cubeVertices = [// positions          // texture Coords
    -0.5, -0.5, -0.5, 0.0, 0.0, 0.5, -0.5, -0.5, 1.0, 0.0, 0.5, 0.5, -0.5, 1.0, 1.0, 0.5, 0.5, -0.5, 1.0, 1.0, -0.5, 0.5, -0.5, 0.0, 1.0, -0.5, -0.5, -0.5, 0.0, 0.0, -0.5, -0.5, 0.5, 0.0, 0.0, 0.5, -0.5, 0.5, 1.0, 0.0, 0.5, 0.5, 0.5, 1.0, 1.0, 0.5, 0.5, 0.5, 1.0, 1.0, -0.5, 0.5, 0.5, 0.0, 1.0, -0.5, -0.5, 0.5, 0.0, 0.0, -0.5, 0.5, 0.5, 1.0, 0.0, -0.5, 0.5, -0.5, 1.0, 1.0, -0.5, -0.5, -0.5, 0.0, 1.0, -0.5, -0.5, -0.5, 0.0, 1.0, -0.5, -0.5, 0.5, 0.0, 0.0, -0.5, 0.5, 0.5, 1.0, 0.0, 0.5, 0.5, 0.5, 1.0, 0.0, 0.5, 0.5, -0.5, 1.0, 1.0, 0.5, -0.5, -0.5, 0.0, 1.0, 0.5, -0.5, -0.5, 0.0, 1.0, 0.5, -0.5, 0.5, 0.0, 0.0, 0.5, 0.5, 0.5, 1.0, 0.0, -0.5, -0.5, -0.5, 0.0, 1.0, 0.5, -0.5, -0.5, 1.0, 1.0, 0.5, -0.5, 0.5, 1.0, 0.0, 0.5, -0.5, 0.5, 1.0, 0.0, -0.5, -0.5, 0.5, 0.0, 0.0, -0.5, -0.5, -0.5, 0.0, 1.0, -0.5, 0.5, -0.5, 0.0, 1.0, 0.5, 0.5, -0.5, 1.0, 1.0, 0.5, 0.5, 0.5, 1.0, 0.0, 0.5, 0.5, 0.5, 1.0, 0.0, -0.5, 0.5, 0.5, 0.0, 0.0, -0.5, 0.5, -0.5, 0.0, 1.0];
    let planeVertices = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, 3.0, 0.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, -3.0, 1.0, 1.0];
    this.cubeBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(cubeVertices));
    this.planeBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(planeVertices));
    this.cubeBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.cubeBuffer.attrib('texcoord', 2, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.planeBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.planeBuffer.attrib('texcoord', 2, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.planeVao = new libs_vao__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    this.planeVao.setup(this.prg, [this.planeBuffer]);
    this.cubeVao = new libs_vao__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    this.cubeVao.setup(this.prg, [this.cubeBuffer]);
    this.texture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_4___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA);
    let img = getAssets.splash;
    this.texture.fromImage(img);
    this.texture.bind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].NEAREST_MIPMAP_NEAREST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].generateMipmap(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, null);
  }

  _setGUI() {
    this.addGUIParams({
      lod: 5.,
      LINEAR_MIPMAP_LINEAR: false,
      NEAREST_MIPMAP_NEAREST: true
    });
    let folder = this.gui.addFolder('tetxureLod lod param');
    folder.add(this.params, 'lod', 1., Math.log2(512)).step(1.);
    folder.open();
    let folder1 = this.gui.addFolder('TEXTURE_MIN_FILTER');
    folder1.add(this.params, 'LINEAR_MIPMAP_LINEAR').listen().onChange(() => {
      this.setChecked('LINEAR_MIPMAP_LINEAR');
    });
    folder1.add(this.params, 'NEAREST_MIPMAP_NEAREST').listen().onChange(() => {
      this.setChecked('NEAREST_MIPMAP_NEAREST');
    });
    folder1.open();
  }

  setChecked(val) {
    this.texture.bind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"][val]);
    this.params.LINEAR_MIPMAP_LINEAR = false;
    this.params.NEAREST_MIPMAP_NEAREST = false;
    this.params[val] = true;
  }

  prepare() {
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    this.mvpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].lookAt(vMatrix, [0.0, 0.0, 4.0], [0, 0, 0.0], [0, 1, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientHeight, .1, 1000);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].multiply(this.tmpMatrix, pMatrix, vMatrix);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LESS);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].STENCIL_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].stencilFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].NOTEQUAL, 1, 0xff);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].stencilOp(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].REPLACE);
  }

  uniform() {
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    this.count++;
    let rad = this.count % 360 * Math.PI / 180;
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].rotate(mMatrix, mMatrix, rad, [0, 1, 1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
    this.prg.use();
    this.texture.bind(0);
    this.prg.style({
      mvpMatrix: this.mvpMatrix,
      texture: 0,
      lod: this.params.lod
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].STENCIL_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].stencilMask(0x00); //写入0

    this.prg.use();
    this.planeVao.bind();
    this.planeBuffer.drawTriangles();
    this.planeVao.unbind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].stencilFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].ALWAYS, 1, 0xff);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].stencilMask(0xff); //写入1

    this.cubeVao.bind();
    this.cubeBuffer.drawTriangles();
    this.cubeVao.unbind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].stencilFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].NOTEQUAL, 1, 0xff); //不等于1的才能通过测试

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].stencilMask(0x00); //写入0

    this.outlinePrg.use();
    const scale = 1.1;
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    let rad = this.count % 360 * Math.PI / 180; //不旋转看到的会是一个mask方面

    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].rotate(mMatrix, mMatrix, rad, [0, 1, 1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [scale, scale, scale]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
    this.outlinePrg.style({
      mvpMatrix: this.mvpMatrix
    });
    this.cubeVao.bind();
    this.cubeBuffer.drawTriangles();
    this.cubeVao.unbind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].stencilMask(0xff);
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texcoord;\nuniform   mat4 mvpMatrix;\nout   vec2 TexCoords;\n\nvoid main(void){\n    TexCoords = texcoord;\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin   vec2 TexCoords;\nout vec4 outColor;\nuniform sampler2D texture;\nuniform float lod;\nvoid main(void){\n\n    outColor = textureLod(texture, TexCoords, lod);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 outColor;\nvoid main()\n{\n  outColor = vec4(0.04, 0.28, 0.26, 1.0);\n}\n"function shimGL(gl, ext) {
  gl.bindVertexArray = function () {
    return ext.bindVertexArrayOES.apply(ext, arguments);
  };

  gl.createVertexArray = function () {
    return ext.createVertexArrayOES.apply(ext, arguments);
  };

  gl.deleteVertexArray = function () {
    return ext.deleteVertexArrayOES.apply(ext, arguments);
  };

  gl.isVertexArray = function () {
    return ext.isVertexArrayOES.apply(ext, arguments);
  };
}
/**
 * @class
 * @classdesc Vao manage attributes pointers setup for given arraybuffer and program
 * It provide a transparent fallback if extension isn't available
 *
 *  @param {WebGLRenderingContext} gl webgl context the vao belongs to
 */


function Vao(gl) {
  this.gl = gl;

  if (gl.bindVertexArray !== undefined) {
    this._impl = new NativeVao(this);
  } else {
    var ext = gl.getExtension('OES_vertex_array_object');

    if (ext) {
      shimGL(gl, ext);
      this._impl = new NativeVao(this);
    } else {
      this._impl = new EmulateVao(this);
    }
  }
}

Vao.prototype = {
  /**
    * release the internal webgl vao
    */
  dispose: function () {
    this._impl.dispose();

    this._impl = null;
  },

  /**
   * Initialize attrib pointer setup for given program and arraybuffers
   *   @param {Program} prg the nanogl Program
   *   @param {ArrayBuffer[]} buffers an array of ArrayBuffers containing the attributes
   */
  setup: function (prg, buffers, indices) {
    if (!prg.ready) {
      prg._grabParameters();
    }

    this._impl.setup(prg, buffers, indices);
  },

  /**
   * Bind the VAO. Call this method before each draw call
   */
  bind: function () {
    this._impl.bind();
  },

  /**
   * Unbind the VAO. Call this method after each draw call
   */
  unbind: function () {
    this._impl.unbind();
  }
}; // ---------------------------
//   Native Implementation Webgl1 extension or Webgl2 native
// ---------------------------

function NativeVao(vao) {
  this._vao = vao;
  this._handle = null;
}

NativeVao.prototype = {
  dispose: function () {
    this.release();
    this._vao = null;
  },
  setup: function (prg, buffers, indices) {
    this.release();
    var gl = this._vao.gl;
    this._handle = gl.createVertexArray();
    gl.bindVertexArray(this._handle);

    for (var i = 0; i < buffers.length; i++) {
      buffers[i].attribPointer(prg);
    }

    if (indices !== undefined) {
      indices.bind();
    }

    gl.bindVertexArray(null);
  },
  bind: function () {
    this._vao.gl.bindVertexArray(this._handle);
  },
  unbind: function () {
    this._vao.gl.bindVertexArray(null);
  },
  release: function () {
    if (this._handle) {
      this._vao.gl.deleteVertexArray(this._handle);

      this._handle = null;
    }
  }
}; // ---------------------------
//   Emulation Implementation
// ---------------------------

function EmulateVao(vao) {
  this._vao = vao;
}

EmulateVao.prototype = {
  dispose: function () {
    this._vao = null;
    this.prg = null;
    this.buffers = null;
    this.indices = null;
  },
  setup: function (prg, buffers, indices) {
    this.prg = prg;
    this.buffers = buffers;
    this.indices = indices;
  },
  bind: function () {
    for (var i = 0; i < this.buffers.length; i++) {
      this.buffers[i].attribPointer(this.prg);
    }

    if (this.indices !== undefined) {
      this.indices.bind();
    }
  },
  unbind: function () {// noop
  }
};
module.exports = Vao;__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mirror; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var shaders_mirror_simple_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(73);
/* harmony import */ var shaders_mirror_simple_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_mirror_simple_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_mirror_simple_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(74);
/* harmony import */ var shaders_mirror_simple_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_mirror_simple_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_mirror_mirror_vert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75);
/* harmony import */ var shaders_mirror_mirror_vert__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_mirror_mirror_vert__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_mirror_mirror_frag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(76);
/* harmony import */ var shaders_mirror_mirror_frag__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_mirror_mirror_frag__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1);
/* harmony import */ var libs_glFbo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(22);
/* harmony import */ var libs_glFbo__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(libs_glFbo__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(4);











class Mirror extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "ortMatrix", gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create()));
  }

  init() {
    this.prg = this.compile(shaders_mirror_simple_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_mirror_simple_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
    this.mPrg = this.compile(shaders_mirror_mirror_vert__WEBPACK_IMPORTED_MODULE_5___default.a, shaders_mirror_mirror_frag__WEBPACK_IMPORTED_MODULE_6___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      color
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_7__["Torus"])(64, 64, 0.2, 0.7);
    let torus = new libs_Mesh__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]();
    torus.bufferVertex(pos);
    torus.bufferIndices(index);
    torus.bufferNormal(normal);
    torus.bufferColor(color);
    this.torus = torus;
    let position = [-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];
    color = [0.3, 0.5, 0.5, 1.0, 0.5, 0.5, 0.1, 1.0, 0.5, 0.5, 0.1, 1.0, 0.5, 0.5, 0.1, 1.0];
    let texCoord = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0];
    index = [0, 2, 1, 1, 2, 3];
    let plane = new libs_Mesh__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]();
    plane.bufferVertex(position);
    plane.bufferIndices(index);
    plane.bufferTexCoord(texCoord);
    plane.bufferColor(color);
    this.plane = plane;
  }

  prepare() {
    this.fbo = new libs_glFbo__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"]);
    this.fbo.resize(512, 512);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].CULL_FACE);
  }

  uniform() {
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    let eyeDirection = [];
    let camUpDirection = [];
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* vec3 */ "d"].transformQuat(eyeDirection, [0.0, 5.0, 5.0], this.rotateQ);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* vec3 */ "d"].transformQuat(camUpDirection, [0.0, 1.0, -1.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].lookAt(vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].perspective(pMatrix, 45, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* canvas */ "a"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].multiply(this.tmpMatrix, pMatrix, vMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].lookAt(vMatrix, [0.0, 0.0, .1], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].ortho(pMatrix, -1.0, 1.0, -1.0, 1.0, 0.1, 1.);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].multiply(this.ortMatrix, pMatrix, vMatrix);
  }

  render() {
    this.fbo.bind();
    this.fbo.clear();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clearColor(0.3, 0.8, 0.4, 0.3);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].cullFace(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].FRONT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].rotate(mMatrix, mMatrix, 1 * 2 * Math.PI / 9, [0, 1, 0]);
    let invMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].invert(invMatrix, mMatrix);
    this.prg.use();
    this.prg.style({
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix,
      invMatrix,
      lightDirection: [0., -0.5, 0.577],
      eyeDirection: this.eyeDirection,
      ambientColor: [0., 0., 0., 0.0],
      mirror: true
    });
    this.torus.bind(this.prg);
    this.torus.draw();
    this.fbo.unbind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clearColor(0.0, 0.7, 0.7, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clearStencil(0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DEPTH_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].STENCIL_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].cullFace(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].BACK); // this.torus.bind(this.prg)
    // this.torus.draw()

    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].STENCIL_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].stencilFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].ALWAYS, 1, ~0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].stencilOp(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].REPLACE); // 只有通过深度测试和模板测试时才替换为1

    mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(mMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].translate(mMatrix, mMatrix, [0.0, 1., 0.0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [1.7, 1.7, 1.7]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].rotate(mMatrix, mMatrix, Math.PI * 1.5, [1, 0, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].invert(invMatrix, mMatrix);
    this.prg.style({
      mMatrix: mMatrix,
      invMatrix
    });
    this.plane.bind(this.prg, ['position', 'color', 'normal']);
    this.plane.draw();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].stencilFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].EQUAL, 1, ~0); // 等于1才通过,不然正交投影会到整个屏幕

    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].stencilOp(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].KEEP);
    this.mPrg.use();
    this.fbo.bindColor(this.mPrg.texture(), 0);
    this.mPrg.style({
      alpha: .9,
      texture: 0,
      ortMatrix: this.ortMatrix
    });
    this.plane.bind(this.mPrg, ['position', 'texCoord']); // this.plane.draw(gl.LINE_STRIP)

    this.plane.draw();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].disable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].STENCIL_TEST);
  }

}module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\nuniform   bool mirror;\nvarying   vec3 vNormal;\nvarying   vec4 vColor;\nuniform vec3 eyeDirection;\nvarying float dist;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tif(mirror){pos = vec4(pos.x, -pos.y, pos.zw);}\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = normal;\n  vColor      = color;\n  dist = distance(position.xyz, eyeDirection);\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform mat4 invMatrix;\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform vec4 ambientColor;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying float dist;\n\nvoid main(void){\n    vec3  invLight  = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n    vec3  invEye    = normalize(invMatrix * vec4(eyeDirection, 0.0)).xyz;\n    vec3  halfLE    = normalize(invLight + invEye);\n    float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0);\n    float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0); // 50.0来模仿粗糙度\n    vec4  destColor = vColor * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;\n    // float gamma = 2.2; // 我们本身用的已经是数字颜色，而不是看到的颜色，所以不需要gamma校正\n    // destColor.rgb = pow(destColor.rgb, vec3(1.0/gamma));\n    gl_FragColor    = destColor;\n    // gl_FragColor = vec4(700.,0.3,1.,1.);\n}\n"module.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nuniform   mat4 ortMatrix;\nvarying   vec2 vTexCoord;\n\nvoid main(void){\n    vTexCoord   = texCoord;\n    gl_Position = ortMatrix * vec4(position, 1.0);\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\nuniform float     alpha;\nvarying vec2      vTexCoord;\n\nvoid main(void){\n    vec2 tc      = vec2(vTexCoord.s, 1. - vTexCoord.t);\n    gl_FragColor = vec4(texture2D(texture, tc).rgb, alpha);\n    // gl_FragColor = vec4(vec3(vTexCoord.t),1.);\n}\n"var Texture = __webpack_require__(3);
/**
 * @class
 * @param {WebGLRenderingContext} gl      the webgl context this Fbo belongs to
 * @param {Object} [opts]
 * @param {boolean} [opts.depth=false] if true, a depth renderbuffer is attached
 * @param {boolean} [opts.stencil=false] if true, a stencil renderbuffer is attached
 * @param {GLenum|GLenum[]} [opts.type=GL_UNSIGNED_BYTE] the pixel type of the Fbo, can be gl.UNSIGNED_BYTE, gl.FLOAT, half.HALF_FLOAT_OES etc. you can also provide an array of types used as cascaded fallbacks
 * @param {GLenum} [opts.format=GL_RGB] the internal pixel format.
 *
 */


function Fbo(gl, opts) {
  this.gl = gl;
  this.width = 0;
  this.height = 0;
  this.fbo = null;
  opts = opts || DEFAULT_OPTS;
  var flags = opts.depth | opts.stencil << 1;
  var types = opts.type || gl.UNSIGNED_BYTE;
  this.types = Array.isArray(types) ? types : [types];
  this.color = new Texture(gl, opts.format);
  this.attachment = new DepthStencilAttachment(this, flags);
}

Fbo.prototype = {
  /**
   * Resize FBO attachments
   *  @param {uint} w new width
   *  @param {uint} h new height
   */
  resize: function (w, h) {
    if (this.width !== w || this.height !== h) {
      this.width = w | 0;
      this.height = h | 0;

      if (this.fbo === null) {
        this._init();
      }

      this._allocate();
    }
  },

  /**
   * Bind the color texture of this Fbo to a sampler2D location and a unit
   * The related program must be in use.
   * @param {WebGLUniformLocation} location the program's sampler to bind the textue to
   * @param {} unit the texture unit to use
   */
  bindColor: function (location, unit) {
    var gl = this.gl;
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, this.color.id);
    gl.uniform1i(location, unit);
  },

  /**
   * Bind the Fbo and set gl viewport to it's size
   */
  bind: function () {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
    gl.viewport(0, 0, this.width, this.height);
  },
  unbind: function () {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  },

  /**
   * Clear all buffer of the Fbo.
   * The Fbo must be explicitly bound before calling this method
   */
  clear: function () {
    var gl = this.gl;
    var bits = gl.COLOR_BUFFER_BIT | this.attachment.clearBits();
    gl.clear(bits);
  },

  /**
   * Check if the Fbo is valid,
   * The Fbo must be explicitely bound before calling this method
   */
  isValid: function () {
    var gl = this.gl;
    return gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
  },

  /**
   * return the actual pixel type of the underlying color texture (UNSIGNED_BYTE, FLOAT, HALF_FLOAT_EOS etc)
   * after possibles types has been tested
   */
  getActualType: function () {
    return this.color.type;
  },

  /**
   * Delete all webgl objects related to this Fbo (fbo, color attachment and depth/stencil renderbuffer )
   */
  dispose: function () {
    var gl = this.gl;
    gl.deleteFramebuffer(this.fbo);
    this.color.dispose();
    this.attachment.dispose();
    this.valid = false;
    this.fbo = null;
    this.gl = null;
  },
  // create render buffers and set attchment points
  _init: function () {
    var gl = this.gl;
    this.fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.color.id, 0);

    this.attachment._init();
  },
  // (re)allocate render buffers to size
  _allocate: function () {
    var gl = this.gl;

    this.attachment._allocate();

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
    var tIndex = 0;
    var nextFmt = this.types[tIndex];

    do {
      this.color.fromData(this.width, this.height, null, nextFmt);
      gl.getError(); // clear possible texture error
    } while (!(this.valid = this.isValid()) && (nextFmt = this.types[++tIndex]));

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
}; //---------------------------------
//         Depth/Stencil Attachment
//---------------------------------

function DepthStencilAttachment(fbo, flags) {
  this.fbo = fbo;
  this.flags = flags;
  this.buffer = null;
}

DepthStencilAttachment.prototype = {
  _init: function () {
    var gl = this.fbo.gl;
    var attType = this.flags & 3;
    var depth = null;

    if (attType !== 0) {
      depth = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, depth);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, getAttachmentType(gl, attType), gl.RENDERBUFFER, depth);
    }

    this.buffer = depth;
  },
  _allocate: function () {
    var gl = this.fbo.gl;
    var attType = this.flags & 3;

    if (attType !== 0) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.buffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, getAttachmentFormat(gl, attType), this.fbo.width, this.fbo.height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
  },
  dispose: function () {
    if (this.buffer) {
      this.fbo.gl.deleteRenderbuffer(this.buffer);
    }

    this.buffer = null;
  },
  clearBits: function () {
    return (this.flags & 1 ? 0x0100 : 0) | (this.flags & 2 ? 0x0400 : 0);
  }
}; //---------------------------------
//                        Utilities
//---------------------------------
// renderbuffer format

function getAttachmentFormat(gl, type) {
  switch (type) {
    case 1:
      return 0x81A5;
    // DEPTH_COMPONENT16;

    case 2:
      return 0x8D48;
    // STENCIL_INDEX8;

    case 3:
      return 0x84F9;
    // DEPTH_STENCIL;

    default:
      throw new Error('unknown attachment type ' + type);
  }
}

function getAttachmentType(gl, type) {
  switch (type) {
    case 1:
      return 0x8D00;
    // DEPTH_ATTACHMENT

    case 2:
      return 0x8D20;
    // STENCIL_ATTACHMENT;

    case 3:
      return 0x821A;
    // DEPTH_STENCIL_ATTACHMENT;

    default:
      throw new Error('unknown attachment type ' + type);
  }
}

var DEFAULT_OPTS = {};
module.exports = Fbo;__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mrt; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_mrt_mrt_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(77);
/* harmony import */ var shaders_mrt_mrt_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_mrt_mrt_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_mrt_mrt_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78);
/* harmony import */ var shaders_mrt_mrt_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_mrt_mrt_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_mrt_simple_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(79);
/* harmony import */ var shaders_mrt_simple_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_mrt_simple_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_mrt_simple_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(80);
/* harmony import */ var shaders_mrt_simple_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_mrt_simple_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(12);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(libs_vao__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6);











let mrtStatus = {
  color_attachments: 0,
  draw_buffers: 0
};
let ext;
let frameBuffer;
class Mrt extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "offset", [[-0.5, -0.5, 0.0], [-0.5, 0.5, 0.0], [0.5, -0.5, 0.0], [0.5, 0.5, 0.0]]);
  }

  init() {
    ext = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension('WEBGL_draw_buffers');

    if (!ext) {
      alert('WEBGL_draw_buffers not supported');
      return;
    } else {
      mrtStatus.color_attachments = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL);
      mrtStatus.draw_buffers = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getParameter(ext.MAX_DRAW_BUFFERS_WEBGL);
      console.log('MAX_COLOR_ATTACHMENTS_WEBGL: ' + mrtStatus.color_attachments);
      console.log('MAX_DRAW_BUFFERS_WEBGL: ' + mrtStatus.draw_buffers);
    }

    this.mrtPrg = this.compile(shaders_mrt_mrt_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_mrt_mrt_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.prg = this.compile(shaders_mrt_simple_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_mrt_simple_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      color
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_10__["Torus"])(64, 64, 1.0, 3.0, [1.0, 1.0, 1.0, 1.0]);
    const tPosBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(pos));
    const tNormalBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(normal));
    const tColorBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(color));
    this.indexBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* IndexBuffer */ "b"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNSIGNED_SHORT, new Uint16Array(index), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].STATIC_DRAW);
    tPosBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    tNormalBuffer.attrib('normal', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    tColorBuffer.attrib('color', 4, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.torusVao = new libs_vao__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    this.torusVao.setup(this.mrtPrg, [tPosBuffer, tNormalBuffer, tColorBuffer]);
    let vPos = [-0.5, 0.5, 0.0, 0.5, 0.5, 0.0, -0.5, -0.5, 0.0, 0.5, -0.5, 0.0];
    let vTexCoord = [0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0];
    let vIndex = [0, 2, 1, 2, 3, 1];
    const vPosBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(vPos));
    const vTexBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(vTexCoord));
    this.vIndexBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* IndexBuffer */ "b"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNSIGNED_SHORT, new Uint16Array(vIndex), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].STATIC_DRAW);
    vPosBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    vTexBuffer.attrib('texCoord', 2, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.mainVao = new libs_vao__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    this.mainVao.setup(this.prg, [vPosBuffer, vTexBuffer]);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CULL_FACE); //double side

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearColor(.3, .3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearDepth(1.0);
    frameBuffer = createFramebufferMRT(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height); //full canvas size

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, frameBuffer.t[0]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE1);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, frameBuffer.t[1]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE2);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, frameBuffer.t[2]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE3);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, frameBuffer.t[3]); //z值为pespecte之后的z，camera从上往下看，z相同，所以depth里圆圈颜色相同，转动后，透视z值改变，颜色改变

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, frameBuffer.f);
    const bufferList = [ext.COLOR_ATTACHMENT0_WEBGL, ext.COLOR_ATTACHMENT1_WEBGL, ext.COLOR_ATTACHMENT2_WEBGL, ext.COLOR_ATTACHMENT3_WEBGL];
    ext.drawBuffersWEBGL(bufferList); // 指定渲染目标

    this.camera.radius = 28;
  }

  uniform() {
    let vMatrix = this.camera.viewMatrix;
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create();
    this.mvpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create();
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].multiply(this.tmpMatrix, pMatrix, vMatrix);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, frameBuffer.f);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    const lightDirection = [-0.577, 0.577, 0.577];
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create();
    let invMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].create();
    this.count++;
    let rad = this.count % 360 * Math.PI / 180;
    this.mrtPrg.use();
    this.torusVao.bind();
    this.indexBuffer.bind();

    for (let i = 0; i < 9; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].identity(mMatrix); //绕y轴旋转，改变model坐标系方向，便于后续移动错开

      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].rotate(mMatrix, mMatrix, i * 2 * Math.PI / 9, [0, 1, 0]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].translate(mMatrix, mMatrix, [0.0, 0.0, 15.0]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].rotate(mMatrix, mMatrix, rad, [1, 1, 0]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "a"].invert(invMatrix, mMatrix);
      let ambient = Object(_Torus__WEBPACK_IMPORTED_MODULE_10__["hsva"])(i * 40, 1.0, 1.0, 1.0); //hue 0-360为各常见色彩

      this.mrtPrg.style({
        lightDirection,
        mvpMatrix: this.mvpMatrix,
        ambient,
        invMatrix
      });
      this.indexBuffer.drawTriangles();
    }

    this.torusVao.unbind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.prg.use();
    this.mainVao.bind();
    this.vIndexBuffer.bind();

    for (let i = 0; i < 4; ++i) {
      this.prg.style({
        offset: this.offset[i],
        texture: i
      });
      this.vIndexBuffer.drawTriangles();
    }

    this.mainVao.unbind();
  }

} //链接纹理到framebuffer

function createFramebufferMRT(width, height) {
  let frameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createFramebuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, frameBuffer);
  let fTexture = [];

  for (let i = 0; i < 4; ++i) {
    fTexture[i] = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, fTexture[i]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNSIGNED_BYTE, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL + i, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, fTexture[i], 0);
  }

  let depthRenderBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createRenderbuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, depthRenderBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].renderbufferStorage(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_COMPONENT16, width, height);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_ATTACHMENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, depthRenderBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null);
  return {
    f: frameBuffer,
    d: depthRenderBuffer,
    t: fTexture
  };
}module.exports = "#define GLSLIFY 1\nattribute vec3  position;\nattribute vec3  normal;\nattribute vec4  color;\nuniform   mat4  mvpMatrix;\nuniform   mat4  invMatrix;\nuniform   vec3  lightDirection;\nuniform   vec4  ambient;\nvarying   vec4  vDest;\nvarying   vec4  vColor;\nvarying   vec3  vNormal;\nvarying   float vDepth;\n\nvoid main(){\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n    vec3 invLight = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n    float diff = clamp(dot(normal, invLight), 0.1, 1.0);\n    vDest = vec4(color.rgb * ambient.rgb * diff, 1.0);\n    vColor = color * ambient;\n    vNormal = normal;\n    vDepth = gl_Position.z / gl_Position.w;\n}\n"module.exports = "#extension GL_EXT_draw_buffers: require\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec4  vDest;\nvarying vec4  vColor;\nvarying vec3  vNormal;\nvarying float vDepth;\n\nfloat near = 0.1;\nfloat far  = 100.0;\n\n// https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/\n// http://www.songho.ca/opengl/gl_projectionmatrix.html\nfloat LinearizeDepth(float depth)\n{\n    float z = depth * 2.0 - 1.0; // back to NDC\n    return (2.0 * near * far) / (far + near - z * (far - near));\n}\n\nvoid main(){\n    gl_FragData[0] = vDest;\n    gl_FragData[1] = vColor;\n    gl_FragData[2] = vec4((vNormal + 1.0) / 2.0, 1.0);\n    float depth = (LinearizeDepth(gl_FragCoord.z) -near) /(far-near);\n    gl_FragData[3] = vec4(vec3(depth), 1.);\n\n    // gl_FragColor = vec4(.3,.3,.3,1.);\n}\n"module.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nuniform vec3 offset;\nvarying vec2 vTexCoord;\n\nvoid main(){\n\tvTexCoord = texCoord;\n\tgl_Position = vec4(position + offset, 1.0);\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\nvarying vec2 vTexCoord;\n\nvoid main(){\n\tgl_FragColor = texture2D(texture, vTexCoord);\n  // gl_FragColor = vec4(.3, .0, .3, 1.);\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying   vec3 vNormal;\nvarying vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 kS = fresnelSchlick(max(dot(N, V), 0.0), F0);\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n    vec3 irradiance = textureCube(irradianceMap, N).rgb;\n    vec3 diffuse      = irradiance * albedo;\n    vec3 ambient = (kD * diffuse) * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"module.exports = "#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\n#define GLSLIFY 1\n// material map\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture2D(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture2D(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture2D(metallicMap, TexCoords).r;\n    float roughness = texture2D(roughnessMap, TexCoords).r;\n    float ao        = texture2D(aoMap, TexCoords).r;\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"module.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 WorldPos;\nvarying vec2 vUv;\nvoid main(void){\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  WorldPos = pos.xyz;\n  vUv = texCoord;\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D equirectangularMap;\nvarying vec3 WorldPos;\nvarying vec2 vUv;\n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec2 SampleSphericalMap(vec3 v)\n{\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y)); // [-PI/2,PI/2]\n    uv *= invAtan; //[-.5,.5]\n    uv += 0.5;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = SampleSphericalMap(normalize(WorldPos));\n    vec3 color = texture2D(equirectangularMap, uv).rgb;\n\n    gl_FragColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(WorldPos,1.);\n}\n"module.exports = "#define GLSLIFY 1\nattribute vec3 position;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 WorldPos;\n\nvoid main()\n{\n\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tvec4 clipPos    = vpMatrix * pos;\n\tgl_Position = clipPos.xyww; // 设置深度测试的z为1，这样只会在没有遮挡时渲染skybox，节省性能\n\n  WorldPos = pos.xyz;\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform samplerCube environmentMap;\nvarying vec3 WorldPos;\n\nvoid main()\n{\n    vec3 envColor = textureCube(environmentMap, WorldPos).rgb;\n\n    // HDR tonemap and gamma correct\n    envColor = envColor / (envColor + vec3(1.0));\n    envColor = pow(envColor, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(envColor, 1.0);\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\nvarying vec3 WorldPos;\n\nuniform samplerCube environmentMap;\n\nconst float PI = 3.14159265359;\n\nvoid main()\n{\n\t// The world vector acts as the normal of a tangent surface\n    // from the origin, aligned to WorldPos. Given this normal, calculate all\n    // incoming radiance of the environment. The result of this radiance\n    // is the radiance of light coming from -Normal direction, which is what\n    // we use in the PBR shader to sample irradiance.\n    vec3 N = normalize(WorldPos);\n\n    vec3 irradiance = vec3(0.0);\n\n    // tangent space calculation from origin point\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up            = cross(N, right);\n\n    const float sampleDelta = 0.025;\n    float nrSamples = 0.0;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\n\n            irradiance += textureCube(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n    gl_FragColor = vec4(irradiance, 1.0);\n}\n"// HDRParser.js
 // Code ported by Marcin Ignac (2014)
// Based on Java implementation from
// https://code.google.com/r/cys12345-research/source/browse/hdr/image_processor/RGBE.java?r=7d84e9fd866b24079dbe61fa0a966ce8365f5726

const radiancePattern = '#\\?RADIANCE';
const commentPattern = '#.*'; // let gammaPattern = 'GAMMA=';

const exposurePattern = 'EXPOSURE=\\s*([0-9]*[.][0-9]*)';
const formatPattern = 'FORMAT=32-bit_rle_rgbe';
const widthHeightPattern = '-Y ([0-9]+) \\+X ([0-9]+)'; // http://croquetweak.blogspot.co.uk/2014/08/deconstructing-floats-frexp-and-ldexp.html
// function ldexp(mantissa, exponent) {
//     return exponent > 1023 ? mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023) : exponent < -1074 ? mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074) : mantissa * Math.pow(2, exponent);
// }

function readPixelsRawRLE(buffer, data, offset, fileOffset, scanlineWidth, numScanlines) {
  const rgbe = new Array(4);
  let scanlineBuffer = null;
  let ptr;
  let ptrEnd;
  let count;
  const buf = new Array(2);
  const bufferLength = buffer.length;

  function readBuf(buf) {
    let bytesRead = 0;

    do {
      buf[bytesRead++] = buffer[fileOffset];
    } while (++fileOffset < bufferLength && bytesRead < buf.length);

    return bytesRead;
  }

  function readBufOffset(buf, offset, length) {
    let bytesRead = 0;

    do {
      buf[offset + bytesRead++] = buffer[fileOffset];
    } while (++fileOffset < bufferLength && bytesRead < length);

    return bytesRead;
  }

  function readPixelsRaw(buffer, data, offset, numpixels) {
    const numExpected = 4 * numpixels;
    const numRead = readBufOffset(data, offset, numExpected);

    if (numRead < numExpected) {
      throw new Error(`Error reading raw pixels: got ${numRead} bytes, expected ${numExpected}`);
    }
  }

  while (numScanlines > 0) {
    if (readBuf(rgbe) < rgbe.length) {
      throw new Error(`Error reading bytes: expected ${rgbe.length}`);
    }

    if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
      // this file is not run length encoded
      data[offset++] = rgbe[0];
      data[offset++] = rgbe[1];
      data[offset++] = rgbe[2];
      data[offset++] = rgbe[3];
      readPixelsRaw(buffer, data, offset, scanlineWidth * numScanlines - 1);
      return;
    }

    if (((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) !== scanlineWidth) {
      throw new Error(`Wrong scanline width ${(rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF}, expected ${scanlineWidth}`);
    }

    if (scanlineBuffer === null) {
      scanlineBuffer = new Array(4 * scanlineWidth);
    }

    ptr = 0;
    /* read each of the four channels for the scanline into the buffer */

    for (let i = 0; i < 4; i++) {
      ptrEnd = (i + 1) * scanlineWidth;

      while (ptr < ptrEnd) {
        if (readBuf(buf) < buf.length) {
          throw new Error('Error reading 2-byte buffer');
        }

        if ((buf[0] & 0xFF) > 128) {
          /* a run of the same value */
          count = (buf[0] & 0xFF) - 128;

          if (count === 0 || count > ptrEnd - ptr) {
            throw new Error('Bad scanline data');
          }

          while (count-- > 0) {
            scanlineBuffer[ptr++] = buf[1];
          }
        } else {
          /* a non-run */
          count = buf[0] & 0xFF;

          if (count === 0 || count > ptrEnd - ptr) {
            throw new Error('Bad scanline data');
          }

          scanlineBuffer[ptr++] = buf[1];

          if (--count > 0) {
            if (readBufOffset(scanlineBuffer, ptr, count) < count) {
              throw new Error('Error reading non-run data');
            }

            ptr += count;
          }
        }
      }
    }
    /* copy byte data to output */


    for (let i = 0; i < scanlineWidth; i++) {
      data[offset + 0] = scanlineBuffer[i];
      data[offset + 1] = scanlineBuffer[i + scanlineWidth];
      data[offset + 2] = scanlineBuffer[i + 2 * scanlineWidth];
      data[offset + 3] = scanlineBuffer[i + 3 * scanlineWidth];
      offset += 4;
    }

    numScanlines--;
  }
} // Returns data as floats and flipped along Y by default


function parseHdr(buffer) {
  if (buffer instanceof ArrayBuffer) {
    buffer = new Uint8Array(buffer);
  }

  let fileOffset = 0;
  const bufferLength = buffer.length;
  const NEW_LINE = 10;

  function readLine() {
    let buf = '';

    do {
      const b = buffer[fileOffset];

      if (b === NEW_LINE) {
        ++fileOffset;
        break;
      }

      buf += String.fromCharCode(b);
    } while (++fileOffset < bufferLength);

    return buf;
  }

  let width = 0;
  let height = 0;
  let exposure = 1;
  const gamma = 1;
  let rle = false;

  for (let i = 0; i < 20; i++) {
    const line = readLine();
    let match;

    if (match = line.match(radiancePattern)) {} else if (match = line.match(formatPattern)) {
      rle = true;
    } else if (match = line.match(exposurePattern)) {
      exposure = Number(match[1]);
    } else if (match = line.match(commentPattern)) {} else if (match = line.match(widthHeightPattern)) {
      height = Number(match[1]);
      width = Number(match[2]);
      break;
    }
  }

  if (!rle) {
    throw new Error('File is not run length encoded!');
  }

  const data = new Uint8Array(width * height * 4);
  const scanlineWidth = width;
  const numScanlines = height;
  readPixelsRawRLE(buffer, data, 0, fileOffset, scanlineWidth, numScanlines); // TODO: Should be Float16

  const floatData = new Float32Array(width * height * 4);

  for (let offset = 0; offset < data.length; offset += 4) {
    let r = data[offset + 0] / 255;
    let g = data[offset + 1] / 255;
    let b = data[offset + 2] / 255;
    const e = data[offset + 3];
    const f = Math.pow(2.0, e - 128.0);
    r *= f;
    g *= f;
    b *= f;
    const floatOffset = offset;
    floatData[floatOffset + 0] = r;
    floatData[floatOffset + 1] = g;
    floatData[floatOffset + 2] = b;
    floatData[floatOffset + 3] = 1.0;
  }

  return {
    shape: [width, height],
    exposure: exposure,
    gamma: gamma,
    data: floatData
  };
}

/* harmony default export */ __webpack_exports__["a"] = (parseHdr);/* harmony import */ var _GlTools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var parse_dds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var parse_dds__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(parse_dds__WEBPACK_IMPORTED_MODULE_1__);
// GLCubeTexture.js




const DDSD_MIPMAPCOUNT = 0x20000;
const OFF_MIPMAPCOUNT = 7;
const headerLengthInt = 31;

class GLCubeTexture {
  constructor(mSource, mParameters = {}, isCubeTexture = false) {
    if (isCubeTexture) {
      this.texture = mSource;
      return;
    }

    let hasMipmaps = mSource.length > 6;

    if (mSource[0].mipmapCount) {
      hasMipmaps = mSource[0].mipmapCount > 1;
    }

    this.texture = _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].createTexture();
    this.magFilter = mParameters.magFilter || _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].LINEAR;
    this.minFilter = mParameters.minFilter || _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].LINEAR_MIPMAP_LINEAR;
    this.wrapS = mParameters.wrapS || _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].CLAMP_TO_EDGE;
    this.wrapT = mParameters.wrapT || _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].CLAMP_TO_EDGE;

    if (!hasMipmaps && this.minFilter == _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].LINEAR_MIPMAP_LINEAR) {
      this.minFilter = _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].LINEAR;
    }

    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].bindTexture(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.texture);
    const targets = [_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP_NEGATIVE_X, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_Y, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP_NEGATIVE_Y, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_Z, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP_NEGATIVE_Z];
    let numLevels = 1;
    let index = 0;
    numLevels = mSource.length / 6;
    this.numLevels = numLevels;

    if (hasMipmaps) {
      for (let j = 0; j < 6; j++) {
        for (let i = 0; i < numLevels; i++) {
          _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].pixelStorei(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].UNPACK_FLIP_Y_WEBGL, false);
          index = j * numLevels + i;

          if (mSource[index].shape) {
            if (window.useWebgl2) {
              _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texImage2D(targets[j], i, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA16F, mSource[index].shape[0], mSource[index].shape[1], 0, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].FLOAT, mSource[index].data);
            } else _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texImage2D(targets[j], i, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, mSource[index].shape[0], mSource[index].shape[1], 0, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].FLOAT, mSource[index].data);
          } else {
            _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texImage2D(targets[j], i, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].UNSIGNED_BYTE, mSource[index]);
          }

          _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texParameteri(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_WRAP_S, this.wrapS);
          _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texParameteri(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_WRAP_T, this.wrapT);
          _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texParameteri(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_MAG_FILTER, this.magFilter);
          _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texParameteri(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_MIN_FILTER, this.minFilter);
        }
      }
    } else {
      let index = 0;

      for (let j = 0; j < 6; j++) {
        index = j * numLevels;
        _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].pixelStorei(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].UNPACK_FLIP_Y_WEBGL, false);

        if (mSource[index].shape) {
          if (window.useWebgl2) {
            _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texImage2D(targets[j], 0, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA16F, mSource[index].shape[0], mSource[index].shape[1], 0, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].FLOAT, mSource[index].data);
          } else _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texImage2D(targets[j], 0, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, mSource[index].shape[0], mSource[index].shape[1], 0, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].FLOAT, mSource[index].data);
        } else {
          _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texImage2D(targets[j], 0, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].RGBA, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].UNSIGNED_BYTE, mSource[index]);
        }

        _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texParameteri(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_WRAP_S, this.wrapS);
        _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texParameteri(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_WRAP_T, this.wrapT);
        _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texParameteri(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_MAG_FILTER, this.magFilter);
        _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].texParameteri(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_MIN_FILTER, this.minFilter);
      }

      _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].generateMipmap(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP);
    }

    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].bindTexture(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, null);
  } // PUBLIC METHOD


  bind(index = 0) {
    // if (!GL.shader) {
    //   return;
    // }
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].activeTexture(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE0 + index);
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].bindTexture(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.texture); // gl.uniform1i(GL.shader.uniformTextures[index], index);

    this._bindIndex = index;
  }

  unbind() {
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].bindTexture(_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "d"].TEXTURE_CUBE_MAP, null);
  }

}

GLCubeTexture.parseDDS = function parseDDS(mArrayBuffer) {
  function clamp(value, min, max) {
    if (min > max) {
      return clamp(value, max, min);
    }

    if (value < min) return min;else if (value > max) return max;else return value;
  } //	CHECKING MIP MAP LEVELS


  const ddsInfos = parse_dds__WEBPACK_IMPORTED_MODULE_1___default()(mArrayBuffer);
  const {
    flags
  } = ddsInfos;
  console.log('ddsInfos', ddsInfos);
  const header = new Int32Array(mArrayBuffer, 0, headerLengthInt);
  let mipmapCount = 1;

  if (flags & DDSD_MIPMAPCOUNT) {
    mipmapCount = Math.max(1, header[OFF_MIPMAPCOUNT]);
  }

  const sources = ddsInfos.images.map(img => {
    const faceData = new Float32Array(mArrayBuffer.slice(img.offset, img.offset + img.length));
    return {
      data: faceData,
      shape: img.shape,
      mipmapCount
    };
  });
  return new GLCubeTexture(sources);
};

/* harmony default export */ __webpack_exports__["a"] = (GLCubeTexture);// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
//
// DX10 Cubemap support based on
// https://github.com/dariomanesku/cmft/issues/7#issuecomment-69516844
// https://msdn.microsoft.com/en-us/library/windows/desktop/bb943983(v=vs.85).aspx
// https://github.com/playcanvas/engine/blob/master/src/resources/resources_texture.js

var DDS_MAGIC = 0x20534444
var DDSD_MIPMAPCOUNT = 0x20000
var DDPF_FOURCC = 0x4

var FOURCC_DXT1 = fourCCToInt32('DXT1')
var FOURCC_DXT3 = fourCCToInt32('DXT3')
var FOURCC_DXT5 = fourCCToInt32('DXT5')
var FOURCC_DX10 = fourCCToInt32('DX10')
var FOURCC_FP32F = 116 // DXGI_FORMAT_R32G32B32A32_FLOAT

var DDSCAPS2_CUBEMAP = 0x200
var D3D10_RESOURCE_DIMENSION_TEXTURE2D = 3
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2

// The header length in 32 bit ints
var headerLengthInt = 31

// Offsets into the header array
var off_magic = 0
var off_size = 1
var off_flags = 2
var off_height = 3
var off_width = 4
var off_mipmapCount = 7
var off_pfFlags = 20
var off_pfFourCC = 21
var off_caps2 = 28

module.exports = parseHeaders

function parseHeaders (arrayBuffer) {
  var header = new Int32Array(arrayBuffer, 0, headerLengthInt)

  if (header[off_magic] !== DDS_MAGIC) {
    throw new Error('Invalid magic number in DDS header')
  }

  if (!header[off_pfFlags] & DDPF_FOURCC) {
    throw new Error('Unsupported format, must contain a FourCC code')
  }

  var blockBytes
  var format
  var fourCC = header[off_pfFourCC]
  switch (fourCC) {
    case FOURCC_DXT1:
      blockBytes = 8
      format = 'dxt1'
      break
    case FOURCC_DXT3:
      blockBytes = 16
      format = 'dxt3'
      break
    case FOURCC_DXT5:
      blockBytes = 16
      format = 'dxt5'
      break
    case FOURCC_FP32F:
      format = 'rgba32f'
      break
    case FOURCC_DX10:
      var dx10Header = new Uint32Array(arrayBuffer.slice(128, 128 + 20))
      format = dx10Header[0]
      var resourceDimension = dx10Header[1]
      var miscFlag = dx10Header[2]
      var arraySize = dx10Header[3]
      var miscFlags2 = dx10Header[4]

      if (resourceDimension === D3D10_RESOURCE_DIMENSION_TEXTURE2D && format === DXGI_FORMAT_R32G32B32A32_FLOAT) {
        format = 'rgba32f'
      } else {
        throw new Error('Unsupported DX10 texture format ' + format)
      }
      break
    default:
      throw new Error('Unsupported FourCC code: ' + int32ToFourCC(fourCC))
  }

  var flags = header[off_flags]
  var mipmapCount = 1

  if (flags & DDSD_MIPMAPCOUNT) {
    mipmapCount = Math.max(1, header[off_mipmapCount])
  }

  var cubemap = false
  var caps2 = header[off_caps2]
  if (caps2 & DDSCAPS2_CUBEMAP) {
    cubemap = true
  }

  var width = header[off_width]
  var height = header[off_height]
  var dataOffset = header[off_size] + 4
  var texWidth = width
  var texHeight = height
  var images = []
  var dataLength

  if (fourCC === FOURCC_DX10) {
    dataOffset += 20
  }

  if (cubemap) {
    for (var f = 0; f < 6; f++) {
      if (format !== 'rgba32f') {
        throw new Error('Only RGBA32f cubemaps are supported')
      }
      var bpp = 4 * 32 / 8

      width = texWidth
      height = texHeight

      // cubemap should have all mipmap levels defined
      // Math.log2(width) + 1
      var requiredMipLevels = Math.log(width) / Math.log(2) + 1

      for (var i = 0; i < requiredMipLevels; i++) {
        dataLength = width * height * bpp
        images.push({
          offset: dataOffset,
          length: dataLength,
          shape: [ width, height ]
        })
        // Reuse data from the previous level if we are beyond mipmapCount
        // This is hack for CMFT not publishing full mipmap chain https://github.com/dariomanesku/cmft/issues/10
        if (i < mipmapCount) {
          dataOffset += dataLength
        }
        width = Math.floor(width / 2)
        height = Math.floor(height / 2)
      }
    }
  } else {
    for (var i = 0; i < mipmapCount; i++) {
      dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes

      images.push({
        offset: dataOffset,
        length: dataLength,
        shape: [ width, height ]
      })
      dataOffset += dataLength
      width = Math.floor(width / 2)
      height = Math.floor(height / 2)
    }
  }

  return {
    shape: [ texWidth, texHeight ],
    images: images,
    format: format,
    flags: flags,
    cubemap: cubemap
  }
}

function fourCCToInt32 (value) {
  return value.charCodeAt(0) +
    (value.charCodeAt(1) << 8) +
    (value.charCodeAt(2) << 16) +
    (value.charCodeAt(3) << 24)
}

function int32ToFourCC (value) {
  return String.fromCharCode(
    value & 0xff,
    (value >> 8) & 0xff,
    (value >> 16) & 0xff,
    (value >> 24) & 0xff
  )
}
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Pbr; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_pbr_pbr_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(87);
/* harmony import */ var shaders_pbr_pbr_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_pbr_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_pbr_pbr_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88);
/* harmony import */ var shaders_pbr_pbr_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_pbr_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_pbr_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var shaders_pbr_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_pbr_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27);
/* harmony import */ var shaders_pbr_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_11__);












const nrRows = 7;
const nrColumns = 7;
const spacing = .8;
class Pbr extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension('OES_standard_derivatives');
    this.prg = this.compile(shaders_pbr_pbr_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_pbr_pbr_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.mapPrg = this.compile(shaders_pbr_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_pbr_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      uv
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_8__["Sphere"])(256, 256, .25);
    let sphere = new libs_Mesh__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]();
    sphere.bufferVertex(pos);
    sphere.bufferIndices(index);
    sphere.bufferNormal(normal);
    sphere.bufferTexCoord(uv);
    this.sphere = sphere;
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LEQUAL);
  }

  uniform() {
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].create());
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].create());
    let eyeDirection = [];
    let camUpDirection = [];
    if (this.params.map === 'none') gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* vec3 */ "d"].transformQuat(eyeDirection, [0.0, 0.0, 5.0], this.rotateQ);else gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* vec3 */ "d"].transformQuat(eyeDirection, [0.0, 0.0, 1.0], this.rotateQ);
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* vec3 */ "d"].transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].lookAt(vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].multiply(this.tmpMatrix, pMatrix, vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearColor(0.3, 0.3, 0.3, 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.eyeDirection,
      lambertDiffuse: this.params.lambertDiffuse
    };

    if (this.params.map === 'none') {
      this.prg.use();
      this.prg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        albedo: [.5, .0, .0],
        ao: 1.
      }));
      this.sphere.bind(this.prg, ['position', 'normal']);

      for (let row = 0; row < nrRows; row++) {
        this.prg.style({
          metallic: row / nrRows
        });

        for (let col = 0; col < nrColumns; col++) {
          gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].translate(mMatrix, gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "a"].create(), [(col - nrColumns / 2) * spacing, (row - nrRows / 2) * spacing, 0.0]); // mat4.translate(mMatrix, mMatrix, [1, 0, 0])

          this.prg.style({
            roughness: clamp(col / nrColumns, 0.05, 1.),
            mMatrix
          });
          this.sphere.draw();
        }
      }
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      this.mapPrg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        mMatrix: mMatrix,
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4
      }));
      this.sphere.bind(this.mapPrg);
      this.sphere.draw();
    }
  }

}

function clamp(value, min, max) {
  if (min > max) {
    return clamp(value, max, min);
  }

  if (value < min) return min;else if (value > max) return max;else return value;
}module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying   vec3 vNormal;\nvarying vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"/* unused harmony export color */
/* unused harmony export controllers */
/* unused harmony export dom */
/* unused harmony export gui */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GUI$1; });
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (!this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function ()        {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function ()        {
      dom.addClass(this, 'drag').bind(window, 'touchend', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRowName) {
          titleRowName.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    params.closed = false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var _titleRowName = document.createTextNode(params.name);
    dom.addClass(_titleRowName, 'controller-name');
    var titleRow = addRow(_this, _titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller,                                   {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};


/* unused harmony default export */ var _unused_webpack_default_export = (index);
//# sourceMappingURL=dat.gui.module.js.map
module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout   vec3 vNormal;\nout vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 6.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color =  ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 vNormal;\nout vec3 WorldPos;\nout vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nin vec2 TexCoords;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 WorldPos;\nout vec2 vUv;\nvoid main(void){\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  WorldPos = pos.xyz;\n  vUv = texCoord;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D equirectangularMap;\nin vec3 WorldPos;\nin vec2 vUv;\nout vec4 outColor;\n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec2 SampleSphericalMap(vec3 v)\n{\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y)); // [-PI/2,PI/2]\n    uv *= invAtan; //[-.5,.5]\n    uv += 0.5;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = SampleSphericalMap(normalize(WorldPos));\n    vec3 color = textureLod(equirectangularMap, uv, 0.).rgb;\n\n    outColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(WorldPos,1.);\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nuniform   mat4 mMatrix;\nuniform   mat4 vMatrix;\nuniform   mat4 pMatrix;\n\nout vec3 WorldPos;\n\nvoid main()\n{\n  mat4 rotView = mat4(mat3(vMatrix)); // remove translation from the view matrix\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tvec4 clipPos    = pMatrix * rotView * pos;\n\tgl_Position = clipPos.xyww; // 设置深度测试的z为1，这样只会在没有遮挡时渲染skybox，节省性能\n\n  WorldPos = pos.xyz;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform samplerCube environmentMap;\nin vec3 WorldPos;\nout vec4 outColor;\nvoid main()\n{\n    vec3 envColor = textureLod(environmentMap, WorldPos, 0.).rgb;\n\n    // HDR tonemap and gamma correct\n    envColor = envColor / (envColor + vec3(1.0));\n    envColor = pow(envColor, vec3(1.0/2.2));\n\n    outColor = vec4(envColor, 1.0);\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\n\nin vec3 position;\nin vec2 texCoord;\nout vec2 TexCoords;\n\nvoid main(void) {\n  gl_Position = vec4(position, 1.);\n  TexCoords = texCoord;\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec2 FragColor;\nin vec2 TexCoords;\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits)\n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t// from spherical coordinates to cartesian coordinates - halfway vector\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\n\t// from tangent-space H vector to world-space sample vector\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    // note that we use a different k for IBL\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 1024u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the\n        // preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec2 integratedBRDF = IntegrateBRDF(TexCoords.x, TexCoords.y);\n    FragColor = integratedBRDF;\n    // FragColor = vec4(integratedBRDF,0. ,1.);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PbrModel; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_pbr_model_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93);
/* harmony import */ var shaders_pbr_model_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_model_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_pbr_model_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(94);
/* harmony import */ var shaders_pbr_model_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_model_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_pbr_model_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(95);
/* harmony import */ var shaders_pbr_model_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_model_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_pbr_model_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(96);
/* harmony import */ var shaders_pbr_model_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_model_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(14);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(16);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(17);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(18);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(19);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(20);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var utils_HDRParser__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(10);
/* harmony import */ var libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(13);
/* harmony import */ var libs_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(21);





















/* irradianceMap, prefilterMap 用cmftStudio生成

*/

class PbrModel extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension('OES_texture_float_linear'); // Even WebGL2 requires OES_texture_float_linear

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension("EXT_color_buffer_float"); // // gl.getExtension('OES_texture_half_float')
    // gl.getExtension('OES_texture_half_float_linear')
    // gl.getExtension('EXT_shader_texture_lod')

    this.prg = this.compile(shaders_pbr_model_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_pbr_model_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.mapPrg = this.compile(shaders_pbr_model_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_pbr_model_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.cubePrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
    this.skyboxPrg = this.compile(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default.a, shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default.a);
    this.brdfPrg = this.compile(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12___default.a, shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13___default.a);
  }

  attrib() {
    let cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]();
    cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_14__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.cube = cube;
    let quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]();
    let quadData = [-1.0, 1.0, 0.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 0.0, 1.0, 0.0];
    quad.bufferData(quadData, ['position', 'texCoord'], [3, 2]);
    this.quad = quad;
    this.orb = new libs_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]().parseObj(getAssets.orb);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNPACK_FLIP_Y_WEBGL, true);
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].create());
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].create());
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].create());
    let vpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(90), 1., .1, 100);
    const CAMERA_SETTINGS = [[gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(-1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, 1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, -1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, -1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, 1), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, 0, -1), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "d"].fromValues(0, -1, 0)]];
    let hdrInfo = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.equirectangular);
    console.log('hdrInfo', hdrInfo);
    this.hdrTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.hdrTexture.id);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA32F, hdrInfo.shape[0], hdrInfo.shape[1], 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT, hdrInfo.data);
    this.hdrTexture.clamp(); // cubemap

    let cubemapTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, cubemapTexture);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA32F, 512, 512, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR_MIPMAP_LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    this.cubemapTexture = cubemapTexture;
    this.cubePrg.use();
    this.hdrTexture.bind(0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, 512, 512);
    let captureFrameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createFramebuffer();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, captureFrameBuffer);

    for (let i = 0; i < 6; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].multiply(vpMatrix, pMatrix, vMatrix);
      this.cubePrg.style({
        equirectangularMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.cubemapTexture, 0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
      this.cube.bind(this.cubePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER);

    if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER_COMPLETE) {
      console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null); //brdf lookup texture

    this.brdfLUTTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RG).fromData(512, 512, null, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RG32F);
    this.brdfLUTTexture.bind();
    this.brdfLUTTexture.clamp();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, captureFrameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.brdfLUTTexture.id, 0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, 512, 512);
    this.brdfPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.quad.bind(this.brdfPrg);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TRIANGLE_STRIP);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null);
    let irr_posx = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradiancePosX);
    let irr_negx = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradianceNegX);
    let irr_posy = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradiancePosY);
    let irr_negy = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradianceNegY);
    let irr_posz = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradiancePosZ);
    let irr_negz = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradianceNegZ);
    this.irradianceMap = new libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"]([irr_posx, irr_negx, irr_posy, irr_negy, irr_posz, irr_negz]);
    this.prefilterMap = libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"].parseDDS(getAssets.radiance);
  }

  uniform() {
    this.vMatrix = this.camera.viewMatrix;
    this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].perspective(this.pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].multiply(this.tmpMatrix, this.pMatrix, this.vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      roughness: 0.2,
      metallic: 6 / 7,
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder = this.gui.addFolder('material param');
    folder.add(this.params, 'roughness', 0.05, 1).step(0.01);
    folder.add(this.params, 'metallic', 0, 6 / 7).step(0.01);
    folder.open();
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearColor(0.3, 0.3, 0.3, 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.camera.cameraPos,
      lambertDiffuse: this.params.lambertDiffuse
    };

    if (this.params.map === 'none') {
      this.prg.use();
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.irradianceMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE1);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.prefilterMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE2);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.brdfLUTTexture.id);
      this.prg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        mMatrix,
        roughness: this.params.roughness,
        metallic: this.params.metallic,
        albedo: [.5, .0, .0],
        ao: 1.,
        irradianceMap: 0,
        prefilterMap: 1,
        brdfLUT: 2
      }));

      for (let i = 0; i < this.orb.length; i++) {
        this.orb[i].bind(this.prg, ['position', 'normal']);
        this.orb[i].draw();
      }
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE5);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.irradianceMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE6);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.prefilterMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE7);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.brdfLUTTexture);
      gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [2, 2, 2]);
      this.mapPrg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        mMatrix,
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4,
        irradianceMap: 5,
        prefilterMap: 6,
        brdfLUT: 7
      }));
      this.sphere.bind(this.mapPrg);
      this.sphere.draw();
    } // this.skyboxPrg.use()
    // gl.activeTexture(gl.TEXTURE0)
    // gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.cubemapTexture)
    // this.skyboxPrg.style({
    //   environmentMap: 0,
    //   vMatrix: this.vMatrix,
    //   pMatrix: this.pMatrix,
    //   mMatrix: mat4.identity(mat4.create()),
    // })
    // this.cube.bind(this.skyboxPrg, ['position'])
    // this.cube.draw()

  }

}

function clamp(value, min, max) {
  if (min > max) {
    return clamp(value, max, min);
  }

  if (value < min) return min;else if (value > max) return max;else return value;
}module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout   vec3 vNormal;\nout vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 6.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color =  ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 vNormal;\nout vec3 WorldPos;\nout vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nin vec2 TexCoords;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
// ObjLoader.js
// from https: //github.com/yiwenl/alfrid






class ObjLoader {
  constructor() {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "object", null);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "objectList", []);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "meshes", []);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "materialLibraries", []);
  }

  load(url, callback, drawType = 4) {
    this._drawType = drawType;
    super.load(url, callback);
  }

  _onLoaded() {
    this.parseObj(this._req.response);
  }

  parseObj(objStr, materials) {
    this.materials = materials;
    const lines = objStr.split('\n'); // 实际buffer的数据

    const positions = [];
    const coords = [];
    const finalNormals = [];
    const indices = []; // add face 调用，把暂时的vertices，normals，uvs根据解析来的indices填充到实际buffer的数据里,

    const vertices = [];
    const normals = [];
    const uvs = [];
    let result; // o object_name | g group_name
    //ignore mtl

    const objectPattern = /^[og]\s*(.+)?/; // mtllib file_reference

    const material_library_pattern = /^mtllib /; // usemtl material_name

    const material_use_pattern = /^usemtl /; // v float float float

    const vertexPattern = /v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/; // vn float float float

    const normalPattern = /vn( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/; // vt float float

    const uvPattern = /vt( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/; // f vertex vertex vertex ...

    const facePattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/; // f vertex/uv vertex/uv vertex/uv ...

    const facePattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/; // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...

    const facePattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/; // f vertex//normal vertex//normal vertex//normal ...

    const facePattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/;

    function parseVertexIndex(value) {
      const index = parseInt(value);
      return (index >= 0 ? index - 1 : index + vertices.length / 3) * 3;
    }

    function parseNormalIndex(value) {
      const index = parseInt(value);
      return (index >= 0 ? index - 1 : index + normals.length / 3) * 3;
    }

    function parseUVIndex(value) {
      const index = parseInt(value);
      return (index >= 0 ? index - 1 : index + uvs.length / 2) * 2;
    }

    const addVertex = (a, b, c) => {
      // 1个face 3个index a,b,c,顶点是依次输入的，所以没用重用，index是连续的，没有重用
      this.object.positions.push([vertices[a], vertices[a + 1], vertices[a + 2]]);
      this.object.positions.push([vertices[b], vertices[b + 1], vertices[b + 2]]);
      this.object.positions.push([vertices[c], vertices[c + 1], vertices[c + 2]]);
      this.object.indices.push(this.object.count * 3 + 0);
      this.object.indices.push(this.object.count * 3 + 1);
      this.object.indices.push(this.object.count * 3 + 2);
      this.object.count++;
    };

    const addUV = (a, b, c) => {
      this.object.coords.push([uvs[a], uvs[a + 1]]);
      this.object.coords.push([uvs[b], uvs[b + 1]]);
      this.object.coords.push([uvs[c], uvs[c + 1]]);
    };

    const addNormal = (a, b, c) => {
      this.object.finalNormals.push([normals[a], normals[a + 1], normals[a + 2]]);
      this.object.finalNormals.push([normals[b], normals[b + 1], normals[b + 2]]);
      this.object.finalNormals.push([normals[c], normals[c + 1], normals[c + 2]]);
    }; // 定义之前vertex lists里的相关索引，vertex indices,uv indices,normal indices etc.
    // 使用整个obj文件的顶点为索引，即不区分是哪个对象，f从1开始，直到全部对象顶点的结尾
    // 实际buffer数据在此添加


    function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
      let ia = parseVertexIndex(a);
      let ib = parseVertexIndex(b);
      let ic = parseVertexIndex(c);
      let id;

      if (d === undefined) {
        addVertex(ia, ib, ic);
      } else {
        id = parseVertexIndex(d);
        addVertex(ia, ib, id);
        addVertex(ib, ic, id);
      }

      if (ua !== undefined) {
        ia = parseUVIndex(ua);
        ib = parseUVIndex(ub);
        ic = parseUVIndex(uc);

        if (d === undefined) {
          addUV(ia, ib, ic);
        } else {
          id = parseUVIndex(ud);
          addUV(ia, ib, id);
          addUV(ib, ic, id);
        }
      }

      if (na !== undefined) {
        ia = parseNormalIndex(na);
        ib = parseNormalIndex(nb);
        ic = parseNormalIndex(nc);

        if (d === undefined) {
          addNormal(ia, ib, ic);
        } else {
          id = parseNormalIndex(nd);
          addNormal(ia, ib, id);
          addNormal(ib, ic, id);
        }
      }
    }

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      line = line.trim();

      if (line.length === 0 || line.charAt(0) === '#') {
        continue;
      }

      let lineFirstChar = line.charAt(0);

      if (material_library_pattern.test(line)) {
        // mtl file
        this.materialLibraries.push(line.substring(7).trim());
      } else if (material_use_pattern.test(line)) {
        this._startMaterial(line.substring(7).trim(), this.materialLibraries);
      } else if ((result = objectPattern.exec(line)) !== null) {
        // o object_name
        // or
        // g group_name
        // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
        // var name = result[ 0 ].substr( 1 ).trim();
        let name = (" " + result[0].substr(1).trim()).substr(1);

        this._startObject(name);
      } else if ((result = vertexPattern.exec(line)) !== null) {
        vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
      } else if ((result = normalPattern.exec(line)) !== null) {
        normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
      } else if ((result = uvPattern.exec(line)) !== null) {
        uvs.push(parseFloat(result[1]), parseFloat(result[2]));
      } else if ((result = facePattern1.exec(line)) !== null) {
        addFace(result[1], result[2], result[3], result[4]);
      } else if ((result = facePattern2.exec(line)) !== null) {
        addFace(result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
      } else if ((result = facePattern3.exec(line)) !== null) {
        addFace(result[2], result[6], result[10], result[14], result[3], result[7], result[11], result[15], result[4], result[8], result[12], result[16]);
      } else if ((result = facePattern4.exec(line)) !== null) {
        addFace(result[2], result[5], result[8], result[11], undefined, undefined, undefined, undefined, result[3], result[6], result[9], result[12]);
      }
    }

    return this._generateMeshes();
  }

  _startObject(name) {
    if (has(this.objectList, 'name', name) !== -1) return; // console.log('start object', name)

    this.object = {
      name,
      positions: [],
      coords: [],
      finalNormals: [],
      indices: [],
      count: 0 // index

    };
    this.objectList.push(this.object);
  }

  _startMaterial(name, lib) {
    let material = {
      name,
      mtlLib: lib[lib.length - 1]
    };
    this.object.material = material;
  }

  _generateMeshes() {
    let o;

    for (let i = 0; i < this.objectList.length; i++) {
      o = {
        positions: this.objectList[i].positions,
        coords: this.objectList[i].coords,
        indices: this.objectList[i].indices,
        normals: this.objectList[i].finalNormals,
        name: this.objectList[i].name,
        material: this.materials ? Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.materials[this.objectList[i].material.name], {
          mtlLib: this.objectList[i].material.mtlLib
        }) : this.objectList[i].material
      };
      const hasNormals = o.normals.length > 0;
      const hasUVs = o.coords.length > 0;
      let mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](this._drawType, o.name, o.material);
      mesh.bufferVertex(o.positions);

      if (hasUVs) {
        mesh.bufferTexCoord(o.coords);
      }

      mesh.bufferIndices(o.indices);

      if (hasNormals) {
        mesh.bufferNormal(o.normals);
      }

      if (this._callback) {
        this._callback(mesh, o);
      }

      this.meshes.push(mesh);
    }

    return this.meshes;
  }

}

ObjLoader.parse = function (objStr) {
  const loader = new ObjLoader();
  return loader.parseObj(objStr);
};

function has(arr, key, value) {
  // array child object has key-value
  if (!arr || !arr.length) return -1;

  for (let i = 0; i < arr.length; i++) {
    if (arr[i][key] === value) return i;
  }

  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (ObjLoader);__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IblFinal; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_ibl_final_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97);
/* harmony import */ var shaders_ibl_final_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_ibl_final_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98);
/* harmony import */ var shaders_ibl_final_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_ibl_final_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(125);
/* harmony import */ var shaders_ibl_final_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_ibl_final_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(126);
/* harmony import */ var shaders_ibl_final_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(14);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(16);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(17);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(18);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var shaders_ibl_final_prefilter_frag__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(99);
/* harmony import */ var shaders_ibl_final_prefilter_frag__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_prefilter_frag__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(19);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(20);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var shaders_ibl_final_irradiance_convolution_frag__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(100);
/* harmony import */ var shaders_ibl_final_irradiance_convolution_frag__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_irradiance_convolution_frag__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(7);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(12);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(libs_vao__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var utils_HDRParser__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(10);























class IblFinal extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension('OES_texture_float_linear'); // Even WebGL2 requires OES_texture_float_linear

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension("EXT_color_buffer_float"); // // gl.getExtension('OES_texture_half_float')
    // gl.getExtension('OES_texture_half_float_linear')
    // gl.getExtension('EXT_shader_texture_lod')

    this.prg = this.compile(shaders_ibl_final_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_ibl_final_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default.a); // this.mapPrg = this.compile(mapVs, mapFs)

    this.cubePrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
    this.skyboxPrg = this.compile(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default.a, shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default.a);
    this.prefilterPrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_prefilter_frag__WEBPACK_IMPORTED_MODULE_12___default.a);
    this.brdfPrg = this.compile(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_13___default.a, shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_14___default.a);
    this.irradiancePrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_irradiance_convolution_frag__WEBPACK_IMPORTED_MODULE_15___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      uv
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_18__["Sphere"])(256, 256, .15);
    let sphere = new libs_Mesh__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]();
    sphere.bufferVertex(pos);
    sphere.bufferIndices(index);
    sphere.bufferNormal(normal);
    sphere.bufferTexCoord(uv);
    this.sphere = sphere;
    let cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]();
    cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_18__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.cube = cube;
    let planeVertices = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, 3.0, 0.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, -3.0, 1.0, 1.0];
    this.planeBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_16__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(planeVertices));
    this.planeBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.planeBuffer.attrib('texCoord', 2, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.planeVao = new libs_vao__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    this.planeVao.setup(this.cubePrg, [this.planeBuffer]);
    let quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]();
    let quadData = [-1.0, 1.0, 0.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 0.0, 1.0, 0.0];
    quad.bufferData(quadData, ['position', 'texCoord'], [3, 2]);
    this.quad = quad;
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNPACK_FLIP_Y_WEBGL, true);
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].create());
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].create());
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].create());
    let vpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(90), 1., .1, 100);
    const CAMERA_SETTINGS = [[gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(-1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, 1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, -1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, -1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, 1), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, 0, -1), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].fromValues(0, -1, 0)]];
    let hdrInfo = Object(utils_HDRParser__WEBPACK_IMPORTED_MODULE_22__[/* default */ "a"])(getAssets.equirectangular);
    console.log('hdrInfo', hdrInfo);
    this.hdrTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.hdrTexture.id);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA32F, hdrInfo.shape[0], hdrInfo.shape[1], 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT, hdrInfo.data);
    this.hdrTexture.clamp(); // cubemap

    let cubemapTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, cubemapTexture);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA32F, 512, 512, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR_MIPMAP_LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    this.cubemapTexture = cubemapTexture;
    this.cubePrg.use();
    this.hdrTexture.bind(0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, 512, 512);
    let captureFrameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createFramebuffer();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, captureFrameBuffer);

    for (let i = 0; i < 6; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].multiply(vpMatrix, pMatrix, vMatrix);
      this.cubePrg.style({
        equirectangularMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.cubemapTexture, 0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
      this.cube.bind(this.cubePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].generateMipmap(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP); // has to be placed here，to generate each face data

    const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER);

    if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER_COMPLETE) {
      console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null); // irradiance map

    let irradianceMap = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, irradianceMap);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA32F, 32, 32, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    this.irradianceMap = irradianceMap;
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, captureFrameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, 32, 32);
    this.irradiancePrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.cubemapTexture); // 放在这，防止new cubeframebuffer时绑定了tetxure0到null

    for (let i = 0; i < 6; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].multiply(vpMatrix, pMatrix, vMatrix);
      this.irradiancePrg.style({
        environmentMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.irradianceMap, 0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
      this.cube.bind(this.irradiancePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null); // prefilter map

    this.prefilterMap = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createTexture();
    let prefilterSize = 128;
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.prefilterMap);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA32F, prefilterSize, prefilterSize, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR_MIPMAP_LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].generateMipmap(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP);
    this.prefilterPrg.use();
    let maxMipLevels = 5;
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.cubemapTexture); // 放在这，防止new cubeframebuffer时绑定了tetxure0到null

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, captureFrameBuffer);

    for (let mip = 0; mip < maxMipLevels; mip++) {
      let mipWidth = 128 * Math.pow(.5, mip);
      let mipHeight = mipWidth;
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, mipWidth, mipHeight);
      let roughness = mip / (maxMipLevels - 1);

      for (let i = 0; i < 6; i++) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].multiply(vpMatrix, pMatrix, vMatrix);
        this.prefilterPrg.style({
          environmentMap: 0,
          vpMatrix,
          mMatrix: mMatrix,
          roughness
        });
        libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.prefilterMap, mip);
        libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
        this.cube.bind(this.prefilterPrg, ['position', 'texCoord']);
        this.cube.draw();
      }
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null); //brdf lookup texture

    this.brdfLUTTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.brdfLUTTexture);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RG32F, 512, 512, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RG, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, captureFrameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.brdfLUTTexture, 0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, 512, 512);
    this.brdfPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.quad.bind(this.brdfPrg);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TRIANGLE_STRIP);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null);
  }

  uniform() {
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].create());
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].create());
    let eyeDirection = [];
    let camUpDirection = [];
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].transformQuat(eyeDirection, [0.0, 0.0, 1.0], this.rotateQ);
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "d"].transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].lookAt(vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].multiply(this.tmpMatrix, pMatrix, vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      roughness: 0.2,
      metallic: 6 / 7,
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder = this.gui.addFolder('material param');
    folder.add(this.params, 'roughness', 0.05, 1).step(0.01);
    folder.add(this.params, 'metallic', 0, 6 / 7).step(0.01);
    folder.open();
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].viewport(0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearColor(0.3, 0.3, 0.3, 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "a"].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.eyeDirection,
      lambertDiffuse: this.params.lambertDiffuse,
      irradianceMap: 0
    };

    if (this.params.map === 'none') {
      this.prg.use();
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.irradianceMap);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE1);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.prefilterMap);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE2);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.brdfLUTTexture);
      this.prg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        albedo: [.5, .0, .0],
        roughness: this.params.roughness,
        metallic: this.params.metallic,
        ao: 1.,
        irradianceMap: 0,
        prefilterMap: 1,
        brdfLUT: 2
      }));
      this.sphere.bind(this.prg, ['position', 'normal']);
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      this.mapPrg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4
      }));
      this.sphere.bind(this.mapPrg);
    }

    this.sphere.draw(); // this.cubePrg.use()
    // this.hdrTexture.bind(0)
    // this.cubePrg.style({
    //   equirectangularMap: 0,
    //   vpMatrix: this.tmpMatrix,
    //   mMatrix: mMatrix
    // })
    // this.cube.bind(this.cubePrg, ['position', 'texCoord'])
    // this.cube.draw()
    // this.planeVao.bind()
    // this.planeBuffer.drawTriangles()
    // this.planeVao.unbind()

    this.skyboxPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_CUBE_MAP, this.prefilterMap);
    this.skyboxPrg.style({
      environmentMap: 0,
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix
    });
    this.cube.bind(this.skyboxPrg, ['position']);
    this.cube.draw(); // brdf out为vec2，设置为vec4时显示正常
    // this.brdfPrg.use()
    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    // this.quad.bind(this.brdfPrg)
    // this.quad.draw(gl.TRIANGLE_STRIP)
  }

}module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout   vec3 vNormal;\nout vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 vNormal;\nout vec3 WorldPos;\nout vec2 TexCoords;\n\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n// material map\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nin vec2 TexCoords;\n\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\nin vec3 WorldPos;\n\nuniform samplerCube environmentMap;\nuniform float roughness;\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits)\n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t// from spherical coordinates to cartesian coordinates - halfway vector\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\n\t// from tangent-space H vector to world-space sample vector\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec3 N = normalize(WorldPos);\n\n    // make the simplyfying assumption that V equals R equals the normal\n    vec3 R = N;\n    vec3 V = R;\n\n    const uint SAMPLE_COUNT = 1024u;\n    vec3 prefilteredColor = vec3(0.0);\n    float totalWeight = 0.0;\n\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        if(NdotL > 0.0)\n        {\n            // sample from the environment's mip level based on roughness/pdf\n            float D   = DistributionGGX(N, H, roughness);\n            float NdotH = max(dot(N, H), 0.0);\n            float HdotV = max(dot(H, V), 0.0);\n            float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;\n\n            float resolution = 512.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n\n            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel);\n\n            prefilteredColor += textureLod(environmentMap, L, mipLevel).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n\n    prefilteredColor = prefilteredColor / totalWeight;\n\n    FragColor = vec4(prefilteredColor, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin vec3 WorldPos;\nout vec4 outColor;\nuniform samplerCube environmentMap;\n\nconst float PI = 3.14159265359;\n\nvoid main()\n{\n\t// The world vector acts as the normal of a tangent surface\n    // from the origin, aligned to WorldPos. Given this normal, calculate all\n    // incoming radiance of the environment. The result of this radiance\n    // is the radiance of light coming from -Normal direction, which is what\n    // we use in the PBR shader to sample irradiance.\n    vec3 N = normalize(WorldPos);\n\n    vec3 irradiance = vec3(0.0);\n\n    // tangent space calculation from origin point\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up            = cross(N, right);\n\n    const float sampleDelta = 0.025;\n    float nrSamples = 0.0;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\n\n            irradiance += texture(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n    outColor = vec4(irradiance, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mask; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_base_vert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(101);
/* harmony import */ var shaders_base_vert__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_base_vert__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_base_frag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(102);
/* harmony import */ var shaders_base_frag__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_base_frag__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(libs_vao__WEBPACK_IMPORTED_MODULE_8__);









class Mask extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_base_vert__WEBPACK_IMPORTED_MODULE_5___default.a, shaders_base_frag__WEBPACK_IMPORTED_MODULE_6___default.a); // flip texture

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNPACK_FLIP_Y_WEBGL, true);
  }

  attrib() {
    let planeVertices = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, 3.0, 0.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, -3.0, 1.0, 1.0];
    this.planeBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], new Float32Array(planeVertices));
    this.planeBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.planeBuffer.attrib('texcoord', 2, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FLOAT);
    this.planeVao = new libs_vao__WEBPACK_IMPORTED_MODULE_8___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    this.planeVao.setup(this.prg, [this.planeBuffer]);
    this.texture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_4___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA);
    let img = getAssets.splash;
    this.texture.fromImage(img);
    this.texture.bind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].NEAREST_MIPMAP_NEAREST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].generateMipmap(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, null);
  }

  prepare() {
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].create());
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].create());
    this.mvpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].lookAt(vMatrix, [0.0, 0.0, 4.0], [0, 0, 0.0], [0, 1, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientHeight, .1, 1000);
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].multiply(this.tmpMatrix, pMatrix, vMatrix);
  }

  uniform() {
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].create());
    this.count++;
    let rad = this.count % 360 * Math.PI / 180;
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].rotate(mMatrix, mMatrix, rad, [0, 1, 1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_7__[/* mat4 */ "a"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
    this.prg.use();
    this.texture.bind(0);
    this.prg.style({
      mvpMatrix: this.mvpMatrix,
      tex: 0
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT);
    this.prg.use();
    this.planeVao.bind();
    this.planeBuffer.drawTriangles();
    this.planeVao.unbind();
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texcoord;\nuniform   mat4 mvpMatrix;\nout   vec2 TexCoords;\n\nvoid main(void){\n    TexCoords = texcoord;\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin   vec4 TexCoords;\nout vec4 outColor;\n\n\nvoid main(void){\n\n    outColor = texture(tex, TexCoords);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DeferredShading; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_deferred_shading_finalQuad_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(103);
/* harmony import */ var shaders_deferred_shading_finalQuad_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_finalQuad_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_deferred_shading_gBuffer_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(104);
/* harmony import */ var shaders_deferred_shading_gBuffer_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_gBuffer_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_deferred_shading_gBuffer_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(105);
/* harmony import */ var shaders_deferred_shading_gBuffer_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_gBuffer_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_deferred_shading_fbo_debug_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(106);
/* harmony import */ var shaders_deferred_shading_fbo_debug_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_fbo_debug_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_deferred_shading_fbo_debug_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(107);
/* harmony import */ var shaders_deferred_shading_fbo_debug_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_fbo_debug_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(25);
/* harmony import */ var shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(24);
/* harmony import */ var shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(4);
/* harmony import */ var libs_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(21);
/* harmony import */ var libs_loaders_MTLLoader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(28);

















const offset = 10.;
const objectPositions = [[-offset, -offset, -offset], [0.0, -offset, -offset], [offset, -offset, -offset], [-offset, -offset, 0.0], [0.0, -offset, 0.0], [offset, -offset, 0.0], [-offset, -offset, offset], [0.0, -offset, offset], [offset, -offset, offset]];
const NR_LIGHTS = 32;
const lightPositions = [];
const lightColors = [];

for (let i = 0; i < NR_LIGHTS; i++) {
  // calculate slightly random offsets
  let xPos = Math.random() * 33 - 16.0;
  let yPos = Math.random() * 10 - 2.0;
  let zPos = Math.random() * 20 - 4.0;
  lightPositions.push([xPos, yPos, zPos]); // lightPositions.push()
  // also calculate random color

  let rColor = Math.random() / 2.0 + 0.5; // between 0.5 and 1.0

  let gColor = Math.random() / 2.0 + 0.5; // between 0.5 and 1.0

  let bColor = Math.random() / 2.0 + 0.5; // between 0.5 and 1.0

  lightColors.push([rColor, gColor, bColor]);
}

class DeferredShading extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    // gl.getExtension('OES_texture_float_linear') // Even WebGL2 requires OES_texture_float_linear
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension("EXT_color_buffer_float"); // gl.getExtension('OES_texture_half_float')

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension('OES_texture_half_float_linear'); // gl.getExtension('EXT_shader_texture_lod')

    this.prg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_deferred_shading_finalQuad_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.gBufferPrg = this.compile(shaders_deferred_shading_gBuffer_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_deferred_shading_gBuffer_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.fboPrg = this.compile(shaders_deferred_shading_fbo_debug_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_deferred_shading_fbo_debug_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
    this.lampPrg = this.compile(shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_10___default.a, shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_11___default.a);
  }

  attrib() {
    var cube, quad, materials;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"]();
          cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_12__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
          this.cube = cube;
          quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"]();
          quad.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_12__["QuadData"], ['position', 'texCoord'], [3, 2]);
          this.quad = quad;
          _context.next = 8;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(new libs_loaders_MTLLoader__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]('nanosuit.mtl', './assets/models/nanosuit').parse(getAssets.nanosuitMTL));

        case 8:
          materials = _context.sent;
          this.nanosuit = new libs_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"]().parseObj(getAssets.nanosuit, materials);

        case 10:
        case "end":
          return _context.stop();
      }
    }, null, this);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearColor(0., 0., 0., 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LEQUAL); //position, normal, AlbedoSpec(diffuse, specular indensity)

    this.mrt = framebufferMRT(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height, ['16f', '16f', 'rgba']); // execute once

    this.camera.target = [0, -1., 0];
    this.camera.offset = [1, 3., 0];
    this.camera.radius = 18;
  }

  uniform() {
    this.vMatrix = this.camera.viewMatrix;
    this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].perspective(this.pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientHeight, .1, 100);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, this.mrt.frameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.gBufferPrg.use();

    if (this.nanosuit) {
      // loaded
      this.gBufferPrg.style({
        vMatrix: this.vMatrix,
        pMatrix: this.pMatrix
      });

      for (let i = 0; i < objectPositions.length; i++) {
        let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].create());
        gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].translate(mMatrix, mMatrix, objectPositions[i]);
        this.gBufferPrg.style({
          mMatrix
        });

        for (let i = 0; i < this.nanosuit.length; i++) {
          this.nanosuit[i].bind(this.gBufferPrg, ['position', 'normal', 'texCoord']);
          this.nanosuit[i].draw();
        }
      }
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT); // gl.activeTexture(gl.TEXTURE0)
    // gl.bindTexture(gl.TEXTURE_2D, this.mrt.texture[1])
    // this.fboPrg.use()
    // this.fboPrg.style({
    //   fboAttachment: 0
    // })
    // this.quad.bind(this.fboPrg, ['position', 'texCoord'])
    // this.quad.draw(gl.TRIANGLE_STRIP)

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.mrt.texture[0]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE1);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.mrt.texture[1]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE2);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.mrt.texture[2]);
    this.prg.use();
    this.prg.style({
      gPosition: 0,
      gNormal: 1,
      gAlbedoSpec: 2,
      viewPos: this.camera.cameraPos
    }, true);

    for (let i = 0; i < lightPositions.length; i++) {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].uniform3fv(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getUniformLocation(this.prg.program, [`lights[${i}].Position`]), lightPositions[i]);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].uniform3fv(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getUniformLocation(this.prg.program, [`lights[${i}].Color`]), lightColors[i]);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].uniform1f(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getUniformLocation(this.prg.program, [`lights[${i}].Linear`]), .1);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].uniform1f(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getUniformLocation(this.prg.program, [`lights[${i}].Quadratic`]), .12);
    }

    this.quad.bind(this.prg, ['position', 'texCoord']);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TRIANGLE_STRIP); // copy depth

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].READ_FRAMEBUFFER, this.mrt.frameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DRAW_FRAMEBUFFER, null); // write to default framebuffer
    // blit to default framebuffer. Note that this may or may not work as the internal formats of both the FBO and default framebuffer have to match.
    // the internal formats are implementation defined. This works on all of my systems, but if it doesn't on yours you'll likely have to write to the
    // depth buffer in another shader stage (or somehow see to match the default framebuffer's internal format with the FBO's internal format).

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].blitFramebuffer(0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height, 0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].NEAREST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null); // render light cubes

    this.lampPrg.use();
    this.lampPrg.style({
      vMatrix: this.vMatrix,
      pMatrix: this.pMatrix
    });

    for (let i = 0; i < lightPositions.length; i++) {
      let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].create());
      gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].translate(mMatrix, mMatrix, lightPositions[i]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_13__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [.3, .3, .3]);
      this.lampPrg.style({
        mMatrix,
        lightColor: lightColors[i]
      });
      this.cube.bind(this.lampPrg, ['position']);
      this.cube.draw();
    }
  }

}

function framebufferMRT(width, height, type) {
  let frameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createFramebuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, frameBuffer);
  let fTexture = [];
  const bufferList = [];

  for (let i = 0; i < type.length; ++i) {
    fTexture[i] = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, fTexture[i]);

    if (type[i] === '16f') {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA16F, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].HALF_FLOAT, null);
    } else {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNSIGNED_BYTE, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0 + i, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, fTexture[i], 0);
    bufferList.push(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0 + i);
  }

  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].drawBuffers(bufferList); // 指定渲染目标

  const depthRenderBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createRenderbuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, depthRenderBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].renderbufferStorage(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH24_STENCIL8, width, height);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_ATTACHMENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, depthRenderBuffer);
  const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER);

  if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER_COMPLETE) {
    console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
  }

  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null);
  return {
    frameBuffer: frameBuffer,
    depthBuffer: depthRenderBuffer,
    texture: fTexture
  };
}
/*
while (...) // 游戏循环
{
  // 1. 几何处理阶段：渲染所有的几何/颜色数据到G缓冲
  glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  gBufferShader.Use();
  for (Object obj: Objects) {
    ConfigureShaderTransformsAndUniforms();
    obj.Draw();
  }
  // 2. 光照处理阶段：使用G缓冲计算场景的光照
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  glClear(GL_COLOR_BUFFER_BIT);
  lightingPassShader.Use();
  BindAllGBufferTextures();
  SetLightingUniforms();
  RenderQuad();
}

*/module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\n\nout vec2 TexCoords;\nvoid main(){\n  TexCoords = texCoord;\n  gl_Position = vec4(position, 1.);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nout vec4 outColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedoSpec;\n\nstruct Light {\n    vec3 Position;\n    vec3 Color;\n\n    float Linear;\n    float Quadratic;\n};\nconst int NR_LIGHTS = 32;\nuniform Light lights[NR_LIGHTS];\nuniform vec3 viewPos;\n\nvoid main() {\n    vec3 FragPos = texture(gPosition, TexCoords).rgb;\n    vec3 Normal = texture(gNormal, TexCoords).rgb;\n    vec3 Diffuse = texture(gAlbedoSpec, TexCoords).rgb;\n    float Specular = texture(gAlbedoSpec, TexCoords).a;\n\n    // then calculate lighting as usual\n    vec3 lighting  = Diffuse * .1; // hard-coded ambient component\n    vec3 viewDir  = normalize(viewPos - FragPos);\n    for(int i = 0; i < NR_LIGHTS; ++i)\n    {\n        // diffuse\n        vec3 lightDir = normalize(lights[i].Position - FragPos);\n        vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * lights[i].Color;\n        // specular\n        vec3 halfwayDir = normalize(lightDir + viewDir);\n        float spec = pow(max(dot(Normal, halfwayDir), 0.0), 16.0);\n        vec3 specular = lights[i].Color * spec * Specular;\n        // attenuation\n        float distance = length(lights[i].Position - FragPos);\n        float attenuation = 1.0 / (1.0 + lights[i].Linear * distance + lights[i].Quadratic * distance * distance);\n        diffuse *= attenuation;\n        specular *= attenuation;\n        lighting += diffuse + specular;\n    }\n    outColor = vec4(lighting, 1.0);\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\nout vec3 FragPos;\nout vec2 TexCoords;\nout vec3 Normal;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    vec4 worldPos = mMatrix * vec4(position, 1.0);\n    FragPos = vec3(worldPos);\n\n    TexCoords = texCoord;\n\n    mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n    Normal = normalMatrix * normal;\n\n    gl_Position = pMatrix * vMatrix * worldPos;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nlayout (location = 0) out vec3 gPosition;\nlayout (location = 1) out vec3 gNormal;\nlayout (location = 2) out vec4 gAlbedoSpec;\n\nin vec2 TexCoords;\nin vec3 FragPos;\nin vec3 Normal;\n\nuniform sampler2D diffuseMap1;\nuniform sampler2D specularMap1;\n\nvoid main()\n{\n    // store the fragment position vector in the first gbuffer texture\n    gPosition = FragPos;\n    // also store the per-fragment normals into the gbuffer\n    gNormal = normalize(Normal);\n    // and the diffuse per-fragment color\n    gAlbedoSpec.rgb = texture(diffuseMap1, TexCoords).rgb;\n    // store specular intensity in gAlbedoSpec's alpha component\n    gAlbedoSpec.a = texture(specularMap1, TexCoords).r;\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\n\nout vec2 TexCoords;\nvoid main(){\n  TexCoords = texCoord;\n  gl_Position = vec4(position, 1.);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nout vec4 FragColor;\nin  vec2 TexCoords;\n\nuniform sampler2D fboAttachment;\n\nvoid main()\n{\n    FragColor = vec4(texture(fboAttachment, TexCoords).rgb, 1.);\n}\n"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MTLLoader; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var load_asset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);
/* harmony import */ var load_asset__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(load_asset__WEBPACK_IMPORTED_MODULE_2__);


 // code from https://github.com/mrdoob/three.js

class MTLLoader {
  constructor(name, path) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "_materials", {});

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "materialsInfo", {});

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "name", '');

    this.name = name;
    this.path = path;
  }

  parse(text) {
    var lines, info, delimiterPattern, i, line, pos, key, value, ss;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          lines = text.split('\n');
          info = {};
          delimiterPattern = /\s+/;
          i = 0;

        case 4:
          if (!(i < lines.length)) {
            _context.next = 18;
            break;
          }

          line = lines[i];
          line = line.trim();

          if (!(line.length === 0 || line.charAt(0) === '#')) {
            _context.next = 9;
            break;
          }

          return _context.abrupt("continue", 15);

        case 9:
          pos = line.indexOf(' ');
          key = pos >= 0 ? line.substring(0, pos) : line;
          key = key.toLowerCase();
          value = pos >= 0 ? line.substring(pos + 1) : '';
          value = value.trim();

          if (key === 'newmtl') {
            // New material
            info = {
              name: value
            };
            this.materialsInfo[value] = info;
          } else {
            if (key === 'ka' || key === 'kd' || key === 'ks') {
              ss = value.split(delimiterPattern, 3);
              info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
            } else {
              info[key] = value;
            }
          }

        case 15:
          i++;
          _context.next = 4;
          break;

        case 18:
          _context.next = 20;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMaterials());

        case 20:
          return _context.abrupt("return", this.materials);

        case 21:
        case "end":
          return _context.stop();
      }
    }, null, this);
  } //


  setMaterials() {
    var n, key, prop, value;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.t0 = _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.materialsInfo);

        case 1:
          if ((_context2.t1 = _context2.t0()).done) {
            _context2.next = 50;
            break;
          }

          key = _context2.t1.value;
          this._materials[key] = {};
          _context2.t2 = _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.materialsInfo[key]);

        case 5:
          if ((_context2.t3 = _context2.t2()).done) {
            _context2.next = 48;
            break;
          }

          prop = _context2.t3.value;
          value = this.materialsInfo[key][prop];
          _context2.t4 = prop.toLowerCase();
          _context2.next = _context2.t4 === 'kd' ? 11 : _context2.t4 === 'ks' ? 13 : _context2.t4 === 'map_kd' ? 15 : _context2.t4 === 'map_ks' ? 19 : _context2.t4 === 'norm' ? 23 : _context2.t4 === 'map_bump' ? 27 : _context2.t4 === 'bump' ? 27 : _context2.t4 === 'map_d' ? 31 : _context2.t4 === 'ns' ? 36 : _context2.t4 === 'd' ? 38 : _context2.t4 === 'tr' ? 41 : 45;
          break;

        case 11:
          this._materials[key].kd = value;
          return _context2.abrupt("break", 46);

        case 13:
          this._materials[key].ks = value;
          return _context2.abrupt("break", 46);

        case 15:
          _context2.next = 17;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("diffuseMap", value));

        case 17:
          this._materials[key].diffuseMap = _context2.sent;
          return _context2.abrupt("break", 46);

        case 19:
          _context2.next = 21;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("specularMap", value));

        case 21:
          this._materials[key].specularMap = _context2.sent;
          return _context2.abrupt("break", 46);

        case 23:
          _context2.next = 25;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("normalMap", value));

        case 25:
          this._materials[key].normalMap = _context2.sent;
          return _context2.abrupt("break", 46);

        case 27:
          _context2.next = 29;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("bumpMap", value));

        case 29:
          this._materials[key].bumpMap = _context2.sent;
          return _context2.abrupt("break", 46);

        case 31:
          _context2.next = 33;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("alphaMap", value));

        case 33:
          this._materials[key].alphaMap = _context2.sent;
          params.transparent = true;
          return _context2.abrupt("break", 46);

        case 36:
          // The specular exponent (defines the focus of the specular highlight)
          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.
          this._materials[key].shininess = parseFloat(value);
          return _context2.abrupt("break", 46);

        case 38:
          n = parseFloat(value);

          if (n < 1) {
            this._materials[key].opacity = n;
          }

          return _context2.abrupt("break", 46);

        case 41:
          n = parseFloat(value);
          n = 1 - n;

          if (n > 0) {
            this._materials[key].opacity = 1 - n;
          }

          return _context2.abrupt("break", 46);

        case 45:
          return _context2.abrupt("break", 46);

        case 46:
          _context2.next = 5;
          break;

        case 48:
          _context2.next = 1;
          break;

        case 50:
        case "end":
          return _context2.stop();
      }
    }, null, this);
  }

  setMapType(name, text) {
    var url, asset;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          //simply skip texture params
          url = text.split(/\s+/).pop();
          _context3.next = 3;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(load_asset__WEBPACK_IMPORTED_MODULE_2___default()(this.path + '/' + url));

        case 3:
          asset = _context3.sent;
          return _context3.abrupt("return", asset);

        case 5:
        case "end":
          return _context3.stop();
      }
    }, null, this);
  } // material: { materialName: { ...params, aoMap: ..., diffuseMap: ..., ....}


  get materials() {
    return this._materials;
  }

  set materials(value) {
    this._materials = value;
  }

}__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NormalMap; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_normal_map_normal_map_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(108);
/* harmony import */ var shaders_normal_map_normal_map_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_normal_map_normal_map_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_normal_map_normal_map_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(109);
/* harmony import */ var shaders_normal_map_normal_map_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_normal_map_normal_map_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);








let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create());
let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create()); // http://ogldev.atspace.co.uk/www/tutorial26/tutorial26.html
// Gramm-Schmid 正交可将从fragment里被光栅化，不再正交与normal的tangent重新正交化
// https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E5%A7%86-%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96
// 和cemra的lookat一样，将基坐标乘以切线空间的normal得到贴图方向的normal，乘法基于scalar project得到三个方向的向量
// normalmap是当前平面方向的微调，所以得到平面或者叫贴图的normal就行
// 比如一个朝向y+方向的面，得到的normal还是垂直表面的，normalmap上不经过转化，是指向z的，蓝色的，计算后，应该是以表面normal为基准的分量
// 即指向y+的，只是有些微调

/* eg.
  let T = vec3.fromValues(0, .3, 1)
  let N = vec3.fromValues(0, 1, 0)
  console.log(vec3.subtract(T, T, vec3.scale(N, N, vec3.dot(T, N))))
  施密特正交后是[0, 0, 1]，与N垂直
  按照想法，normalmap上的（0，0，1）与N（0，1，0）经过TBN乘法得到的还是（0，1，0）
  TBN乘法项与摄像机XYZ单位向量相同 http: //ogldev.atspace.co.uk/www/tutorial13/tutorial13.html
  因此，normalmap切线空间的（0，0，1）只在z轴，即N上有投影，得到的与N相同（0，1，0）
  mat4[T,B,N,1] * [0,0,1,1] = [0,1,0,1] （N = [0,1,0]）
  世界空间坐标系 * 切线空间坐标 = 世界空间坐标 ＜（＾－＾）＞

*/

const caculateTBN = N => {
  const leftTop = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].fromValues(-1., 0, -1.);
  const leftBottom = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].fromValues(-1, 0, 1);
  const rightBootm = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].fromValues(1, 0, 1);
  const rightTop = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].fromValues(1, 0, -1);
  const uv1 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].fromValues(0, 1);
  const uv2 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].fromValues(0, 0);
  const uv3 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].fromValues(1, 0);
  const uv4 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].fromValues(1, 1);
  const nm = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].fromValues(0.0, 1.0, 0.0);
  const edge1 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].create();
  const edge2 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].create();
  const deltaUV1 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].create();
  const deltaUV2 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].create(); // triangle 1
  // ----------

  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].subtract(edge1, leftBottom, leftTop);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].subtract(edge2, rightBootm, leftTop);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].subtract(deltaUV1, uv2, uv1);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].subtract(deltaUV2, uv3, uv1);
  let f = 1.0 / (deltaUV1[0] * deltaUV2[1] - deltaUV2[0] * deltaUV1[1]);
  const tangent1 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].create();
  const bitangent1 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].create();
  const tangent2 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].create();
  const bitangent2 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].create();
  tangent1[0] = f * (deltaUV2[1] * edge1[0] - deltaUV1[1] * edge2[0]);
  tangent1[1] = f * (deltaUV2[1] * edge1[1] - deltaUV1[1] * edge2[1]);
  tangent1[2] = f * (deltaUV2[1] * edge1[2] - deltaUV1[1] * edge2[2]);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].normalize(tangent1, tangent1);
  bitangent1[0] = f * (-deltaUV2[0] * edge1[0] + deltaUV1[0] * edge2[0]);
  bitangent1[1] = f * (-deltaUV2[0] * edge1[1] + deltaUV1[0] * edge2[1]);
  bitangent1[2] = f * (-deltaUV2[0] * edge1[2] + deltaUV1[0] * edge2[2]);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].normalize(bitangent1, bitangent1); // triangle 2
  // ----------

  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].subtract(edge1, rightBootm, leftTop);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].subtract(edge2, rightTop, leftTop);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].subtract(deltaUV1, uv3, uv1);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec2 */ "c"].subtract(deltaUV2, uv4, uv1);
  f = 1.0 / (deltaUV1[0] * deltaUV2[1] - deltaUV2[0] * deltaUV1[1]);
  tangent2[0] = f * (deltaUV2[1] * edge1[0] - deltaUV1[1] * edge2[0]);
  tangent2[1] = f * (deltaUV2[1] * edge1[1] - deltaUV1[1] * edge2[1]);
  tangent2[2] = f * (deltaUV2[1] * edge1[2] - deltaUV1[1] * edge2[2]);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].normalize(tangent2, tangent2);
  bitangent2[0] = f * (-deltaUV2[0] * edge1[0] + deltaUV1[0] * edge2[0]);
  bitangent2[1] = f * (-deltaUV2[0] * edge1[1] + deltaUV1[0] * edge2[1]);
  bitangent2[2] = f * (-deltaUV2[0] * edge1[2] + deltaUV1[0] * edge2[2]);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* vec3 */ "d"].normalize(bitangent2, bitangent2);
  const quadVertices = [// positions            // normal         // texcoords  // tangent                          // bitangent
  leftTop[0], leftTop[1], leftTop[2], nm[0], nm[1], nm[2], uv1[0], uv1[1], tangent1[0], tangent1[1], tangent1[2], bitangent1[0], bitangent1[1], bitangent1[2], leftBottom[0], leftBottom[1], leftBottom[2], nm[0], nm[1], nm[2], uv2[0], uv2[1], tangent1[0], tangent1[1], tangent1[2], bitangent1[0], bitangent1[1], bitangent1[2], rightBootm[0], rightBootm[1], rightBootm[2], nm[0], nm[1], nm[2], uv3[0], uv3[1], tangent1[0], tangent1[1], tangent1[2], bitangent1[0], bitangent1[1], bitangent1[2], leftTop[0], leftTop[1], leftTop[2], nm[0], nm[1], nm[2], uv1[0], uv1[1], tangent2[0], tangent2[1], tangent2[2], bitangent2[0], bitangent2[1], bitangent2[2], rightBootm[0], rightBootm[1], rightBootm[2], nm[0], nm[1], nm[2], uv3[0], uv3[1], tangent2[0], tangent2[1], tangent2[2], bitangent2[0], bitangent2[1], bitangent2[2], rightTop[0], rightTop[1], rightTop[2], nm[0], nm[1], nm[2], uv4[0], uv4[1], tangent2[0], tangent2[1], tangent2[2], bitangent2[0], bitangent2[1], bitangent2[2]];
  return quadVertices;
};

const lightPos = [0, 3, 0];
class NormalMap extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_normal_map_normal_map_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_normal_map_normal_map_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
  }

  attrib() {
    const quadVertices = caculateTBN();
    this.quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]();
    this.quad.bufferData(quadVertices, ['position', 'normal', 'texCoord', 'tangent', 'bitangent'], [3, 3, 2, 3, 3]);
  }

  prepare() {
    this.camera.offset = [0, 2, 0];
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].clearDepth(1.0);
    const brickwall = new libs_glTexture__WEBPACK_IMPORTED_MODULE_3___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"]).fromImage(getAssets.brickwall);
    const brickwallNormal = new libs_glTexture__WEBPACK_IMPORTED_MODULE_3___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"]).fromImage(getAssets.brickwallNormal);
    brickwall.bind(0);
    brickwallNormal.bind(1);
  }

  uniform() {
    vMatrix = this.camera.viewMatrix;
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* toRadian */ "e"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* canvas */ "a"].clientHeight, .1, 100);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [1.8, 1.8, 1.8]);
    this.prg.use();
    this.prg.style({
      mMatrix,
      vMatrix,
      pMatrix,
      viewPos: this.camera.cameraPos,
      lightPos,
      diffuseMap: 0,
      normalMap: 1
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.quad.bind(this.prg, ['position', 'normal', 'texCoord', 'tangent']);
    this.quad.draw();
  }

}module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\nlayout (location = 3) in vec3 tangent;\nlayout (location = 4) in vec3 bitangent;\n\n\nout vec3 FragPos;\nout vec2 TexCoords;\nout vec3 TangentLightPos;\nout vec3 TangentViewPos;\nout vec3 TangentFragPos;\n\n\nuniform mat4 pMatrix;\nuniform mat4 vMatrix;\nuniform mat4 mMatrix;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nvoid main() {\n  FragPos = vec3(mMatrix * vec4(position, 1.));\n  TexCoords = texCoord;\n\n  mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n  vec3 T = normalize(normalMatrix * tangent);\n  vec3 N = normalize(normalMatrix * normal);\n  T = normalize(T - dot(T, N) * N);\n  vec3 B = cross(N, T);\n\n   mat3 TBN = transpose(mat3(T, B, N));\n  TangentLightPos = TBN * lightPos;\n  TangentViewPos  = TBN * viewPos;\n  TangentFragPos  = TBN * FragPos;\n\n  gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec3 FragPos;\nin vec2 TexCoords;\nin vec3 TangentLightPos;\nin vec3 TangentViewPos;\nin vec3 TangentFragPos;\n\n\nuniform sampler2D diffuseMap;\nuniform sampler2D normalMap;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nvoid main()\n{\n     // obtain normal from normal map in range [0,1]\n    vec3 normal = texture(normalMap, TexCoords).rgb;\n    // transform normal vector to range [-1,1]\n    normal = normalize(normal * 2.0 - 1.0);  // this normal is in tangent space\n\n    // get diffuse color\n    vec3 color = texture(diffuseMap, TexCoords).rgb;\n    // ambient\n    vec3 ambient = 0.1 * color;\n    // diffuse\n    vec3 lightDir = normalize(TangentLightPos - TangentFragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * color;\n    // specular\n    vec3 viewDir = normalize(TangentViewPos - TangentFragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n\n    vec3 specular = vec3(0.2) * spec;\n    FragColor = vec4(ambient + diffuse + specular, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SSAO; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_ssao_ssao_geometry_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(110);
/* harmony import */ var shaders_ssao_ssao_geometry_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_geometry_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_ssao_ssao_geometry_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(111);
/* harmony import */ var shaders_ssao_ssao_geometry_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_geometry_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(15);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_ssao_ssao_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(112);
/* harmony import */ var shaders_ssao_ssao_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_ssao_ssao_blur_frag__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(113);
/* harmony import */ var shaders_ssao_ssao_blur_frag__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_blur_frag__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_ssao_ssao_lighting_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(114);
/* harmony import */ var shaders_ssao_ssao_lighting_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_lighting_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(4);
/* harmony import */ var libs_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(21);
/* harmony import */ var libs_loaders_MTLLoader__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(28);
/* harmony import */ var libs_glFbo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(22);
/* harmony import */ var libs_glFbo__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(libs_glFbo__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_16__);

















const lightPositions = [0, -1, 0];
const lightColors = [.2, .2, .7];
const kernelSize = 64;
let ssaoKernel = new Float32Array(64 * 3);
let ssaoNoise = new Float32Array(16 * 3);

const generateSample = () => {
  for (let i = 0; i < kernelSize; i++) {
    let sample = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* vec3 */ "d"].fromValues(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random());
    ssaoKernel[i * 3] = sample[0];
    ssaoKernel[i * 3 + 1] = sample[1];
    ssaoKernel[i * 3 + 2] = sample[2];
  }
};

const generateNoise = () => {
  for (let i = 0; i < 16; i++) {
    let noise = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* vec3 */ "d"].fromValues(Math.random() * 2 - 1, Math.random() * 2 - 1, 0);
    ssaoNoise[i * 3] = noise[0];
    ssaoNoise[i * 3 + 1] = noise[1];
    ssaoNoise[i * 3 + 2] = noise[2];
  }
};

class SSAO extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension('OES_texture_float_linear'); // Even WebGL2 requires OES_texture_float_linear

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension("EXT_color_buffer_float"); // gl.getExtension('OES_texture_half_float')

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].getExtension('OES_texture_half_float_linear'); // gl.getExtension('EXT_shader_texture_lod')

    this.gBufferPrg = this.compile(shaders_ssao_ssao_geometry_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_ssao_ssao_geometry_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.ssaoPrg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_ssao_ssao_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.blurPrg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_ssao_ssao_blur_frag__WEBPACK_IMPORTED_MODULE_8___default.a);
    this.prg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_ssao_ssao_lighting_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
  }

  attrib() {
    var cube, quad, materials;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]();
          cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_10__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
          this.cube = cube;
          quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]();
          quad.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_10__["QuadData"], ['position', 'texCoord'], [3, 2]);
          this.quad = quad;
          _context.next = 8;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(new libs_loaders_MTLLoader__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"]('nanosuit.mtl', './assets/models/nanosuit').parse(getAssets.nanosuitMTL));

        case 8:
          materials = _context.sent;
          this.nanosuit = new libs_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"]().parseObj(getAssets.nanosuit, materials);

        case 10:
        case "end":
          return _context.stop();
      }
    }, null, this);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearColor(0., 0., 0., 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LEQUAL); //position, normal, AlbedoSpec(diffuse, specular indensity)

    this.mrt = framebufferMRT(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height, ['16f', '16f', 'rgba']);
    this.ssaoFbo = new libs_glFbo__WEBPACK_IMPORTED_MODULE_15___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    this.ssaoFbo.resize(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height);
    this.blurFbo = new libs_glFbo__WEBPACK_IMPORTED_MODULE_15___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"]);
    this.blurFbo.resize(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].height);
    generateSample();
    generateNoise();
    this.noiseTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_16___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGB).fromData(4, 4, ssaoNoise, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGB32F);
    this.noiseTexture.bind();
    this.noiseTexture.repeat(); // execute once

    this.camera.target = [0, -1., 0];
    this.camera.offset = [0, 0., 0];
    this.camera.radius = 3;
    this.camera.rx = -1.5;
  }

  uniform() {
    this.vMatrix = this.camera.viewMatrix;
    this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].perspective(this.pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "e"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "a"].clientHeight, .1, 100);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, this.mrt.frameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.gBufferPrg.use();
    this.gBufferPrg.style({
      vMatrix: this.vMatrix,
      pMatrix: this.pMatrix
    });

    if (this.nanosuit) {
      // loaded
      let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].create());
      gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].translate(mMatrix, mMatrix, [-1.0, -3.3, 3.]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [.4, .4, .4]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].rotate(mMatrix, mMatrix, -Math.PI / 2, [1, 0, 0]);
      this.gBufferPrg.style({
        mMatrix,
        invertedNormals: 0
      });

      for (let i = 0; i < this.nanosuit.length; i++) {
        this.nanosuit[i].bind(this.gBufferPrg, ['position', 'normal', 'texCoord']);
        this.nanosuit[i].draw();
      }
    }

    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "a"].scale(mMatrix, mMatrix, [8, 4, 8]);
    this.gBufferPrg.style({
      mMatrix,
      invertedNormals: 1
    });
    this.cube.bind(this.gBufferPrg, ['position', 'normal', 'texCoord']);
    this.cube.draw();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null);
    this.ssaoFbo.bind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.mrt.texture[0]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE1);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.mrt.texture[1]);
    this.noiseTexture.bind(2);
    this.ssaoPrg.use();
    this.ssaoPrg.style({
      gPositionDepth: 0,
      gNormal: 1,
      texNoise: 2,
      samples: ssaoKernel,
      pMatrix: this.pMatrix
    });
    this.quad.bind(this.ssaoPrg, ['position', 'texCoord']);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TRIANGLE_STRIP);
    this.ssaoFbo.unbind();
    this.blurFbo.bind();
    this.ssaoFbo.color.bind(0);
    this.blurPrg.use();
    this.blurPrg.style({
      ssaoInput: 0
    });
    this.quad.bind(this.blurPrg, ['position', 'texCoord']);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TRIANGLE_STRIP);
    this.blurFbo.unbind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.mrt.texture[0]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE1);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.mrt.texture[1]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE2);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, this.mrt.texture[2]);
    this.blurFbo.color.bind(3);
    this.prg.use();
    this.prg.style({
      gPosition: 0,
      gNormal: 1,
      gAlbedoSpec: 2,
      ssao: 3,
      viewPos: this.camera.cameraPos,
      'lights.Position': lightPositions,
      'lights.Color': lightColors,
      'lights.Linear': .09,
      'lights.Quadratic': .032
    });
    this.quad.bind(this.prg, ['position', 'texCoord']);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TRIANGLE_STRIP);
  }

}

function framebufferMRT(width, height, type) {
  let frameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createFramebuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, frameBuffer);
  let fTexture = [];
  const bufferList = [];

  for (let i = 0; i < type.length; ++i) {
    fTexture[i] = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, fTexture[i]);

    if (type[i] === '16f') {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA16F, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].HALF_FLOAT, null);
    } else {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].UNSIGNED_BYTE, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0 + i, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, fTexture[i], 0);
    bufferList.push(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].COLOR_ATTACHMENT0 + i);
  }

  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].drawBuffers(bufferList); // 指定渲染目标

  const depthRenderBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].createRenderbuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, depthRenderBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].renderbufferStorage(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH24_STENCIL8, width, height);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].framebufferRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].DEPTH_ATTACHMENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, depthRenderBuffer);
  const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER);

  if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER_COMPLETE) {
    console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
  }

  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].TEXTURE_2D, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].RENDERBUFFER, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "d"].FRAMEBUFFER, null);
  return {
    frameBuffer: frameBuffer,
    depthBuffer: depthRenderBuffer,
    texture: fTexture
  };
}
/*
  // 几何处理阶段: 渲染到G缓冲中
  glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);
  [...]
  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  // 使用G缓冲渲染SSAO纹理
  glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);
  glClear(GL_COLOR_BUFFER_BIT);
  shaderSSAO.Use();
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, gPositionDepth);
  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, gNormal);
  glActiveTexture(GL_TEXTURE2);
  glBindTexture(GL_TEXTURE_2D, noiseTexture);
  SendKernelSamplesToShader();
  glUniformMatrix4fv(projLocation, 1, GL_FALSE, glm::value_ptr(projection));
  RenderQuad();
  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  // 光照处理阶段: 渲染场景光照
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  shaderLightingPass.Use();
  [...]
  glActiveTexture(GL_TEXTURE3);
  glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);
  [...]
  RenderQuad();
*/module.exports = "#version 300 es\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\nout vec3 FragPos;\nout vec2 TexCoords;\nout vec3 Normal;\n\nuniform bool invertedNormals;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    vec4 viewPos = vMatrix * mMatrix * vec4(position, 1.0);\n    FragPos = vec3(viewPos);\n    TexCoords = texCoord;\n\n    mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n    Normal = normalMatrix * (invertedNormals ? -normal : normal);\n\n    gl_Position = pMatrix * viewPos;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nlayout (location = 0) out vec3 gPositionDepth;\nlayout (location = 1) out vec3 gNormal;\nlayout (location = 2) out vec4 gAlbedoSpec;\n\nin vec2 TexCoords;\nin vec3 FragPos;\nin vec3 Normal;\n\nconst float NEAR = 0.1; // 投影矩阵的近平面\nconst float FAR = 50.0f; // 投影矩阵的远平面\nfloat LinearizeDepth(float depth)\n{\n    float z = depth * 2.0 - 1.0; // 回到NDC\n    return (2.0 * NEAR * FAR) / (FAR + NEAR - z * (FAR - NEAR));\n}\n\n\nvoid main()\n{\n    // store the fragment position vector in the first gbuffer texture\n    gPositionDepth.xyz = FragPos;\n    // // 储存线性深度到gPositionDepth的alpha分量\n    // gPositionDepth.a = LinearizeDepth(gl_FragCoord.z);\n    // also store the per-fragment normals into the gbuffer\n    gNormal = normalize(Normal);\n    // and the diffuse per-fragment color\n    gAlbedoSpec.rgb = vec3(0.95);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout float FragColor;\nin vec2 TexCoords;\n\nuniform sampler2D gPositionDepth;\nuniform sampler2D gNormal;\nuniform sampler2D texNoise;\n\nuniform vec3 samples[64];\nuniform mat4 pMatrix;\n\nint kernelSize = 64;\nfloat radius = 0.5;\nfloat bias = 0.025;\n// 屏幕的平铺噪声纹理会根据屏幕分辨率除以噪声大小的值来决定\nconst vec2 noiseScale = vec2(960.0/4.0, 640.0/4.0);\n\nvoid main() {\n    vec3 fragPos = texture(gPositionDepth, TexCoords).xyz;\n    vec3 normal = texture(gNormal, TexCoords).rgb;\n    vec3 randomVec = texture(texNoise, TexCoords * noiseScale).xyz;\n\n    // Gramm-Schmidt正交化\n    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\n    vec3 bitangent = cross(normal, tangent);\n    mat3 TBN = mat3(tangent, bitangent, normal);\n\n    float occlusion = 0.0;\n    for(int i = 0; i < kernelSize; ++i)\n    {\n        // 获取样本位置\n        vec3 sample1 = TBN * samples[i]; // 切线->观察空间\n        sample1 = fragPos + sample1 * radius;\n\n        vec4 offset = vec4(sample1, 1.0);\n        offset = pMatrix * offset; // 观察->裁剪空间\n        offset.xyz /= offset.w; // 透视划分\n        offset.xyz = offset.xyz * 0.5 + 0.5; // 变换到0.0 - 1.0的值域\n\n        float sampleDepth = texture(gPositionDepth, offset.xy).z;\n        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));\n        occlusion += (sampleDepth >= sample1.z ? 1.0 : 0.0) * rangeCheck;\n\n    }\n    occlusion = 1.0 - (occlusion / float(kernelSize));\n    FragColor = occlusion;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin vec2 TexCoords;\nout float FragColor;\nuniform sampler2D ssaoInput;\n\nvoid main() {\n  // simple box filter\n  vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0));\n  float result = 0.0;\n  for (int x = -2; x < 2; ++x)\n  {\n    for (int y = -2; y < 2; ++y)\n    {\n        vec2 offset = vec2(float(x), float(y)) * texelSize;\n        result += texture(ssaoInput, TexCoords + offset).r;\n    }\n  }\n  FragColor = result / (4.0 * 4.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nout vec4 outColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedoSpec;\nuniform sampler2D ssao;\n\nstruct Light {\n    vec3 Position;\n    vec3 Color;\n\n    float Linear;\n    float Quadratic;\n};\nuniform Light lights;\nuniform vec3 viewPos;\n\nvoid main() {\n    vec3 FragPos = texture(gPosition, TexCoords).rgb;\n    vec3 Normal = texture(gNormal, TexCoords).rgb;\n    vec3 Diffuse = texture(gAlbedoSpec, TexCoords).rgb;\n    float AmbientOcclusion = texture(ssao, TexCoords).r;\n\n    // then calculate lighting as usual\n    vec3 ambient = vec3(0.3 * Diffuse * AmbientOcclusion);\n    vec3 lighting  = ambient;\n    vec3 viewDir  = normalize(- FragPos);\n\n\n    // diffuse\n    vec3 lightDir = normalize(lights.Position - FragPos);\n    vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * lights.Color;\n    // specular\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(Normal, halfwayDir), 0.0), 16.0);\n    vec3 specular = lights.Color * spec;\n    // attenuation\n    float distance = length(lights.Position - FragPos);\n    float attenuation = 1.0 / (1.0 + lights.Linear * distance + lights.Quadratic * distance * distance);\n    diffuse *= attenuation;\n    specular *= attenuation;\n    lighting += diffuse + specular;\n\n    outColor = vec4(lighting, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Shadow; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_shadow_depth_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(115);
/* harmony import */ var shaders_shadow_depth_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_depth_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_shadow_depth_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(116);
/* harmony import */ var shaders_shadow_depth_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_depth_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(15);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_shadow_depthQuad_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(117);
/* harmony import */ var shaders_shadow_depthQuad_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_depthQuad_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_shadow_shadowMapping_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(118);
/* harmony import */ var shaders_shadow_shadowMapping_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_shadowMapping_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_shadow_shadowMapping_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(119);
/* harmony import */ var shaders_shadow_shadowMapping_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_shadowMapping_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(6);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(4);













const shadowWidth = 1024;
const shadowHeight = 1024;
const lightPos = [0, 4, -1];
let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
class Shadow extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_shadow_depth_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_shadow_depth_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.depthQuadPrg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_shadow_depthQuad_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.shadowPrg = this.compile(shaders_shadow_shadowMapping_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_shadow_shadowMapping_frag__WEBPACK_IMPORTED_MODULE_9___default.a); // flip texture

    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].UNPACK_FLIP_Y_WEBGL, true);
  }

  attrib() {
    let planeData = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    30., -1.01, 30., 1.0, 0.0, -30., -1.01, 30., 0.0, 0.0, -30., -1.01, -30., 0.0, 1.0, 30., -1.01, 30., 1.0, 0.0, -30., -1.01, -30., 0.0, 1.0, 30., -1.01, -30., 1.0, 1.0];
    this.plane = new libs_Mesh__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]();
    this.plane.bufferData(planeData, ['position', 'texCoord'], [3, 2]);
    this.cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]();
    this.cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_11__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]();
    this.quad.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_11__["QuadData"], ['position', 'texCoord'], [3, 2]);
  }

  prepare() {
    // gl.getExtension("WEBGL_depth_texture")
    let lightView = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
    let lightProjection = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
    const nearPlane = .1;
    const farPlane = 18.5; // out, left, right, bottom, top, near, far

    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].ortho(lightProjection, -25, 25, -25, 25, nearPlane, farPlane);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].lookAt(lightView, lightPos, [0, 0, 0], [0, 1, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].multiply(this.tmpMatrix, lightProjection, lightView);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* toRadian */ "e"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* canvasWidth */ "c"] / libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* canvasHeight */ "b"], .1, 100);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].LESS);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clearColor(0.3, 0.3, .3, 1.0);
    this.depthBuffer = depthTextureFbo(shadowWidth, shadowHeight);
    this.camera.radius = 11;
    this.wood = new libs_glTexture__WEBPACK_IMPORTED_MODULE_3___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"]).fromImage(getAssets.wood);
    this.wood.bind();
    this.wood.repeat();
  }

  uniform() {
    vMatrix = this.camera.viewMatrix;
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].viewport(0, 0, shadowWidth, shadowHeight);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].FRAMEBUFFER, this.depthBuffer.frameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    this.prg.use();
    this.prg.style({
      lightSpaceMatrix: this.tmpMatrix
    });

    this._renderScene(this.prg, ['position']);

    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].FRAMEBUFFER, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].viewport(0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* canvasWidth */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* canvasHeight */ "b"]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DEPTH_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_2D, this.depthBuffer.depthTexture); // for debug
    // this.depthQuadPrg.use()
    // this.depthQuadPrg.style({
    //   depthMap: 0
    // })
    // this.quad.bind(this.depthQuadPrg, ['position', 'texCoord'])
    // this.quad.draw(gl.TRIANGLE_STRIP)

    this.wood.bind(1);
    this.shadowPrg.use();
    this.shadowPrg.style({
      shadowMap: 0,
      diffuseTexture: 1,
      lightPos,
      viewPos: this.camera.cameraPos,
      mMatrix: this.mMatrix,
      pMatrix,
      vMatrix,
      lightSpaceMatrix: this.tmpMatrix
    });

    this._renderScene(this.shadowPrg);
  }

  _renderScene(shader, arg) {
    this.mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
    shader.style({
      mMatrix: this.mMatrix
    });
    this.plane.bind(shader, arg);
    this.plane.draw();
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].translate(this.mMatrix, this.mMatrix, [-1.2, 0, 5]);
    shader.style({
      mMatrix: this.mMatrix
    });
    this.cube.bind(shader, arg);
    this.cube.draw();
    this.mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].translate(this.mMatrix, this.mMatrix, [2, 2, 4]);
    shader.style({
      mMatrix: this.mMatrix
    });
    this.cube.bind(shader, arg);
    this.cube.draw();
    this.mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].translate(this.mMatrix, this.mMatrix, [-2.2, .4, 1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "a"].rotate(this.mMatrix, this.mMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* toRadian */ "e"])(30), [2, 2, 4]);
    shader.style({
      mMatrix: this.mMatrix
    });
    this.cube.bind(shader, arg);
    this.cube.draw();
  }

}

function depthTextureFbo(width, height) {
  const frameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].createFramebuffer();
  const depthTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].createTexture();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_2D, depthTexture);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DEPTH_COMPONENT16, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DEPTH_COMPONENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].UNSIGNED_SHORT, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].NEAREST);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].NEAREST);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].REPEAT);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].REPEAT);
  const borderColor = [1.0, 1.0, 1.0, 1.0]; // gl.texParameterfv(gl.TEXTURE_2D, gl.TEXTURE_BORDER_COLOR, borderColor)

  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].FRAMEBUFFER, frameBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].DEPTH_ATTACHMENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].TEXTURE_2D, depthTexture, 0);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].drawBuffers([libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].NONE]);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].readBuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].NONE);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "d"].FRAMEBUFFER, null);
  return {
    frameBuffer,
    depthTexture
  };
}
/*
  // 1. 首选渲染深度贴图
  glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);
  glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
  glClear(GL_DEPTH_BUFFER_BIT);
  ConfigureShaderAndMatrices();
  RenderScene();
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  // 2. 像往常一样渲染场景，但这次使用深度贴图
  glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  ConfigureShaderAndMatrices();
  glBindTexture(GL_TEXTURE_2D, depthMap);
  RenderScene();
*/module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\n\nuniform mat4 lightSpaceMatrix;\nuniform mat4 mMatrix;\n\nvoid main(void){\n    gl_Position = lightSpaceMatrix * mMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n\nvoid main(){\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D depthMap;\nuniform float near_plane;\nuniform float far_plane;\n\n// required when using a perspective projection matrix\nfloat LinearizeDepth(float depth)\n{\n    float z = depth * 2.0 - 1.0; // Back to NDC\n    return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));\n}\n\nvoid main()\n{\n    float depthValue = texture(depthMap, TexCoords).r;\n    // FragColor = vec4(vec3(LinearizeDepth(depthValue) / far_plane), 1.0); // perspective\n    FragColor = vec4(vec3(depthValue), 1.0); // orthographic\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\n\nout vec3 FragPos;\nout  vec3 Normal;\nout  vec2 TexCoords;\nout vec4 FragPosLightSpace;\n\n\nuniform mat4 pMatrix;\nuniform mat4 vMatrix;\nuniform mat4 mMatrix;\nuniform mat4 lightSpaceMatrix;\n\nvoid main(){\n  gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.);\n  FragPos = vec3(mMatrix * vec4(position, 1.));\n  Normal = transpose(inverse(mat3(mMatrix))) * normal;\n  TexCoords = texCoord;\n  FragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.); // 从lightPos视角看的坐标\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\nin vec4 FragPosLightSpace;\n\n\nuniform sampler2D diffuseTexture;\nuniform sampler2D shadowMap;\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nfloat ShadowCalculation(vec4 fragPosLightSpace, float bias){\n      // 执行透视除法\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n    // 变换到[0,1]的范围\n    projCoords = projCoords * 0.5 + 0.5;\n    // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)\n    float closestDepth = texture(shadowMap, projCoords.xy).r;\n    // 取得当前片元在光源视角下的深度\n    float currentDepth = projCoords.z;\n    // 检查当前片元是否在阴影中\n\n    float shadow = 0.0;\n    vec2 texelSize = vec2(1. / float(textureSize(shadowMap, 0).x));\n    for(int x = -1; x <= 1; ++x)\n    {\n        for(int y = -1; y <= 1; ++y)\n        {\n            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;\n            shadow += currentDepth - bias > pcfDepth ? .7 : 0.0;\n        }\n    }\n    shadow /= 9.0;\n\n    if(projCoords.z > 1.0) shadow = 0.0;\n\n    return shadow;\n}\n\nvoid main(){\n    vec3 color = texture(diffuseTexture, TexCoords).rgb;\n    vec3 normal = normalize(Normal);\n    vec3 lightColor = vec3(2.0);\n    // Ambient\n    vec3 ambient = 0.15 * color;\n    // Diffuse\n    vec3 lightDir = normalize(lightPos - FragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * lightColor;\n    // Specular\n    vec3 viewDir = normalize(viewPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = 0.0;\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);\n    vec3 specular = spec * lightColor;\n    // 计算阴影\n    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);\n    float shadow = ShadowCalculation(FragPosLightSpace, bias);\n    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;\n\n    FragColor = vec4(lighting, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _MouseMove__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);


const importLists = {
  reflection: 'Light/Reflection',
  mask: 'OpenGL/Mask',
  shadow: 'advanced_light/Shadow',
  deferredshading: 'advanced_light/DeferredShading',
  mrt: 'OpenGL/Mrt',
  mirror: 'OpenGL/Mirror',
  pbr: 'Pbr/Pbr',
  ibldiffuse: 'Pbr/IblDiffuse',
  iblfinal: 'Pbr/iblFinal',
  ssao: 'advanced_light/SSAO',
  normalmap: 'advanced_light/NormalMap',
  pbrflow: 'Pbr/PbrFlow',
  lightcaster: 'Light/LightCaster',
  color: 'Light/Color',
  material: 'Light/Material',
  pbrmodel: 'Pbr/PbrModel',
  shape: 'Shape'
};

function addList() {
  let list = document.querySelector('.list');

  for (let key in importLists) {
    let link = document.createElement('a');
    link.innerHTML = key;
    link.setAttribute('href', '?' + key);
    list.appendChild(link);
    let br = document.createElement('br');
    list.appendChild(br);
  }
}

let obj;

const dynamicImport = name => {
  __webpack_require__(124)(`./${importLists[name]}`).then(foo => {
    obj = new foo.default();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* canvas */ "a"].addEventListener('mousemove', e => {
      obj.rotateQ = Object(_MouseMove__WEBPACK_IMPORTED_MODULE_1__["default"])(e, libs_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* canvas */ "a"]);
    });
    obj.play();
  });
};

let name = location.search.replace('?', '').toLocaleLowerCase();
if (name) dynamicImport(name);else addList();/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return gl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return canvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return canvasWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return canvasHeight; });
const canvas = document.querySelector('canvas');
const options = {
  antialias: false,
  stencil: true
};
const name = location.search.replace('?', '').toLocaleLowerCase();
let gl;

if (name !== 'mrt' && name !== 'mirror' && name !== 'pbr' && name !== 'ibl') {
  gl = canvas.getContext('webgl2', options);
  if (!gl) console.warn('webgl2 not supported!');
  console.log('webgl2 used.');
  window.useWebgl2 = true;
} else gl = canvas.getContext('webgl', options);

const toRadian = deg => {
  return deg / 180 * Math.PI;
};

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MouseMove; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

function MouseMove(e, canvas) {
  let cw = canvas.clientWidth;
  let ch = canvas.clientHeight;
  var wh = 1 / Math.sqrt(cw * cw + ch * ch);
  let x = e.clientX - canvas.offsetLeft - cw * 0.5;
  let y = e.clientY - canvas.offsetTop - ch * 0.5;
  let q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__[/* quat */ "b"].create();
  var sq = Math.sqrt(x * x + y * y);
  var r = sq * 2.0 * Math.PI * wh; // 距离来表示旋转弧度

  if (sq !== 1) {
    sq = 1 / sq;
    x *= sq;
    y *= sq;
  }

  gl_matrix__WEBPACK_IMPORTED_MODULE_0__[/* quat */ "b"].setAxisAngle(q, [y, x, 0], r); // 旋转轴向量与(x,y,0)垂直

  return q;
}var map = {
	"./3dShape/3dShape": [
		38,
		7,
		19
	],
	"./3dShape/3dShape.js": [
		38,
		7,
		19
	],
	"./Assets": [
		11,
		9
	],
	"./Assets.js": [
		11,
		9
	],
	"./Light/Color": [
		39,
		9,
		0,
		1,
		17
	],
	"./Light/Color.js": [
		39,
		9,
		0,
		1,
		17
	],
	"./Light/LightCaster": [
		40,
		9,
		0,
		1,
		13
	],
	"./Light/LightCaster.js": [
		40,
		9,
		0,
		1,
		13
	],
	"./Light/Material": [
		41,
		9,
		0,
		1,
		16
	],
	"./Light/Material.js": [
		41,
		9,
		0,
		1,
		16
	],
	"./Light/Reflection": [
		42,
		9,
		0,
		14
	],
	"./Light/Reflection.js": [
		42,
		9,
		0,
		14
	],
	"./MouseMove": [
		23,
		9
	],
	"./MouseMove.js": [
		23,
		9
	],
	"./OpenGL/Gpgpu": [
		43,
		7,
		20
	],
	"./OpenGL/Gpgpu.js": [
		43,
		7,
		20
	],
	"./OpenGL/Mask": [
		44,
		9,
		0,
		9
	],
	"./OpenGL/Mask.js": [
		44,
		9,
		0,
		9
	],
	"./OpenGL/Mirror": [
		45,
		9,
		0,
		1,
		12
	],
	"./OpenGL/Mirror.js": [
		45,
		9,
		0,
		1,
		12
	],
	"./OpenGL/Mrt": [
		46,
		9,
		0,
		8
	],
	"./OpenGL/Mrt.js": [
		46,
		9,
		0,
		8
	],
	"./OpenGL/Text": [
		47,
		7,
		21
	],
	"./OpenGL/Text.js": [
		47,
		7,
		21
	],
	"./Pbr/IblDiffuse": [
		59,
		9,
		0,
		1,
		5
	],
	"./Pbr/IblDiffuse.js": [
		59,
		9,
		0,
		1,
		5
	],
	"./Pbr/Pbr": [
		48,
		9,
		0,
		1,
		15
	],
	"./Pbr/Pbr.js": [
		48,
		9,
		0,
		1,
		15
	],
	"./Pbr/PbrFlow": [
		49,
		9,
		0,
		1,
		3
	],
	"./Pbr/PbrFlow.js": [
		49,
		9,
		0,
		1,
		3
	],
	"./Pbr/PbrModel": [
		50,
		9,
		0,
		1,
		2
	],
	"./Pbr/PbrModel.js": [
		50,
		9,
		0,
		1,
		2
	],
	"./Pbr/iblFinal": [
		51,
		9,
		0,
		1,
		4
	],
	"./Pbr/iblFinal.js": [
		51,
		9,
		0,
		1,
		4
	],
	"./PipeLine": [
		5,
		9,
		0,
		22
	],
	"./PipeLine.js": [
		5,
		9,
		0,
		22
	],
	"./Scene": [
		31,
		9
	],
	"./Scene.js": [
		31,
		9
	],
	"./Shape": [
		52,
		9,
		0,
		11
	],
	"./Shape.js": [
		52,
		9,
		0,
		11
	],
	"./Torus": [
		6,
		9,
		23
	],
	"./Torus.js": [
		6,
		9,
		23
	],
	"./advanced_light/Bloom": [
		53,
		7,
		24
	],
	"./advanced_light/Bloom.js": [
		53,
		7,
		24
	],
	"./advanced_light/DeferredShading": [
		54,
		9,
		0,
		1,
		6
	],
	"./advanced_light/DeferredShading.js": [
		54,
		9,
		0,
		1,
		6
	],
	"./advanced_light/HeightMap": [
		55,
		7,
		25
	],
	"./advanced_light/HeightMap.js": [
		55,
		7,
		25
	],
	"./advanced_light/NormalMap": [
		56,
		9,
		0,
		1,
		18
	],
	"./advanced_light/NormalMap.js": [
		56,
		9,
		0,
		1,
		18
	],
	"./advanced_light/SSAO": [
		57,
		9,
		0,
		1,
		7
	],
	"./advanced_light/SSAO.js": [
		57,
		9,
		0,
		1,
		7
	],
	"./advanced_light/Shadow": [
		58,
		9,
		0,
		1,
		10
	],
	"./advanced_light/Shadow.js": [
		58,
		9,
		0,
		1,
		10
	],
	"./app": [
		32,
		9
	],
	"./app.js": [
		32,
		9
	]
};
function webpackAsyncContext(req) {
	var ids = map[req];
	if(!ids) {
		return Promise.resolve().then(function() {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}
	return Promise.all(ids.slice(2).map(__webpack_require__.e)).then(function() {
		var id = ids[0];
		return __webpack_require__.t(id, ids[1])
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.id = 124;
module.exports = webpackAsyncContext;var mat4_namespaceObject = {};
__webpack_require__.r(mat4_namespaceObject);
__webpack_require__.d(mat4_namespaceObject, "create", function() { return create; });
__webpack_require__.d(mat4_namespaceObject, "clone", function() { return clone; });
__webpack_require__.d(mat4_namespaceObject, "copy", function() { return copy; });
__webpack_require__.d(mat4_namespaceObject, "fromValues", function() { return fromValues; });
__webpack_require__.d(mat4_namespaceObject, "set", function() { return set; });
__webpack_require__.d(mat4_namespaceObject, "identity", function() { return identity; });
__webpack_require__.d(mat4_namespaceObject, "transpose", function() { return transpose; });
__webpack_require__.d(mat4_namespaceObject, "invert", function() { return invert; });
__webpack_require__.d(mat4_namespaceObject, "adjoint", function() { return adjoint; });
__webpack_require__.d(mat4_namespaceObject, "determinant", function() { return determinant; });
__webpack_require__.d(mat4_namespaceObject, "multiply", function() { return multiply; });
__webpack_require__.d(mat4_namespaceObject, "translate", function() { return translate; });
__webpack_require__.d(mat4_namespaceObject, "scale", function() { return mat4_scale; });
__webpack_require__.d(mat4_namespaceObject, "rotate", function() { return rotate; });
__webpack_require__.d(mat4_namespaceObject, "rotateX", function() { return rotateX; });
__webpack_require__.d(mat4_namespaceObject, "rotateY", function() { return rotateY; });
__webpack_require__.d(mat4_namespaceObject, "rotateZ", function() { return rotateZ; });
__webpack_require__.d(mat4_namespaceObject, "fromTranslation", function() { return fromTranslation; });
__webpack_require__.d(mat4_namespaceObject, "fromScaling", function() { return fromScaling; });
__webpack_require__.d(mat4_namespaceObject, "fromRotation", function() { return fromRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromXRotation", function() { return fromXRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromYRotation", function() { return fromYRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromZRotation", function() { return fromZRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromRotationTranslation", function() { return fromRotationTranslation; });
__webpack_require__.d(mat4_namespaceObject, "fromQuat2", function() { return fromQuat2; });
__webpack_require__.d(mat4_namespaceObject, "getTranslation", function() { return getTranslation; });
__webpack_require__.d(mat4_namespaceObject, "getScaling", function() { return getScaling; });
__webpack_require__.d(mat4_namespaceObject, "getRotation", function() { return getRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
__webpack_require__.d(mat4_namespaceObject, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
__webpack_require__.d(mat4_namespaceObject, "fromQuat", function() { return fromQuat; });
__webpack_require__.d(mat4_namespaceObject, "frustum", function() { return frustum; });
__webpack_require__.d(mat4_namespaceObject, "perspective", function() { return perspective; });
__webpack_require__.d(mat4_namespaceObject, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
__webpack_require__.d(mat4_namespaceObject, "ortho", function() { return ortho; });
__webpack_require__.d(mat4_namespaceObject, "lookAt", function() { return lookAt; });
__webpack_require__.d(mat4_namespaceObject, "targetTo", function() { return targetTo; });
__webpack_require__.d(mat4_namespaceObject, "str", function() { return str; });
__webpack_require__.d(mat4_namespaceObject, "frob", function() { return frob; });
__webpack_require__.d(mat4_namespaceObject, "add", function() { return add; });
__webpack_require__.d(mat4_namespaceObject, "subtract", function() { return subtract; });
__webpack_require__.d(mat4_namespaceObject, "multiplyScalar", function() { return multiplyScalar; });
__webpack_require__.d(mat4_namespaceObject, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
__webpack_require__.d(mat4_namespaceObject, "exactEquals", function() { return exactEquals; });
__webpack_require__.d(mat4_namespaceObject, "equals", function() { return mat4_equals; });
__webpack_require__.d(mat4_namespaceObject, "mul", function() { return mul; });
__webpack_require__.d(mat4_namespaceObject, "sub", function() { return sub; });
var vec3_namespaceObject = {};
__webpack_require__.r(vec3_namespaceObject);
__webpack_require__.d(vec3_namespaceObject, "create", function() { return vec3_create; });
__webpack_require__.d(vec3_namespaceObject, "clone", function() { return vec3_clone; });
__webpack_require__.d(vec3_namespaceObject, "length", function() { return vec3_length; });
__webpack_require__.d(vec3_namespaceObject, "fromValues", function() { return vec3_fromValues; });
__webpack_require__.d(vec3_namespaceObject, "copy", function() { return vec3_copy; });
__webpack_require__.d(vec3_namespaceObject, "set", function() { return vec3_set; });
__webpack_require__.d(vec3_namespaceObject, "add", function() { return vec3_add; });
__webpack_require__.d(vec3_namespaceObject, "subtract", function() { return vec3_subtract; });
__webpack_require__.d(vec3_namespaceObject, "multiply", function() { return vec3_multiply; });
__webpack_require__.d(vec3_namespaceObject, "divide", function() { return divide; });
__webpack_require__.d(vec3_namespaceObject, "ceil", function() { return ceil; });
__webpack_require__.d(vec3_namespaceObject, "floor", function() { return floor; });
__webpack_require__.d(vec3_namespaceObject, "min", function() { return min; });
__webpack_require__.d(vec3_namespaceObject, "max", function() { return max; });
__webpack_require__.d(vec3_namespaceObject, "round", function() { return round; });
__webpack_require__.d(vec3_namespaceObject, "scale", function() { return vec3_scale; });
__webpack_require__.d(vec3_namespaceObject, "scaleAndAdd", function() { return scaleAndAdd; });
__webpack_require__.d(vec3_namespaceObject, "distance", function() { return distance; });
__webpack_require__.d(vec3_namespaceObject, "squaredDistance", function() { return squaredDistance; });
__webpack_require__.d(vec3_namespaceObject, "squaredLength", function() { return squaredLength; });
__webpack_require__.d(vec3_namespaceObject, "negate", function() { return negate; });
__webpack_require__.d(vec3_namespaceObject, "inverse", function() { return inverse; });
__webpack_require__.d(vec3_namespaceObject, "normalize", function() { return normalize; });
__webpack_require__.d(vec3_namespaceObject, "dot", function() { return vec3_dot; });
__webpack_require__.d(vec3_namespaceObject, "cross", function() { return cross; });
__webpack_require__.d(vec3_namespaceObject, "lerp", function() { return lerp; });
__webpack_require__.d(vec3_namespaceObject, "hermite", function() { return hermite; });
__webpack_require__.d(vec3_namespaceObject, "bezier", function() { return bezier; });
__webpack_require__.d(vec3_namespaceObject, "random", function() { return random; });
__webpack_require__.d(vec3_namespaceObject, "transformMat4", function() { return transformMat4; });
__webpack_require__.d(vec3_namespaceObject, "transformMat3", function() { return transformMat3; });
__webpack_require__.d(vec3_namespaceObject, "transformQuat", function() { return transformQuat; });
__webpack_require__.d(vec3_namespaceObject, "rotateX", function() { return vec3_rotateX; });
__webpack_require__.d(vec3_namespaceObject, "rotateY", function() { return vec3_rotateY; });
__webpack_require__.d(vec3_namespaceObject, "rotateZ", function() { return vec3_rotateZ; });
__webpack_require__.d(vec3_namespaceObject, "angle", function() { return angle; });
__webpack_require__.d(vec3_namespaceObject, "str", function() { return vec3_str; });
__webpack_require__.d(vec3_namespaceObject, "exactEquals", function() { return vec3_exactEquals; });
__webpack_require__.d(vec3_namespaceObject, "equals", function() { return vec3_equals; });
__webpack_require__.d(vec3_namespaceObject, "sub", function() { return vec3_sub; });
__webpack_require__.d(vec3_namespaceObject, "mul", function() { return vec3_mul; });
__webpack_require__.d(vec3_namespaceObject, "div", function() { return div; });
__webpack_require__.d(vec3_namespaceObject, "dist", function() { return dist; });
__webpack_require__.d(vec3_namespaceObject, "sqrDist", function() { return sqrDist; });
__webpack_require__.d(vec3_namespaceObject, "len", function() { return vec3_len; });
__webpack_require__.d(vec3_namespaceObject, "sqrLen", function() { return sqrLen; });
__webpack_require__.d(vec3_namespaceObject, "forEach", function() { return forEach; });
var quat_namespaceObject = {};
__webpack_require__.r(quat_namespaceObject);
__webpack_require__.d(quat_namespaceObject, "create", function() { return quat_create; });
__webpack_require__.d(quat_namespaceObject, "identity", function() { return quat_identity; });
__webpack_require__.d(quat_namespaceObject, "setAxisAngle", function() { return setAxisAngle; });
__webpack_require__.d(quat_namespaceObject, "getAxisAngle", function() { return getAxisAngle; });
__webpack_require__.d(quat_namespaceObject, "multiply", function() { return quat_multiply; });
__webpack_require__.d(quat_namespaceObject, "rotateX", function() { return quat_rotateX; });
__webpack_require__.d(quat_namespaceObject, "rotateY", function() { return quat_rotateY; });
__webpack_require__.d(quat_namespaceObject, "rotateZ", function() { return quat_rotateZ; });
__webpack_require__.d(quat_namespaceObject, "calculateW", function() { return calculateW; });
__webpack_require__.d(quat_namespaceObject, "slerp", function() { return slerp; });
__webpack_require__.d(quat_namespaceObject, "random", function() { return quat_random; });
__webpack_require__.d(quat_namespaceObject, "invert", function() { return quat_invert; });
__webpack_require__.d(quat_namespaceObject, "conjugate", function() { return conjugate; });
__webpack_require__.d(quat_namespaceObject, "fromMat3", function() { return fromMat3; });
__webpack_require__.d(quat_namespaceObject, "fromEuler", function() { return fromEuler; });
__webpack_require__.d(quat_namespaceObject, "str", function() { return quat_str; });
__webpack_require__.d(quat_namespaceObject, "clone", function() { return quat_clone; });
__webpack_require__.d(quat_namespaceObject, "fromValues", function() { return quat_fromValues; });
__webpack_require__.d(quat_namespaceObject, "copy", function() { return quat_copy; });
__webpack_require__.d(quat_namespaceObject, "set", function() { return quat_set; });
__webpack_require__.d(quat_namespaceObject, "add", function() { return quat_add; });
__webpack_require__.d(quat_namespaceObject, "mul", function() { return quat_mul; });
__webpack_require__.d(quat_namespaceObject, "scale", function() { return quat_scale; });
__webpack_require__.d(quat_namespaceObject, "dot", function() { return quat_dot; });
__webpack_require__.d(quat_namespaceObject, "lerp", function() { return quat_lerp; });
__webpack_require__.d(quat_namespaceObject, "length", function() { return quat_length; });
__webpack_require__.d(quat_namespaceObject, "len", function() { return quat_len; });
__webpack_require__.d(quat_namespaceObject, "squaredLength", function() { return quat_squaredLength; });
__webpack_require__.d(quat_namespaceObject, "sqrLen", function() { return quat_sqrLen; });
__webpack_require__.d(quat_namespaceObject, "normalize", function() { return quat_normalize; });
__webpack_require__.d(quat_namespaceObject, "exactEquals", function() { return quat_exactEquals; });
__webpack_require__.d(quat_namespaceObject, "equals", function() { return quat_equals; });
__webpack_require__.d(quat_namespaceObject, "rotationTo", function() { return rotationTo; });
__webpack_require__.d(quat_namespaceObject, "sqlerp", function() { return sqlerp; });
__webpack_require__.d(quat_namespaceObject, "setAxes", function() { return setAxes; });
var vec2_namespaceObject = {};
__webpack_require__.r(vec2_namespaceObject);
__webpack_require__.d(vec2_namespaceObject, "create", function() { return vec2_create; });
__webpack_require__.d(vec2_namespaceObject, "clone", function() { return vec2_clone; });
__webpack_require__.d(vec2_namespaceObject, "fromValues", function() { return vec2_fromValues; });
__webpack_require__.d(vec2_namespaceObject, "copy", function() { return vec2_copy; });
__webpack_require__.d(vec2_namespaceObject, "set", function() { return vec2_set; });
__webpack_require__.d(vec2_namespaceObject, "add", function() { return vec2_add; });
__webpack_require__.d(vec2_namespaceObject, "subtract", function() { return vec2_subtract; });
__webpack_require__.d(vec2_namespaceObject, "multiply", function() { return vec2_multiply; });
__webpack_require__.d(vec2_namespaceObject, "divide", function() { return vec2_divide; });
__webpack_require__.d(vec2_namespaceObject, "ceil", function() { return vec2_ceil; });
__webpack_require__.d(vec2_namespaceObject, "floor", function() { return vec2_floor; });
__webpack_require__.d(vec2_namespaceObject, "min", function() { return vec2_min; });
__webpack_require__.d(vec2_namespaceObject, "max", function() { return vec2_max; });
__webpack_require__.d(vec2_namespaceObject, "round", function() { return vec2_round; });
__webpack_require__.d(vec2_namespaceObject, "scale", function() { return vec2_scale; });
__webpack_require__.d(vec2_namespaceObject, "scaleAndAdd", function() { return vec2_scaleAndAdd; });
__webpack_require__.d(vec2_namespaceObject, "distance", function() { return vec2_distance; });
__webpack_require__.d(vec2_namespaceObject, "squaredDistance", function() { return vec2_squaredDistance; });
__webpack_require__.d(vec2_namespaceObject, "length", function() { return vec2_length; });
__webpack_require__.d(vec2_namespaceObject, "squaredLength", function() { return vec2_squaredLength; });
__webpack_require__.d(vec2_namespaceObject, "negate", function() { return vec2_negate; });
__webpack_require__.d(vec2_namespaceObject, "inverse", function() { return vec2_inverse; });
__webpack_require__.d(vec2_namespaceObject, "normalize", function() { return vec2_normalize; });
__webpack_require__.d(vec2_namespaceObject, "dot", function() { return vec2_dot; });
__webpack_require__.d(vec2_namespaceObject, "cross", function() { return vec2_cross; });
__webpack_require__.d(vec2_namespaceObject, "lerp", function() { return vec2_lerp; });
__webpack_require__.d(vec2_namespaceObject, "random", function() { return vec2_random; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2", function() { return transformMat2; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2d", function() { return transformMat2d; });
__webpack_require__.d(vec2_namespaceObject, "transformMat3", function() { return vec2_transformMat3; });
__webpack_require__.d(vec2_namespaceObject, "transformMat4", function() { return vec2_transformMat4; });
__webpack_require__.d(vec2_namespaceObject, "rotate", function() { return vec2_rotate; });
__webpack_require__.d(vec2_namespaceObject, "angle", function() { return vec2_angle; });
__webpack_require__.d(vec2_namespaceObject, "str", function() { return vec2_str; });
__webpack_require__.d(vec2_namespaceObject, "exactEquals", function() { return vec2_exactEquals; });
__webpack_require__.d(vec2_namespaceObject, "equals", function() { return vec2_equals; });
__webpack_require__.d(vec2_namespaceObject, "len", function() { return vec2_len; });
__webpack_require__.d(vec2_namespaceObject, "sub", function() { return vec2_sub; });
__webpack_require__.d(vec2_namespaceObject, "mul", function() { return vec2_mul; });
__webpack_require__.d(vec2_namespaceObject, "div", function() { return vec2_div; });
__webpack_require__.d(vec2_namespaceObject, "dist", function() { return vec2_dist; });
__webpack_require__.d(vec2_namespaceObject, "sqrDist", function() { return vec2_sqrDist; });
__webpack_require__.d(vec2_namespaceObject, "sqrLen", function() { return vec2_sqrLen; });
__webpack_require__.d(vec2_namespaceObject, "forEach", function() { return vec2_forEach; });

// CONCATENATED MODULE: ./node_modules/gl-matrix/src/gl-matrix/common.js
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = 0.000001;
let ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
const RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

const degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

// CONCATENATED MODULE: ./node_modules/gl-matrix/src/gl-matrix/mat4.js


/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  let out = new ARRAY_TYPE(16);
  if(ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  let out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a03 = a[3];
    let a12 = a[6], a13 = a[7];
    let a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  let x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function mat4_scale(out, a, v) {
  let x = v[0], y = v[1], z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;
  let b00, b01, b02;
  let b10, b11, b12;
  let b20, b21, b22;

  if (len < EPSILON) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[0]  = a[0];
    out[1]  = a[1];
    out[2]  = a[2];
    out[3]  = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[4]  = a[4];
    out[5]  = a[5];
    out[6]  = a[6];
    out[7]  = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[8]  = a[8];
    out[9]  = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;

  if (len < EPSILON) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = 1;
  out[1]  = 0;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = 0;
  out[2]  = -s;
  out[3]  = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = s;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */
function fromQuat2(out, a) {
  let translation = new ARRAY_TYPE(3);
  let bx = -a[0], by = -a[1], bz = -a[2], bw = a[3],
  ax = a[4], ay = a[5], az = a[6], aw = a[7];

  let magnitude = bx * bx + by * by + bz * bz + bw * bw;
  //Only scale if it makes sense
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  let m11 = mat[0];
  let m12 = mat[1];
  let m13 = mat[2];
  let m21 = mat[4];
  let m22 = mat[5];
  let m23 = mat[6];
  let m31 = mat[8];
  let m32 = mat[9];
  let m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if ((mat[0] > mat[5]) && (mat[0] > mat[10])) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  let ox = o[0];
  let oy = o[1];
  let oz = o[2];

  let out0 = (1 - (yy + zz)) * sx;
  let out1 = (xy + wz) * sx;
  let out2 = (xz - wy) * sx;
  let out4 = (xy - wz) * sy;
  let out5 = (1 - (xx + zz)) * sy;
  let out6 = (yz + wx) * sy;
  let out8 = (xz + wy) * sz;
  let out9 = (yz - wx) * sz;
  let out10 = (1 - (xx + yy)) * sz;

  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  let rl = 1 / (right - left);
  let tb = 1 / (top - bottom);
  let nf = 1 / (near - far);
  out[0] = (near * 2) * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = (near * 2) * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (far * near * 2) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = (2 * far * near) * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);
  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);
  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);
  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);
  let xScale = 2.0 / (leftTan + rightTan);
  let yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = ((upTan - downTan) * yScale * 0.5);
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = (far * near) / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  let lr = 1 / (left - right);
  let bt = 1 / (bottom - top);
  let nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < EPSILON &&
      Math.abs(eyey - centery) < EPSILON &&
      Math.abs(eyez - centerz) < EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  let eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  let z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  let len = z0*z0 + z1*z1 + z2*z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  let x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  len = x0*x0 + x1*x1 + x2*x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  out[9] = a[9] + (b[9] * scale);
  out[10] = a[10] + (b[10] * scale);
  out[11] = a[11] + (b[11] * scale);
  out[12] = a[12] + (b[12] * scale);
  out[13] = a[13] + (b[13] * scale);
  out[14] = a[14] + (b[14] * scale);
  out[15] = a[15] + (b[15] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function mat4_equals(a, b) {
  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];
  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];
  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];
  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];
  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];
  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];
  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

  return (Math.abs(a0 - b0) <= EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
          Math.abs(a9 - b9) <= EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
          Math.abs(a10 - b10) <= EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
          Math.abs(a11 - b11) <= EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
          Math.abs(a12 - b12) <= EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
          Math.abs(a13 - b13) <= EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
          Math.abs(a14 - b14) <= EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
          Math.abs(a15 - b15) <= EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
const mul = multiply;

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
const sub = subtract;

// CONCATENATED MODULE: ./node_modules/gl-matrix/src/gl-matrix/mat3.js


/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function mat3_create() {
  let out = new ARRAY_TYPE(9);
  if(ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function mat3_clone(a) {
  let out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function mat3_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function mat3_fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function mat3_set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function mat3_identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function mat3_transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function mat3_invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b01 = a22 * a11 - a12 * a21;
  let b11 = -a22 * a10 + a12 * a20;
  let b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  let det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function mat3_adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  out[0] = (a11 * a22 - a12 * a21);
  out[1] = (a02 * a21 - a01 * a22);
  out[2] = (a01 * a12 - a02 * a11);
  out[3] = (a12 * a20 - a10 * a22);
  out[4] = (a00 * a22 - a02 * a20);
  out[5] = (a02 * a10 - a00 * a12);
  out[6] = (a10 * a21 - a11 * a20);
  out[7] = (a01 * a20 - a00 * a21);
  out[8] = (a00 * a11 - a01 * a10);
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function mat3_determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function mat3_multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b00 = b[0], b01 = b[1], b02 = b[2];
  let b10 = b[3], b11 = b[4], b12 = b[5];
  let b20 = b[6], b21 = b[7], b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function mat3_translate(out, a, v) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],
    x = v[0], y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function mat3_rotate(out, a, rad) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],

    s = Math.sin(rad),
    c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function mat3_scale(out, a, v) {
  let x = v[0], y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function mat3_fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function mat3_fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function mat3_fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function mat3_fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function mat3_str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
          a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function mat3_frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function mat3_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function mat3_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}



/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function mat3_multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function mat3_multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function mat3_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function mat3_equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return (Math.abs(a0 - b0) <= EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
const mat3_mul = mat3_multiply;

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
const mat3_sub = mat3_subtract;

// CONCATENATED MODULE: ./node_modules/gl-matrix/src/gl-matrix/vec3.js


/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function vec3_create() {
  let out = new ARRAY_TYPE(3);
  if(ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function vec3_clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec3_length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function vec3_fromValues(x, y, z) {
  let out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function vec3_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function vec3_set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function vec3_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function vec3_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function vec3_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function vec3_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return x*x + y*y + z*z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return x*x + y*y + z*z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x*x + y*y + z*z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function vec3_dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  let factorTimes2 = t * t;
  let factor1 = factorTimes2 * (2 * t - 3) + 1;
  let factor2 = factorTimes2 * (t - 2) + t;
  let factor3 = factorTimes2 * (t - 1);
  let factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  let inverseFactor = 1 - t;
  let inverseFactorTimesTwo = inverseFactor * inverseFactor;
  let factorTimes2 = t * t;
  let factor1 = inverseFactorTimesTwo * inverseFactor;
  let factor2 = 3 * t * inverseFactorTimesTwo;
  let factor3 = 3 * factorTimes2 * inverseFactor;
  let factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  let r = RANDOM() * 2.0 * Math.PI;
  let z = (RANDOM() * 2.0) - 1.0;
  let zScale = Math.sqrt(1.0-z*z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    let qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    let x = a[0], y = a[1], z = a[2];
    // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);
    let uvx = qy * z - qz * y,
        uvy = qz * x - qx * z,
        uvz = qx * y - qy * x;
    // var uuv = vec3.cross([], qvec, uv);
    let uuvx = qy * uvz - qz * uvy,
        uuvy = qz * uvx - qx * uvz,
        uuvz = qx * uvy - qy * uvx;
    // vec3.scale(uv, uv, 2 * w);
    let w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    // vec3.scale(uuv, uuv, 2);
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    // return vec3.add(out, a, vec3.add(out, uv, uuv));
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function vec3_rotateX(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function vec3_rotateY(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  r[1] = p[1];
  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function vec3_rotateZ(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  let tempA = vec3_fromValues(a[0], a[1], a[2]);
  let tempB = vec3_fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  let cosine = vec3_dot(tempA, tempB);

  if(cosine > 1.0) {
    return 0;
  }
  else if(cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec3_str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2];
  let b0 = b[0], b1 = b[1], b2 = b[2];
  return (Math.abs(a0 - b0) <= EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
const vec3_sub = vec3_subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
const vec3_mul = vec3_multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
const div = divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
const dist = distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
const vec3_len = vec3_length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
const sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = vec3_create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 3;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
    }

    return a;
  };
})();

// CONCATENATED MODULE: ./node_modules/gl-matrix/src/gl-matrix/vec4.js


/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function vec4_create() {
  let out = new ARRAY_TYPE(4);
  if(ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function vec4_clone(a) {
  let out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function vec4_fromValues(x, y, z, w) {
  let out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function vec4_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function vec4_set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function vec4_ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function vec4_floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function vec4_round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function vec4_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function vec4_scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function vec4_distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function vec4_squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec4_length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function vec4_squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function vec4_negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function vec4_inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function vec4_normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x*x + y*y + z*z + w*w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function vec4_dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */
function vec4_lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  let aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function vec4_random(out, scale) {
  scale = scale || 1.0;

  // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function vec4_transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function vec4_transformQuat(out, a, q) {
  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec4_str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec4_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec4_equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
const vec4_sub = vec4_subtract;

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
const vec4_mul = vec4_multiply;

/**
 * Alias for {@link vec4.divide}
 * @function
 */
const vec4_div = vec4_divide;

/**
 * Alias for {@link vec4.distance}
 * @function
 */
const vec4_dist = vec4_distance;

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
const vec4_sqrDist = vec4_squaredDistance;

/**
 * Alias for {@link vec4.length}
 * @function
 */
const vec4_len = vec4_length;

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
const vec4_sqrLen = vec4_squaredLength;

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const vec4_forEach = (function() {
  let vec = vec4_create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 4;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
    }

    return a;
  };
})();

// CONCATENATED MODULE: ./node_modules/gl-matrix/src/gl-matrix/quat.js





/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function quat_create() {
  let out = new ARRAY_TYPE(4);
  if(ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function quat_identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  let rad = Math.acos(q[3]) * 2.0;
  let s = Math.sin(rad / 2.0);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function quat_multiply(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function quat_rotateX(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function quat_rotateY(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let by = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function quat_rotateZ(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bz = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  let x = a[0], y = a[1], z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > EPSILON ) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function quat_random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  let u1 = RANDOM();
  let u2 = RANDOM();
  let u3 = RANDOM();

  let sqrt1MinusU1 = Math.sqrt(1 - u1);
  let sqrtU1 = Math.sqrt(u1);

  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function quat_invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
  let invDot = dot ? 1.0/dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0*invDot;
  out[1] = -a1*invDot;
  out[2] = -a2*invDot;
  out[3] = a3*invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if ( fTrace > 0.0 ) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5/fRoot;  // 1/(4w)
    out[0] = (m[5]-m[7])*fRoot;
    out[1] = (m[6]-m[2])*fRoot;
    out[2] = (m[1]-m[3])*fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if ( m[4] > m[0] )
      i = 1;
    if ( m[8] > m[i*3+i] )
      i = 2;
    let j = (i+1)%3;
    let k = (i+2)%3;

    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
    let halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;

    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);

    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;

    return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function quat_str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
const quat_clone = vec4_clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
const quat_fromValues = vec4_fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
const quat_copy = vec4_copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
const quat_set = vec4_set;

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
const quat_add = vec4_add;

/**
 * Alias for {@link quat.multiply}
 * @function
 */
const quat_mul = quat_multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
const quat_scale = vec4_scale;

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
const quat_dot = vec4_dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */
const quat_lerp = vec4_lerp;

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
const quat_length = vec4_length;

/**
 * Alias for {@link quat.length}
 * @function
 */
const quat_len = quat_length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
const quat_squaredLength = vec4_squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
const quat_sqrLen = quat_squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const quat_normalize = vec4_normalize;

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const quat_exactEquals = vec4_exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const quat_equals = vec4_equals;

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
const rotationTo = (function() {
  let tmpvec3 = vec3_create();
  let xUnitVec3 = vec3_fromValues(1,0,0);
  let yUnitVec3 = vec3_fromValues(0,1,0);

  return function(out, a, b) {
    let dot = vec3_dot(a, b);
    if (dot < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (vec3_len(tmpvec3) < 0.000001)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return quat_normalize(out, out);
    }
  };
})();

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
const sqlerp = (function () {
  let temp1 = quat_create();
  let temp2 = quat_create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
const setAxes = (function() {
  let matr = mat3_create();

  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return quat_normalize(out, fromMat3(out, matr));
  };
})();

// CONCATENATED MODULE: ./node_modules/gl-matrix/src/gl-matrix/vec2.js


/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function vec2_create() {
  let out = new ARRAY_TYPE(2);
  if(ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function vec2_clone(a) {
  let out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function vec2_fromValues(x, y) {
  let out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function vec2_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function vec2_set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function vec2_ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function vec2_floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function vec2_round (out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function vec2_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function vec2_scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function vec2_distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x*x + y*y);
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function vec2_squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x*x + y*y;
}

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec2_length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x*x + y*y);
}

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function vec2_squaredLength (a) {
  var x = a[0],
    y = a[1];
  return x*x + y*y;
}

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function vec2_negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function vec2_inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function vec2_normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x*x + y*y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function vec2_dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function vec2_cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */
function vec2_lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function vec2_random(out, scale) {
  scale = scale || 1.0;
  var r = RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function vec2_transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function vec2_transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */
function vec2_rotate(out, a, b, c) {
  //Translate point to the origin
  let p0 = a[0] - b[0],
  p1 = a[1] - b[1],
  sinC = Math.sin(c),
  cosC = Math.cos(c);
  
  //perform rotation and translate to correct position
  out[0] = p0*cosC - p1*sinC + b[0];
  out[1] = p0*sinC + p1*cosC + b[1];

  return out;
}

/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */
function vec2_angle(a, b) {
  let x1 = a[0],
    y1 = a[1],
    x2 = b[0],
    y2 = b[1];
  
  let len1 = x1*x1 + y1*y1;
  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }
  
  let len2 = x2*x2 + y2*y2;
  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }
  
  let cosine = (x1 * x2 + y1 * y2) * len1 * len2;
  
  
  if(cosine > 1.0) {
    return 0;
  }
  else if(cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec2_str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_equals(a, b) {
  let a0 = a[0], a1 = a[1];
  let b0 = b[0], b1 = b[1];
  return (Math.abs(a0 - b0) <= EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
const vec2_len = vec2_length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const vec2_sub = vec2_subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
const vec2_mul = vec2_multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
const vec2_div = vec2_divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
const vec2_dist = vec2_distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const vec2_sqrDist = vec2_squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
const vec2_sqrLen = vec2_squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const vec2_forEach = (function() {
  let vec = vec2_create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 2;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1];
    }

    return a;
  };
})();

// CONCATENATED MODULE: ./node_modules/gl-matrix/src/gl-matrix.js
/* unused concated harmony import glMatrix */
/* unused concated harmony import mat3 */
/* concated harmony reexport mat4 */__webpack_require__.d(__webpack_exports__, "a", function() { return mat4_namespaceObject; });
/* concated harmony reexport quat */__webpack_require__.d(__webpack_exports__, "b", function() { return quat_namespaceObject; });
/* concated harmony reexport vec2 */__webpack_require__.d(__webpack_exports__, "c", function() { return vec2_namespaceObject; });
/* concated harmony reexport vec3 */__webpack_require__.d(__webpack_exports__, "d", function() { return vec3_namespaceObject; });
/* unused concated harmony import vec4 */












__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(2);

// CONCATENATED MODULE: ./libs/glProgram.js
var _UID = 0;
/**
 * Program constructor. Create gl program and shaders. You can pass optional shader code to immediatly compile shaders
 *   @param {WebGLRenderingContext} gl webgl context this program belongs to
 *   @param {String} [vert=undefined] an optional vertex shader code. See {@link Program#compile}
 *   @param {String} [frag=undefined] an optional fragment shader code See {@link Program#compile}
 *   @param {String} [defs=undefined] an optional string prepend to both fragment and vertex shader code. See {@link Program#compile}.
 *   @see {@link Program#compile}
 *
 * @example <caption>For the given vertex shader</caption>
 * attribute vec3 aPosition;
 * uniform mat4 uMVP;
 * uniform vec3 uCameraPosition;
 *
 * @class
 * @classdesc Program class provide shader compilation and linking functionality.
 *              It also give you convenient access to active uniforms and attributes.
 *              Once compiled, the Program object list all used uniforms/attributes and provide getter/setter function for each one. See {@link Program} constructor.
 *
 */

function Program(gl, vert, frag, defs) {
  this.gl = gl;
  this.program = gl.createProgram();
  this.vShader = gl.createShader(gl.VERTEX_SHADER);
  this.fShader = gl.createShader(gl.FRAGMENT_SHADER);
  this.dyns = [];
  this.uniforms = [];
  this.ready = false;
  gl.attachShader(this.program, this.vShader);
  gl.attachShader(this.program, this.fShader);
  this._uid = _UID++ | 0;
  this._cuid = _UID++ | 0;

  if (vert !== undefined && frag !== undefined) {
    this.compile(vert, frag, defs);
  }

  this.unAssigned = [];
  this.prevTime = 0;
}
/**
 * Program.debug
 *   can be set to true to check and log compilation and linking errors (default to false)
 */


Program.debug = true;
Program.prototype = {
  /**
   * Shortcut for gl.useProgram()
   * alias program.bind()
   */
  use: function () {
    if (!this.ready) {
      this._grabParameters();
    }

    this.gl.useProgram(this.program);
  },
  style: function (opt, skip) {
    if (JSON.stringify(opt) === '{}' && this.uniforms.length === 0) {
      return;
    } else if (JSON.stringify(opt) === '{}' && this.uniforms.length > 0) {
      throw new Error('active uniform not assigned:' + this.uniforms);
    }

    for (let k in opt) {
      if (typeof this[k] === 'function') {
        this[k](opt[k]);
      } else {// throw new Error('not find in shader:' + k)
      }
    }

    this.unAssigned = this.unAssigned.filter(v => {
      let assign = false;

      for (let k in opt) {
        if (k === v) assign = true;
      }

      if (assign) return false;
      return true;
    });

    if (Date.now() - this.prevTime < 1000 / 16 * 1000 && this.unAssigned.length === 0 && !(this.timer === null)) {
      clearTimeout(this.timer);
      this.timer = null;
    }

    if (this.unAssigned.length !== 0 && skip === undefined) {
      this.timer = setTimeout(() => {
        if (this.unAssigned.length > 0) throw new Error('active uniform not assigned: ' + this.unAssigned);
      }, 1 / 16);
    }

    this.prevTime = Date.now();
  },

  /**
   * Compile vertex and fragment shader then link gl program
   * This method can be safely called several times.
   *  @param {String} vert vertex shader code
   *  @param {String} frag fragment shader code
   *  @param {String} [prefix=''] an optional string append to both fragment and vertex code
   */
  compile: function (vert, frag, prefix) {
    this.ready = false;
    prefix = prefix || ''; // + '\n'

    var gl = this.gl;

    if (!(compileShader(gl, this.fShader, prefix + frag) && compileShader(gl, this.vShader, prefix + vert))) {
      return false;
    }

    gl.linkProgram(this.program);

    if (Program.debug && !gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
      warn(gl.getProgramInfoLog(this.program));
      return false;
    } // delete old accessors


    while (this.dyns.length > 0) {
      delete this[this.dyns.pop()];
    }

    this._cuid = _UID++ | 0;
    return true;
  },

  /**
    * Delete program and shaders
    */
  dispose: function () {
    if (this.gl !== null) {
      this.gl.deleteProgram(this.program);
      this.gl.deleteShader(this.fShader);
      this.gl.deleteShader(this.vShader);
      this.gl = null;
    }
  },

  /*
   *  List all uniforms and attributes and create helper function on Program instance
   *  eg :
   *     for a uniform vec3 uDirection;
   *     create a method
   *        program.uDirection( 1, 0, 0 );
   */
  _grabParameters: function () {
    var gl = this.gl,
        prg = this.program; // Uniforms
    // ========

    var numUniforms = gl.getProgramParameter(prg, gl.ACTIVE_UNIFORMS);
    var context = {
      texIndex: 0
    };

    for (var uniformIndex = 0; uniformIndex < numUniforms; ++uniformIndex) {
      var uniform = gl.getActiveUniform(prg, uniformIndex); // safari 8.0 issue,
      // when recompiling shader and link the progam again, old uniforms are kept in ACTIVE_UNIFORMS count but return null here

      if (uniform === null) {
        gl.getError(); // also flush error

        continue;
      }

      var uName = uniform.name,
          n = uName.indexOf('[');

      if (n >= 0) {
        uName = uName.substring(0, n);
      }

      var uLocation = gl.getUniformLocation(prg, uniform.name);
      this[uName] = getUniformSetter(uniform.type, uLocation, gl, context);
      this.dyns.push(uName);
      this.uniforms.push(uName);
      this.unAssigned.push(uName);
    } // Attributes
    // ==========


    var numAttribs = gl.getProgramParameter(prg, gl.ACTIVE_ATTRIBUTES);

    for (var aIndex = 0; aIndex < numAttribs; ++aIndex) {
      var attribName = gl.getActiveAttrib(prg, aIndex).name;
      var aLocation = gl.getAttribLocation(prg, attribName);
      this[attribName] = getAttribAccess(aLocation);
      this.dyns.push(attribName);
    }

    this.ready = true;
  }
  /**
   * alias to Program.use()
   */

};
Program.prototype.bind = Program.prototype.use;
/*
 * internal logs
 */

function warn(str) {
  console.warn(str);
} // -------------------------------------------------
//                    UTILITIES
// -------------------------------------------------

/*
 * Shader logging utilities
 */


var __pads = ['', '   ', '  ', ' ', ''];

function appendLine(l, i) {
  return __pads[String(i + 1).length] + (i + 1) + ': ' + l;
}
/*
 * Format shader code
 * add padded lines number
 */


function formatCode(shader) {
  return shader.split('\n').map(appendLine).join('\n');
}
/*
 * Shader compilation utility
 */


function compileShader(gl, shader, code) {
  gl.shaderSource(shader, code);
  gl.compileShader(shader);

  if (Program.debug && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    warn(gl.getShaderInfoLog(shader));
    warn(formatCode(code));
    return false;
  }

  return true;
}

var USetFMap = {};
USetFMap[5126
/* FLOAT       */
] = '1f';
USetFMap[35664
/* FLOAT_VEC2  */
] = '2f';
USetFMap[35665
/* FLOAT_VEC3  */
] = '3f';
USetFMap[35666
/* FLOAT_VEC4  */
] = '4f';
USetFMap[35670
/* BOOL        */
] = USetFMap[5124
/* INT         */
] = USetFMap[35678
/* SAMPLER_2D  */
] = USetFMap[35680
/*SAMPLER_CUBE */
] = '1i';
USetFMap[35671
/* BOOL_VEC2   */
] = USetFMap[35667
/* INT_VEC2    */
] = '2i';
USetFMap[35672
/* BOOL_VEC3   */
] = USetFMap[35668
/* INT_VEC3    */
] = '3i';
USetFMap[35673
/* BOOL_VEC4   */
] = USetFMap[35669
/* INT_VEC4    */
] = '4i';
USetFMap[35674
/* FLOAT_MAT2  */
] = 'Matrix2f';
USetFMap[35675
/* FLOAT_MAT3  */
] = 'Matrix3f';
USetFMap[35676
/* FLOAT_MAT4  */
] = 'Matrix4f';
/*
 * Uniform upload utilities
 */

function getUniformSetFunctionName(type) {
  type = String(type);
  return 'uniform' + USetFMap[type];
}
/*
 * For a given uniform's type, return the proper setter function
 */


function getUniformSetter(type, location, gl, context) {
  switch (type) {
    case gl.FLOAT_MAT2:
    case gl.FLOAT_MAT3:
    case gl.FLOAT_MAT4:
      return getMatrixSetFunction(type, location, gl, context);

    case gl.SAMPLER_2D:
    case gl.SAMPLER_CUBE:
      return getSamplerSetFunction(type, location, gl, context);

    default:
      return getUniformSetFunction(type, location, gl, context);
  }
}
/*
 * setter factory for vector uniforms
 * return a function wich take both array or arguments
 */


function getUniformSetFunction(type, location, gl, context) {
  context;
  var fname = getUniformSetFunctionName(type);
  return function () {
    if (arguments.length === 1 && arguments[0].length !== undefined) {
      gl[fname + 'v'](location, arguments[0]);
    } else if (arguments.length > 0) {
      gl[fname].apply(gl, Array.prototype.concat.apply(location, arguments));
    }

    return location;
  };
}
/*
 * setter factory for matrix uniforms
 */


function getMatrixSetFunction(type, location, gl, context) {
  context;
  var fname = getUniformSetFunctionName(type);
  return function () {
    if (arguments.length > 0 && arguments[0].length !== undefined) {
      var transpose = arguments.length > 1 ? !!arguments[1] : false;
      gl[fname + 'v'](location, transpose, arguments[0]);
    }

    return location;
  };
}
/*
 * setter factory for sampler uniforms
 */


function getSamplerSetFunction(type, location, gl, context) {
  var unit = context.texIndex++;
  return function () {
    if (arguments.length === 1) {
      if (arguments[0].bind !== undefined) {
        // is texture
        arguments[0].bind(unit);
        gl.uniform1i(location, unit);
      } else {
        gl.uniform1i(location, arguments[0]);
      }
    }

    return location;
  };
}
/*
 * getter factory for attributes
 */


function getAttribAccess(attrib) {
  return function () {
    return attrib;
  };
}

/* harmony default export */ var glProgram = (Program);
// EXTERNAL MODULE: ./node_modules/gl-matrix/src/gl-matrix.js + 7 modules
var gl_matrix = __webpack_require__(1);

// EXTERNAL MODULE: ./libs/GlTools.js
var GlTools = __webpack_require__(0);

// CONCATENATED MODULE: ./libs/Camera.js


 // cameraFront = -(cameraPos - camraTarget)

const getMouse = function (mEvent, mTarget, finger2) {
  const o = mTarget || {};

  if (mEvent.touches && !finger2) {
    o.x = mEvent.touches[0].pageX;
    o.y = mEvent.touches[0].pageY;
  } else if (!mEvent.touches) {
    o.x = mEvent.clientX;
    o.y = mEvent.clientY;
  } else if (mEvent.touches && finger2) {
    o.x = mEvent.touches[1].pageX;
    o.y = mEvent.touches[1].pageY;
  }

  return o;
};

const MIN_DIFF = 0.0001;
class Camera_Camrea {
  constructor(position = [0, 0, 0], up = [0, 1, 0]) {
    Object(defineProperty["a" /* default */])(this, "cameraPos", void 0);

    Object(defineProperty["a" /* default */])(this, "up", void 0);

    Object(defineProperty["a" /* default */])(this, "cameraFront", [0, 0, -1]);

    Object(defineProperty["a" /* default */])(this, "_mouse", {});

    Object(defineProperty["a" /* default */])(this, "_preMouse", {});

    Object(defineProperty["a" /* default */])(this, "_mousedown", false);

    Object(defineProperty["a" /* default */])(this, "_rx", 0);

    Object(defineProperty["a" /* default */])(this, "_ry", 0);

    Object(defineProperty["a" /* default */])(this, "_preRx", 0);

    Object(defineProperty["a" /* default */])(this, "_preRy", 0);

    Object(defineProperty["a" /* default */])(this, "_targetRx", 0);

    Object(defineProperty["a" /* default */])(this, "_targetRy", 0);

    Object(defineProperty["a" /* default */])(this, "_tmp", gl_matrix["a" /* mat4 */].identity(gl_matrix["a" /* mat4 */].create()));

    Object(defineProperty["a" /* default */])(this, "_width", GlTools["a" /* canvas */].width);

    Object(defineProperty["a" /* default */])(this, "_height", GlTools["a" /* canvas */].height);

    Object(defineProperty["a" /* default */])(this, "sensitivity", 1.);

    Object(defineProperty["a" /* default */])(this, "target", [0, 0, 0]);

    Object(defineProperty["a" /* default */])(this, "offset", [0, 0, 0]);

    Object(defineProperty["a" /* default */])(this, "radius", 5);

    Object(defineProperty["a" /* default */])(this, "_targetRadius", 5);

    Object(defineProperty["a" /* default */])(this, "_updateWheel", false);

    this.cameraPos = position;
    this.up = up;

    this._addEvents();
  }

  _addEvents() {
    GlTools["a" /* canvas */].addEventListener('mousedown', e => this._down(e));
    GlTools["a" /* canvas */].addEventListener('mousemove', e => this._move(e));
    document.addEventListener('mouseup', e => this._up(e));
    GlTools["a" /* canvas */].addEventListener('mousewheel', e => this._onWheel(e));
    GlTools["a" /* canvas */].addEventListener('DOMMouseScroll', e => this._onWheel(e));
  }

  _down(mEvent) {
    this._mousedown = true;
    getMouse(mEvent, this._mouse);
    getMouse(mEvent, this._preMouse); // reset 重新开始计算

    this._preRx = this._targetRx;
    this._preRy = this._targetRy;
  }

  _move(mEvent) {
    if (this._mousedown) {
      getMouse(mEvent, this._mouse);
      let diffX = (this._mouse.x - this._preMouse.x) / this._width;
      let diffY = (this._mouse.y - this._preMouse.y) / this._height;
      this._targetRx = this._preRx + diffX * Math.PI * 2 * this.sensitivity;
      this._targetRy = this._preRy + diffY * Math.PI * this.sensitivity;
    }
  }

  _up(mEvent) {
    this._mousedown = false;
  }

  updateMatrix() {
    this._rx += (this._targetRx - this._rx) * 0.1; //ease out

    if (Math.abs(this._targetRx - this._rx) < MIN_DIFF) {
      this._rx = this._targetRx;
    }

    this._ry += (this._targetRy - this._ry) * 0.1; //ease out

    if (Math.abs(this._targetRy - this._ry) < MIN_DIFF) {
      this._ry = this._targetRy;
    } // or use scheduling to add EF


    if (this._updateWheel) {
      this.radius += (this._targetRadius - this.radius) * 0.1; //ease out

      if (Math.abs(this._targetRadius - this.radius) < MIN_DIFF) {
        this.radius = this._targetRadius;
      }
    }

    this.cameraPos[1] = Math.sin(this._ry) * this.radius;
    let tr = Math.abs(Math.cos(this._ry) * this.radius); // 防止y突然从1变成-1，x，z的象限变化

    this.cameraPos[0] = Math.cos(this._rx + Math.PI * 0.5) * tr;
    this.cameraPos[2] = Math.sin(this._rx + Math.PI * 0.5) * tr; //mat4.lookAt(mat4.create(), this.cameraPos, this.cameraPos + this.cameraFront, this.up)

    this.cameraPos = [this.cameraPos[0] + this.offset[0], this.cameraPos[1] + this.offset[1], this.cameraPos[2] + this.offset[2]];
    gl_matrix["a" /* mat4 */].lookAt(this._tmp, this.cameraPos, this.target, this.up);
  }

  _onWheel(mEvent) {
    const w = mEvent.wheelDelta;
    const d = mEvent.detail;
    let value = 0;

    if (d) {
      if (w) {
        value = w / d / 40 * d > 0 ? 1 : -1; // Opera
      } else {
        value = -d / 3; // Firefox;         TODO: do not /3 for OS X
      }
    } else {
      value = w / 120;
    }

    this._targetRadius = this.radius + -value * 2;
    if (this._targetRadius <= 1) this._targetRadius = 1;
    this._updateWheel = true;
  }

  get viewMatrix() {
    return this._tmp;
  } // 设置旋转角度


  set rx(value) {
    this._targetRx = value;
  }

}
// EXTERNAL MODULE: ./node_modules/dat.gui/build/dat.gui.module.js
var dat_gui_module = __webpack_require__(36);

// CONCATENATED MODULE: ./src/js/PipeLine.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PipeLine_Pipeline; });






class PipeLine_Pipeline {
  constructor() {
    Object(defineProperty["a" /* default */])(this, "rotateQ", gl_matrix["b" /* quat */].create());

    Object(defineProperty["a" /* default */])(this, "camera", new Camera_Camrea());

    Object(defineProperty["a" /* default */])(this, "_params", {});

    Object(defineProperty["a" /* default */])(this, "gui", new dat_gui_module["a" /* GUI */]({
      width: 300
    }));

    this.init();
    this.attrib();
    this.prepare();

    this._setGUI();

    this._animate = this.animate.bind(this);
  }

  init() {}

  compile(vs, fs) {
    let prg = new glProgram(GlTools["d" /* gl */]);
    prg.compile(vs, fs);
    return prg;
  }

  attrib() {}

  uniform() {}

  prepare() {}

  animate() {
    requestAnimationFrame(this._animate);
    this.camera.updateMatrix();
    this.uniform();
    this.render();
  }

  render() {}

  play() {
    this.animate();
  }

  _setGUI() {// this.addGUIParams({
    //   lt: 0.2,
    //   gt: 0.98,
    //   clamp: false
    // })
    // let folder = gui.addFolder('grayFocus')
    // folder.add(this.params, 'lt', 0, 1).step(0.01)
    // folder.add(this.params, 'gt', 0, 1).step(0.01)
    // folder.add(this.params, 'clamp')
    // folder.open()
  }

  addGUIParams(o) {
    return Object.assign(this._params, o);
  }

  get params() {
    return this._params;
  }

  set params(param) {
    throw Error("Params has no setter,please use addGUIParams");
  }

}__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread.js
var objectSpread = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(2);

// EXTERNAL MODULE: ./src/js/PipeLine.js + 2 modules
var PipeLine = __webpack_require__(5);

// EXTERNAL MODULE: ./libs/GlTools.js
var GlTools = __webpack_require__(0);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/pbr_ibl.vert
var pbr_ibl = __webpack_require__(81);
var pbr_ibl_default = /*#__PURE__*/__webpack_require__.n(pbr_ibl);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/pbr_ibl.frag
var ibl_diffuse_pbr_ibl = __webpack_require__(82);
var ibl_diffuse_pbr_ibl_default = /*#__PURE__*/__webpack_require__.n(ibl_diffuse_pbr_ibl);

// EXTERNAL MODULE: ./src/shaders/pbr/pbr_map.vert
var pbr_map = __webpack_require__(26);
var pbr_map_default = /*#__PURE__*/__webpack_require__.n(pbr_map);

// EXTERNAL MODULE: ./src/shaders/pbr/pbr_map.frag
var pbr_pbr_map = __webpack_require__(27);
var pbr_pbr_map_default = /*#__PURE__*/__webpack_require__.n(pbr_pbr_map);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/cubemap.vert
var cubemap = __webpack_require__(35);
var cubemap_default = /*#__PURE__*/__webpack_require__.n(cubemap);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/equirectangular_to_cubemap.frag
var equirectangular_to_cubemap = __webpack_require__(83);
var equirectangular_to_cubemap_default = /*#__PURE__*/__webpack_require__.n(equirectangular_to_cubemap);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/skybox.vert
var skybox = __webpack_require__(84);
var skybox_default = /*#__PURE__*/__webpack_require__.n(skybox);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/skybox.frag
var ibl_diffuse_skybox = __webpack_require__(85);
var ibl_diffuse_skybox_default = /*#__PURE__*/__webpack_require__.n(ibl_diffuse_skybox);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/irradiance_convolution.frag
var irradiance_convolution = __webpack_require__(86);
var irradiance_convolution_default = /*#__PURE__*/__webpack_require__.n(irradiance_convolution);

// EXTERNAL MODULE: ./libs/glBuffer.js
var glBuffer = __webpack_require__(7);

// EXTERNAL MODULE: ./libs/vao.js
var vao = __webpack_require__(12);
var vao_default = /*#__PURE__*/__webpack_require__.n(vao);

// EXTERNAL MODULE: ./src/js/Torus.js
var Torus = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/gl-matrix/src/gl-matrix.js + 7 modules
var gl_matrix = __webpack_require__(1);

// EXTERNAL MODULE: ./libs/Mesh.js
var Mesh = __webpack_require__(4);

// EXTERNAL MODULE: ./libs/glTexture.js
var glTexture = __webpack_require__(3);
var glTexture_default = /*#__PURE__*/__webpack_require__.n(glTexture);

// EXTERNAL MODULE: ./utils/HDRParser.js
var HDRParser = __webpack_require__(10);

// EXTERNAL MODULE: ./libs/GLCubeTexture.js
var GLCubeTexture = __webpack_require__(13);

// CONCATENATED MODULE: ./libs/CubeFrameBuffer.js
// CubeFrameBuffer.js





class CubeFrameBuffer_CubeFrameBuffer {
  constructor(size, mParameters = {}) {
    this._size = size;
    this.magFilter = mParameters.magFilter || GlTools["d" /* gl */].LINEAR;
    this.minFilter = mParameters.minFilter || GlTools["d" /* gl */].LINEAR;
    this.wrapS = mParameters.wrapS || GlTools["d" /* gl */].CLAMP_TO_EDGE;
    this.wrapT = mParameters.wrapT || GlTools["d" /* gl */].CLAMP_TO_EDGE;

    this._init();
  }

  _init() {
    this.texture = GlTools["d" /* gl */].createTexture();
    this.glTexture = new GLCubeTexture["a" /* default */](this.texture, {}, true);
    GlTools["d" /* gl */].bindTexture(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, this.texture);
    GlTools["d" /* gl */].texParameteri(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, GlTools["d" /* gl */].TEXTURE_MAG_FILTER, this.magFilter);
    GlTools["d" /* gl */].texParameteri(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, GlTools["d" /* gl */].TEXTURE_MIN_FILTER, this.minFilter);
    GlTools["d" /* gl */].texParameteri(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, GlTools["d" /* gl */].TEXTURE_WRAP_S, this.wrapS);
    GlTools["d" /* gl */].texParameteri(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, GlTools["d" /* gl */].TEXTURE_WRAP_T, this.wrapT);
    const targets = [GlTools["d" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_X, GlTools["d" /* gl */].TEXTURE_CUBE_MAP_NEGATIVE_X, GlTools["d" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_Y, GlTools["d" /* gl */].TEXTURE_CUBE_MAP_NEGATIVE_Y, GlTools["d" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_Z, GlTools["d" /* gl */].TEXTURE_CUBE_MAP_NEGATIVE_Z];

    for (let i = 0; i < targets.length; i++) {
      GlTools["d" /* gl */].pixelStorei(GlTools["d" /* gl */].UNPACK_FLIP_Y_WEBGL, false);
      GlTools["d" /* gl */].texImage2D(targets[i], 0, GlTools["d" /* gl */].RGBA, this.width, this.height, 0, GlTools["d" /* gl */].RGBA, GlTools["d" /* gl */].FLOAT, null);
    }

    this._frameBuffers = [];

    for (let i = 0; i < targets.length; i++) {
      const frameBuffer = GlTools["d" /* gl */].createFramebuffer();
      GlTools["d" /* gl */].bindFramebuffer(GlTools["d" /* gl */].FRAMEBUFFER, frameBuffer);
      GlTools["d" /* gl */].framebufferTexture2D(GlTools["d" /* gl */].FRAMEBUFFER, GlTools["d" /* gl */].COLOR_ATTACHMENT0, targets[i], this.texture, 0);
      const status = GlTools["d" /* gl */].checkFramebufferStatus(GlTools["d" /* gl */].FRAMEBUFFER);

      if (status !== GlTools["d" /* gl */].FRAMEBUFFER_COMPLETE) {
        console.log(`'gl.checkFramebufferStatus() returned '${status}`);
      }

      this._frameBuffers.push(frameBuffer);
    } // gl.generateMipmap(gl.TEXTURE_CUBE_MAP);


    GlTools["d" /* gl */].bindFramebuffer(GlTools["d" /* gl */].FRAMEBUFFER, null);
    GlTools["d" /* gl */].bindRenderbuffer(GlTools["d" /* gl */].RENDERBUFFER, null);
    GlTools["d" /* gl */].bindTexture(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, null);
  }

  bind(mTargetIndex) {
    // if(Math.random() > .99) console.log('bind :', mTargetIndex, this._frameBuffers[mTargetIndex]);
    GlTools["d" /* gl */].viewport(0, 0, this.width, this.height);
    GlTools["d" /* gl */].bindFramebuffer(GlTools["d" /* gl */].FRAMEBUFFER, this._frameBuffers[mTargetIndex]);
  }

  unbind() {
    GlTools["d" /* gl */].bindFramebuffer(GlTools["d" /* gl */].FRAMEBUFFER, null);
    GlTools["d" /* gl */].viewport(0, 0, GlTools["a" /* canvas */].width, GlTools["a" /* canvas */].height);
  } //	TEXTURES


  getTexture() {
    return this.glTexture;
  } //	GETTERS AND SETTERS


  get width() {
    return this._size;
  }

  get height() {
    return this._size;
  }

}

/* harmony default export */ var libs_CubeFrameBuffer = (CubeFrameBuffer_CubeFrameBuffer);
// CONCATENATED MODULE: ./src/js/Pbr/IblDiffuse.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IblDiffuse_IblDiffuse; });




















 //ibl diffuse即irradiance，为normal正交的平面上半球内所有方向的平均颜色微分

class IblDiffuse_IblDiffuse extends PipeLine["default"] {
  constructor() {
    super();

    Object(defineProperty["a" /* default */])(this, "count", 0);
  }

  init() {
    GlTools["d" /* gl */].getExtension('OES_standard_derivatives');
    GlTools["d" /* gl */].getExtension('OES_texture_float');
    GlTools["d" /* gl */].getExtension('OES_texture_float_linear'); // gl.getExtension('OES_texture_half_float')
    // gl.getExtension('OES_texture_half_float_linear')

    this.prg = this.compile(pbr_ibl_default.a, ibl_diffuse_pbr_ibl_default.a);
    this.mapPrg = this.compile(pbr_map_default.a, pbr_pbr_map_default.a);
    this.cubePrg = this.compile(cubemap_default.a, equirectangular_to_cubemap_default.a);
    this.skyboxPrg = this.compile(skybox_default.a, ibl_diffuse_skybox_default.a);
    this.irradiancePrg = this.compile(cubemap_default.a, irradiance_convolution_default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      uv
    } = Object(Torus["Sphere"])(256, 256, .15);
    let sphere = new Mesh["a" /* default */]();
    sphere.bufferVertex(pos);
    sphere.bufferIndices(index);
    sphere.bufferNormal(normal);
    sphere.bufferTexCoord(uv);
    this.sphere = sphere;
    let cube = new Mesh["a" /* default */]();
    cube.bufferData(Torus["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.cube = cube;
    let planeVertices = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, 3.0, 0.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, -3.0, 1.0, 1.0];
    this.planeBuffer = new glBuffer["a" /* ArrayBuffer */](GlTools["d" /* gl */], new Float32Array(planeVertices));
    this.planeBuffer.attrib('position', 3, GlTools["d" /* gl */].FLOAT);
    this.planeBuffer.attrib('texCoord', 2, GlTools["d" /* gl */].FLOAT);
    this.planeVao = new vao_default.a(GlTools["d" /* gl */]);
    this.planeVao.setup(this.cubePrg, [this.planeBuffer]);
  }

  prepare() {
    GlTools["d" /* gl */].enable(GlTools["d" /* gl */].DEPTH_TEST);
    GlTools["d" /* gl */].depthFunc(GlTools["d" /* gl */].LEQUAL);
    GlTools["d" /* gl */].pixelStorei(GlTools["d" /* gl */].UNPACK_FLIP_Y_WEBGL, true);
    let hdrInfo = Object(HDRParser["a" /* default */])(getAssets.equirectangular);
    console.log('hdrInfo', hdrInfo);
    this.hdrTexture = new glTexture_default.a(GlTools["d" /* gl */], GlTools["d" /* gl */].RGBA).fromData(hdrInfo.shape[0], hdrInfo.shape[1], hdrInfo.data, GlTools["d" /* gl */].FLOAT);
    this.hdrTexture.clamp();
    let cubemapTexture = GlTools["d" /* gl */].createTexture();
    GlTools["d" /* gl */].bindTexture(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, cubemapTexture);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      GlTools["d" /* gl */].texImage2D(GlTools["d" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GlTools["d" /* gl */].RGBA, 512, 512, 0, GlTools["d" /* gl */].RGBA, GlTools["d" /* gl */].FLOAT, null);
    }

    GlTools["d" /* gl */].texParameteri(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, GlTools["d" /* gl */].TEXTURE_WRAP_S, GlTools["d" /* gl */].CLAMP_TO_EDGE);
    GlTools["d" /* gl */].texParameteri(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, GlTools["d" /* gl */].TEXTURE_WRAP_T, GlTools["d" /* gl */].CLAMP_TO_EDGE);
    GlTools["d" /* gl */].texParameteri(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, GlTools["d" /* gl */].TEXTURE_MAG_FILTER, GlTools["d" /* gl */].LINEAR);
    GlTools["d" /* gl */].texParameteri(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, GlTools["d" /* gl */].TEXTURE_MIN_FILTER, GlTools["d" /* gl */].LINEAR);
    this.cubemapTexture = cubemapTexture; // render 6 faces to framebuffer

    this.cubePrg.use();
    this.hdrTexture.bind(0);
    let pMatrix = gl_matrix["a" /* mat4 */].identity(gl_matrix["a" /* mat4 */].create());
    let mMatrix = gl_matrix["a" /* mat4 */].identity(gl_matrix["a" /* mat4 */].create());
    let vMatrix = gl_matrix["a" /* mat4 */].identity(gl_matrix["a" /* mat4 */].create());
    let vpMatrix = gl_matrix["a" /* mat4 */].identity(gl_matrix["a" /* mat4 */].create());
    gl_matrix["a" /* mat4 */].perspective(pMatrix, Object(GlTools["e" /* toRadian */])(90), 1., .1, 100);
    const CAMERA_SETTINGS = [[gl_matrix["d" /* vec3 */].fromValues(0, 0, 0), gl_matrix["d" /* vec3 */].fromValues(1, 0, 0), gl_matrix["d" /* vec3 */].fromValues(0, -1, 0)], [gl_matrix["d" /* vec3 */].fromValues(0, 0, 0), gl_matrix["d" /* vec3 */].fromValues(-1, 0, 0), gl_matrix["d" /* vec3 */].fromValues(0, -1, 0)], [gl_matrix["d" /* vec3 */].fromValues(0, 0, 0), gl_matrix["d" /* vec3 */].fromValues(0, 1, 0), gl_matrix["d" /* vec3 */].fromValues(0, 0, 1)], [gl_matrix["d" /* vec3 */].fromValues(0, 0, 0), gl_matrix["d" /* vec3 */].fromValues(0, -1, 0), gl_matrix["d" /* vec3 */].fromValues(0, 0, -1)], [gl_matrix["d" /* vec3 */].fromValues(0, 0, 0), gl_matrix["d" /* vec3 */].fromValues(0, 0, 1), gl_matrix["d" /* vec3 */].fromValues(0, -1, 0)], [gl_matrix["d" /* vec3 */].fromValues(0, 0, 0), gl_matrix["d" /* vec3 */].fromValues(0, 0, -1), gl_matrix["d" /* vec3 */].fromValues(0, -1, 0)]];
    GlTools["d" /* gl */].viewport(0, 0, 512, 512);
    let captureFrameBuffer = GlTools["d" /* gl */].createFramebuffer();
    GlTools["d" /* gl */].bindFramebuffer(GlTools["d" /* gl */].FRAMEBUFFER, captureFrameBuffer);

    for (let i = 0; i < 6; i++) {
      gl_matrix["a" /* mat4 */].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix["a" /* mat4 */].multiply(vpMatrix, pMatrix, vMatrix);
      this.cubePrg.style({
        equirectangularMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      GlTools["d" /* gl */].framebufferTexture2D(GlTools["d" /* gl */].FRAMEBUFFER, GlTools["d" /* gl */].COLOR_ATTACHMENT0, GlTools["d" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.cubemapTexture, 0);
      GlTools["d" /* gl */].clear(GlTools["d" /* gl */].COLOR_BUFFER_BIT | GlTools["d" /* gl */].DEPTH_BUFFER_BIT);
      this.cube.bind(this.cubePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    GlTools["d" /* gl */].bindFramebuffer(GlTools["d" /* gl */].FRAMEBUFFER, null);
    this.irradiancePrg.use();
    let irradianceFbo = new libs_CubeFrameBuffer(32);
    GlTools["d" /* gl */].activeTexture(GlTools["d" /* gl */].TEXTURE0);
    GlTools["d" /* gl */].bindTexture(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, this.cubemapTexture); // 放在这，防止new cubeframebuffer时绑定了tetxure0到null

    for (let i = 0; i < 6; i++) {
      gl_matrix["a" /* mat4 */].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix["a" /* mat4 */].multiply(vpMatrix, pMatrix, vMatrix);
      this.irradiancePrg.style({
        environmentMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      irradianceFbo.bind(i);
      GlTools["d" /* gl */].clear(GlTools["d" /* gl */].COLOR_BUFFER_BIT | GlTools["d" /* gl */].DEPTH_BUFFER_BIT);
      this.cube.bind(this.irradiancePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    irradianceFbo.unbind();
    this.irradianceFbo = irradianceFbo;
  }

  uniform() {
    let vMatrix = gl_matrix["a" /* mat4 */].identity(gl_matrix["a" /* mat4 */].create());
    let pMatrix = gl_matrix["a" /* mat4 */].identity(gl_matrix["a" /* mat4 */].create());
    this.tmpMatrix = gl_matrix["a" /* mat4 */].identity(gl_matrix["a" /* mat4 */].create());
    let eyeDirection = [];
    let camUpDirection = [];
    gl_matrix["d" /* vec3 */].transformQuat(eyeDirection, [0.0, 0.0, 1.0], this.rotateQ);
    gl_matrix["d" /* vec3 */].transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix["a" /* mat4 */].lookAt(vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix["a" /* mat4 */].perspective(pMatrix, Object(GlTools["e" /* toRadian */])(60), GlTools["a" /* canvas */].clientWidth / GlTools["a" /* canvas */].clientHeight, .1, 100);
    gl_matrix["a" /* mat4 */].multiply(this.tmpMatrix, pMatrix, vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      roughness: 0.2,
      metallic: 6 / 7,
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder = this.gui.addFolder('material param');
    folder.add(this.params, 'roughness', 0.05, 1).step(0.01);
    folder.add(this.params, 'metallic', 0, 6 / 7).step(0.01);
    folder.open();
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new glTexture_default.a(GlTools["d" /* gl */], GlTools["d" /* gl */].RGBA).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new glTexture_default.a(GlTools["d" /* gl */], GlTools["d" /* gl */].RGBA).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new glTexture_default.a(GlTools["d" /* gl */], GlTools["d" /* gl */].RGBA).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new glTexture_default.a(GlTools["d" /* gl */], GlTools["d" /* gl */].RGBA).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new glTexture_default.a(GlTools["d" /* gl */], GlTools["d" /* gl */].RGBA).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    GlTools["d" /* gl */].viewport(0, 0, GlTools["a" /* canvas */].width, GlTools["a" /* canvas */].height);
    GlTools["d" /* gl */].clearColor(0.3, 0.3, 0.3, 1.);
    GlTools["d" /* gl */].clearDepth(1.0);
    GlTools["d" /* gl */].clear(GlTools["d" /* gl */].COLOR_BUFFER_BIT | GlTools["d" /* gl */].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix["a" /* mat4 */].identity(gl_matrix["a" /* mat4 */].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.eyeDirection,
      lambertDiffuse: this.params.lambertDiffuse,
      irradianceMap: 0
    };

    if (this.params.map === 'none') {
      this.prg.use();
      this.irradianceFbo.getTexture().bind(0);
      this.prg.style(Object(objectSpread["a" /* default */])({}, baseUniforms, {
        albedo: [.5, .0, .0],
        roughness: this.params.roughness,
        metallic: this.params.metallic,
        ao: 1.
      }));
      this.sphere.bind(this.prg, ['position', 'normal']);
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      this.mapPrg.style(Object(objectSpread["a" /* default */])({}, baseUniforms, {
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4
      }));
      this.sphere.bind(this.mapPrg);
    }

    this.sphere.draw(); // this.cubePrg.use()
    // this.hdrTexture.bind(0)
    // this.cubePrg.style({
    //   equirectangularMap: 0,
    //   vpMatrix: this.tmpMatrix,
    //   mMatrix: mMatrix
    // })
    // this.cube.bind(this.cubePrg, ['position', 'texCoord'])
    // this.cube.draw()
    // this.planeVao.bind()
    // this.planeBuffer.drawTriangles()
    // this.planeVao.unbind()

    this.skyboxPrg.use();
    GlTools["d" /* gl */].activeTexture(GlTools["d" /* gl */].TEXTURE0);
    GlTools["d" /* gl */].bindTexture(GlTools["d" /* gl */].TEXTURE_CUBE_MAP, this.cubemapTexture); // this.irradianceFbo.getTexture().bind(0)

    this.skyboxPrg.style({
      environmentMap: 0,
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix
    });
    this.cube.bind(this.skyboxPrg, ['position']);
    this.cube.draw();
  }

}