__webpack_require__.r(__webpack_exports__);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _MouseMove__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);


const importLists = {
  reflection: 'Light/Reflection',
  mask: 'OpenGL/Mask',
  shadow: 'AdvancedLight/Shadow',
  deferredshading: 'AdvancedLight/DeferredShading',
  mrt: 'OpenGL/Mrt',
  mirror: 'OpenGL/Mirror',
  pbr: 'Pbr/Pbr',
  ibldiffuse: 'Pbr/IblDiffuse',
  iblfinal: 'Pbr/iblFinal',
  ssao: 'AdvancedLight/SSAO',
  normalmap: 'AdvancedLight/NormalMap',
  pbrflow: 'Pbr/PbrFlow',
  lightcaster: 'Light/LightCaster',
  color: 'Light/Color',
  material: 'Light/Material',
  pbrmodel: 'Pbr/PbrModel',
  envMap: 'AdvancedLight/EnvironmentMap',
  gltf: 'Pbr/gltf',
  bloom: 'AdvancedLight/Bloom'
};

function addList() {
  let list = document.querySelector('.list');

  for (let key in importLists) {
    let link = document.createElement('a');
    link.innerHTML = key;
    link.setAttribute('href', '?' + key);
    list.appendChild(link);
    let br = document.createElement('br');
    list.appendChild(br);
  }
}

let obj;

const dynamicImport = name => {
  __webpack_require__(145)(`./${importLists[name]}`).then(foo => {
    obj = new foo.default();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* canvas */ "b"].addEventListener('mousemove', e => {
      let t = Object(_MouseMove__WEBPACK_IMPORTED_MODULE_1__["default"])(e, libs_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* canvas */ "b"]);
      obj.rotateQ = t.q;
      obj.mousePos = t.mousePos;
    });
    obj.play();
  });
};

let name = location.search.replace('?', '');
if (name) dynamicImport(name);else addList();__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MouseMove; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);


const getMouse = function (mEvent, mTarget) {
  const o = mTarget || {};

  if (mEvent.touches) {
    o.x = mEvent.touches[0].pageX;
    o.y = mEvent.touches[0].pageY;
  } else {
    o.x = mEvent.clientX;
    o.y = mEvent.clientY;
  }

  return o;
};

let mousePos = {};
function MouseMove(e, canvas) {
  let cw = canvas.clientWidth;
  let ch = canvas.clientHeight;
  var wh = 1 / Math.sqrt(cw * cw + ch * ch);
  getMouse(e, mousePos);
  let x = mousePos.x - canvas.offsetLeft - cw * 0.5;
  let y = mousePos.y - canvas.offsetTop - ch * 0.5;
  let q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__[/* quat */ "c"].create();
  var sq = Math.sqrt(x * x + y * y);
  var r = sq * 2.0 * Math.PI * wh; // 距离来表示旋转弧度

  if (sq !== 1) {
    sq = 1 / sq;
    x *= sq;
    y *= sq;
  }

  gl_matrix__WEBPACK_IMPORTED_MODULE_0__[/* quat */ "c"].setAxisAngle(q, [y, x, 0], r); // 旋转轴向量与(x,y,0)垂直

  return {
    q,
    mousePos
  };
}var map = {
	"./AdvancedLight/Bloom": [
		65,
		9,
		0,
		2,
		20
	],
	"./AdvancedLight/Bloom.js": [
		65,
		9,
		0,
		2,
		20
	],
	"./AdvancedLight/DeferredShading": [
		44,
		9,
		0,
		3,
		16
	],
	"./AdvancedLight/DeferredShading.js": [
		44,
		9,
		0,
		3,
		16
	],
	"./AdvancedLight/EnvironmentMap": [
		45,
		9,
		0,
		2,
		19
	],
	"./AdvancedLight/EnvironmentMap.js": [
		45,
		9,
		0,
		2,
		19
	],
	"./AdvancedLight/HeightMap": [
		46,
		7,
		23
	],
	"./AdvancedLight/HeightMap.js": [
		46,
		7,
		23
	],
	"./AdvancedLight/NormalMap": [
		47,
		9,
		0,
		17
	],
	"./AdvancedLight/NormalMap.js": [
		47,
		9,
		0,
		17
	],
	"./AdvancedLight/SSAO": [
		48,
		9,
		0,
		3,
		15
	],
	"./AdvancedLight/SSAO.js": [
		48,
		9,
		0,
		3,
		15
	],
	"./AdvancedLight/Shadow": [
		49,
		9,
		0,
		7
	],
	"./AdvancedLight/Shadow.js": [
		49,
		9,
		0,
		7
	],
	"./Assets": [
		27,
		9
	],
	"./Assets.js": [
		27,
		9
	],
	"./AssetsInit": [
		34,
		9
	],
	"./AssetsInit.js": [
		34,
		9
	],
	"./Light/Color": [
		50,
		9,
		0,
		14
	],
	"./Light/Color.js": [
		50,
		9,
		0,
		14
	],
	"./Light/LightCaster": [
		51,
		9,
		0,
		6
	],
	"./Light/LightCaster.js": [
		51,
		9,
		0,
		6
	],
	"./Light/Material": [
		52,
		9,
		0,
		12
	],
	"./Light/Material.js": [
		52,
		9,
		0,
		12
	],
	"./Light/Reflection": [
		53,
		9,
		0,
		18
	],
	"./Light/Reflection.js": [
		53,
		9,
		0,
		18
	],
	"./MouseMove": [
		29,
		9
	],
	"./MouseMove.js": [
		29,
		9
	],
	"./OpenGL/Gpgpu": [
		54,
		7,
		24
	],
	"./OpenGL/Gpgpu.js": [
		54,
		7,
		24
	],
	"./OpenGL/Mask": [
		64,
		9,
		0,
		13
	],
	"./OpenGL/Mask.js": [
		64,
		9,
		0,
		13
	],
	"./OpenGL/Mirror": [
		55,
		9,
		0,
		8
	],
	"./OpenGL/Mirror.js": [
		55,
		9,
		0,
		8
	],
	"./OpenGL/Mrt": [
		56,
		9,
		0,
		1,
		21
	],
	"./OpenGL/Mrt.js": [
		56,
		9,
		0,
		1,
		21
	],
	"./OpenGL/Text": [
		57,
		7,
		25
	],
	"./OpenGL/Text.js": [
		57,
		7,
		25
	],
	"./Pbr/IblDiffuse": [
		66,
		9,
		0,
		1,
		11
	],
	"./Pbr/IblDiffuse.js": [
		66,
		9,
		0,
		1,
		11
	],
	"./Pbr/Pbr": [
		58,
		9,
		0,
		10
	],
	"./Pbr/Pbr.js": [
		58,
		9,
		0,
		10
	],
	"./Pbr/PbrFlow": [
		59,
		9,
		0,
		1,
		9
	],
	"./Pbr/PbrFlow.js": [
		59,
		9,
		0,
		1,
		9
	],
	"./Pbr/PbrModel": [
		60,
		9,
		0,
		4
	],
	"./Pbr/PbrModel.js": [
		60,
		9,
		0,
		4
	],
	"./Pbr/gltf": [
		63,
		9,
		0,
		2,
		26
	],
	"./Pbr/gltf.js": [
		63,
		9,
		0,
		2,
		26
	],
	"./Pbr/iblFinal": [
		61,
		9,
		0,
		1,
		5
	],
	"./Pbr/iblFinal.js": [
		61,
		9,
		0,
		1,
		5
	],
	"./PipeLine": [
		5,
		9,
		0,
		22
	],
	"./PipeLine.js": [
		5,
		9,
		0,
		22
	],
	"./Scene": [
		38,
		9
	],
	"./Scene.js": [
		38,
		9
	],
	"./Settings": [
		62,
		9,
		27
	],
	"./Settings.js": [
		62,
		9,
		27
	],
	"./Torus": [
		6,
		9,
		28
	],
	"./Torus.js": [
		6,
		9,
		28
	],
	"./app": [
		39,
		9
	],
	"./app.js": [
		39,
		9
	]
};
function webpackAsyncContext(req) {
	var ids = map[req];
	if(!ids) {
		return Promise.resolve().then(function() {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}
	return Promise.all(ids.slice(2).map(__webpack_require__.e)).then(function() {
		var id = ids[0];
		return __webpack_require__.t(id, ids[1])
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.id = 145;
module.exports = webpackAsyncContext;module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}
/* unused harmony export color */
/* unused harmony export controllers */
/* unused harmony export dom */
/* unused harmony export gui */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GUI$1; });
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (!this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function ()        {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function ()        {
      dom.addClass(this, 'drag').bind(window, 'touchend', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRowName) {
          titleRowName.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    params.closed = false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var _titleRowName = document.createTextNode(params.name);
    dom.addClass(_titleRowName, 'controller-name');
    var titleRow = addRow(_this, _titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller,                                   {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};


/* unused harmony default export */ var _unused_webpack_default_export = (index);
//# sourceMappingURL=dat.gui.module.js.map
/* harmony import */ var _GlTools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _GLTexture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _GLCubeTexture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
// GLShader.js






const glslify = __webpack_require__(144);

const isSame = (array1, array2) => {
  if (array1.length !== array2.length) {
    return false;
  }

  for (let i = 0; i < array1.length; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
};

const addLineNumbers = string => {
  const lines = string.split('\n');

  for (let i = 0; i < lines.length; i++) {
    lines[i] = `${i + 1}: ${lines[i]}`;
  }

  return lines.join('\n');
};

const cloneArray = mArray => {
  if (mArray.slice) {
    return mArray.slice(0);
  } else {
    return new Float32Array(mArray);
  }
};

const defaultVertexShader = __webpack_require__(142);

const defaultFragmentShader = __webpack_require__(143);

const uniformMapping = {
  float: 'uniform1f',
  vec2: 'uniform2fv',
  vec3: 'uniform3fv',
  vec4: 'uniform4fv',
  int: 'uniform1i',
  mat3: 'uniformMatrix3fv',
  mat4: 'uniformMatrix4fv'
};

class GLShader {
  constructor(strVertexShader = defaultVertexShader, strFragmentShader = defaultFragmentShader, mVaryings) {
    this.parameters = [];
    this._uniformTextures = [];
    this._varyings = mVaryings;

    if (!strVertexShader) {
      strVertexShader = defaultVertexShader;
    }

    if (!strFragmentShader) {
      strFragmentShader = defaultVertexShader;
    }

    const vsShader = this._createShaderProgram(strVertexShader, true);

    const fsShader = this._createShaderProgram(strFragmentShader, false);

    this._attachShaderProgram(vsShader, fsShader);
  }

  use() {
    this.bind();
  }

  bind() {
    // if(GL.shader === this) {
    // 	return;
    // }
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].useProgram(this.shaderProgram);
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* GlTools */ "a"].useShader(this); // this.uniformTextures = [];
  }

  uniform(mName, mType, mValue) {
    if (typeof mName === 'object') {
      this.uniformObject(mName);
      return;
    }
    /*
    if(!!mValue === undefined || mValue === null) {
    	console.warn('mValue Error:', mName);
    	return;
    }
    */


    const uniformType = uniformMapping[mType] || mType;
    let hasUniform = false;
    let oUniform;
    let parameterIndex = -1;

    for (let i = 0; i < this.parameters.length; i++) {
      oUniform = this.parameters[i];

      if (oUniform.name === mName) {
        hasUniform = true;
        parameterIndex = i;
        break;
      }
    }

    let isNumber = false;

    if (!hasUniform) {
      isNumber = uniformType === 'uniform1i' || uniformType === 'uniform1f';
      this.shaderProgram[mName] = _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].getUniformLocation(this.shaderProgram, mName); //console.log(this.shaderProgram[mName], mName)

      if (isNumber) {
        this.parameters.push({
          name: mName,
          type: uniformType,
          value: mValue,
          uniformLoc: this.shaderProgram[mName],
          isNumber
        });
      } else {
        this.parameters.push({
          name: mName,
          type: uniformType,
          value: cloneArray(mValue),
          uniformLoc: this.shaderProgram[mName],
          isNumber
        });
      }

      parameterIndex = this.parameters.length - 1;
    } else {
      this.shaderProgram[mName] = oUniform.uniformLoc;
      isNumber = oUniform.isNumber;
    }

    if (!this.parameters[parameterIndex].uniformLoc) {
      return;
    }

    if (uniformType.indexOf('Matrix') === -1) {
      if (!isNumber) {
        if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
          _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"][uniformType](this.shaderProgram[mName], mValue);
          this.parameters[parameterIndex].value = cloneArray(mValue);
        }
      } else {
        const needUpdate = this.parameters[parameterIndex].value !== mValue || !hasUniform;

        if (needUpdate) {
          _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"][uniformType](this.shaderProgram[mName], mValue);
          this.parameters[parameterIndex].value = mValue;
        }
      }
    } else {
      if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
        _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"][uniformType](this.shaderProgram[mName], false, mValue);
        this.parameters[parameterIndex].value = cloneArray(mValue);
      }
    }
  }

  style(mUniformObj) {
    this.uniformObject(mUniformObj);
  }

  uniformObject(mUniformObj) {
    for (const uniformName in mUniformObj) {
      if (mUniformObj[uniformName] instanceof _GLTexture__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"] || mUniformObj[uniformName] instanceof _GLCubeTexture__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]) {
        const texture = mUniformObj[uniformName];
        let textureIndex = -1;
        ;

        this._uniformTextures.forEach((ut, i) => {
          if (ut.name === uniformName) {
            textureIndex = i;
            ut.texture = texture;
          }
        });

        if (textureIndex === -1) {
          textureIndex = this._uniformTextures.length;

          this._uniformTextures.push({
            name: uniformName,
            texture
          });
        }

        this.uniform(uniformName, 'uniform1i', textureIndex);
        texture.bind(textureIndex);
      } else {
        let uniformValue = mUniformObj[uniformName];
        const uniformType = GLShader.getUniformType(uniformValue); //console.log(uniformType, uniformName, uniformValue)

        if (uniformValue.concat && uniformValue[0].concat) {
          let tmp = [];

          for (let i = 0; i < uniformValue.length; i++) {
            tmp = tmp.concat(uniformValue[i]);
          }

          uniformValue = tmp;
        }

        this.uniform(uniformName, uniformType, uniformValue);
      }
    }
  }

  _createShaderProgram(mShaderStr, isVertexShader) {
    const shaderType = isVertexShader ? _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].VERTEX_SHADER : _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].FRAGMENT_SHADER;
    const shader = _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].createShader(shaderType);
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].shaderSource(shader, mShaderStr);
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].compileShader(shader);

    if (!_GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].getShaderParameter(shader, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].COMPILE_STATUS)) {
      console.warn('Error in Shader : ', _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].getShaderInfoLog(shader));
      console.log(addLineNumbers(mShaderStr));
      return null;
    }

    return shader;
  }

  _attachShaderProgram(mVertexShader, mFragmentShader) {
    this.shaderProgram = _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].createProgram();
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].attachShader(this.shaderProgram, mVertexShader);
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].attachShader(this.shaderProgram, mFragmentShader);
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].deleteShader(mVertexShader);
    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].deleteShader(mFragmentShader);

    if (this._varyings) {
      console.log('Transform feedback setup : ', this._varyings);
      _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].transformFeedbackVaryings(this.shaderProgram, this._varyings, _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].SEPARATE_ATTRIBS);
    }

    _GlTools__WEBPACK_IMPORTED_MODULE_0__[/* gl */ "c"].linkProgram(this.shaderProgram);
  }

}

GLShader.getUniformType = function (mValue) {
  const isArray = !!mValue.length;

  const getArrayUniformType = function (mValue) {
    if (mValue.length === 9) {
      return 'uniformMatrix3fv';
    } else if (mValue.length === 16) {
      return 'uniformMatrix4fv';
    } else {
      return `vec${mValue.length}`;
    }
  };

  if (!isArray) {
    return 'float';
  } else {
    if (!mValue[0].concat) {
      return getArrayUniformType(mValue);
    } else {
      return getArrayUniformType(mValue[0]);
    }
  }
};

/* harmony default export */ __webpack_exports__["a"] = (GLShader);module.exports = "// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nattribute vec3 normal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n    vTextureCoord = texCoord;\n    vNormal = normal;\n}"module.exports = "// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
// Geom.js



const Geom = {};
let meshTri;

Geom.plane = function plane(width, height, numSegments, axis = 'xy', drawType = 4) {
  const positions = [];
  const coords = [];
  const indices = [];
  const normals = [];
  const gapX = width / numSegments;
  const gapY = height / numSegments;
  const gapUV = 1 / numSegments;
  const sx = -width * 0.5;
  const sy = -height * 0.5;
  let index = 0;

  for (let i = 0; i < numSegments; i++) {
    for (let j = 0; j < numSegments; j++) {
      const tx = gapX * i + sx;
      const ty = gapY * j + sy;
      const u = i / numSegments;
      const v = j / numSegments;

      if (axis === 'xz') {
        positions.push([tx, 0, ty + gapY]);
        positions.push([tx + gapX, 0, ty + gapY]);
        positions.push([tx + gapX, 0, ty]);
        positions.push([tx, 0, ty]);
        coords.push([u, 1.0 - (v + gapUV)]);
        coords.push([u + gapUV, 1.0 - (v + gapUV)]);
        coords.push([u + gapUV, 1.0 - v]);
        coords.push([u, 1.0 - v]);
        normals.push([0, 1, 0]);
        normals.push([0, 1, 0]);
        normals.push([0, 1, 0]);
        normals.push([0, 1, 0]);
      } else if (axis === 'yz') {
        positions.push([0, ty, tx]);
        positions.push([0, ty, tx + gapX]);
        positions.push([0, ty + gapY, tx + gapX]);
        positions.push([0, ty + gapY, tx]);
        coords.push([u, v]);
        coords.push([u + gapUV, v]);
        coords.push([u + gapUV, v + gapUV]);
        coords.push([u, v + gapUV]);
        normals.push([1, 0, 0]);
        normals.push([1, 0, 0]);
        normals.push([1, 0, 0]);
        normals.push([1, 0, 0]);
      } else {
        positions.push([tx, ty, 0]);
        positions.push([tx + gapX, ty, 0]);
        positions.push([tx + gapX, ty + gapY, 0]);
        positions.push([tx, ty + gapY, 0]);
        coords.push([u, v]);
        coords.push([u + gapUV, v]);
        coords.push([u + gapUV, v + gapUV]);
        coords.push([u, v + gapUV]);
        normals.push([0, 0, 1]);
        normals.push([0, 0, 1]);
        normals.push([0, 0, 1]);
        normals.push([0, 0, 1]);
      }

      indices.push(index * 4 + 0);
      indices.push(index * 4 + 1);
      indices.push(index * 4 + 2);
      indices.push(index * 4 + 0);
      indices.push(index * 4 + 2);
      indices.push(index * 4 + 3);
      index++;
    }
  }

  const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](drawType);
  mesh.bufferVertex(positions);
  mesh.bufferTexCoord(coords);
  mesh.bufferIndex(indices);
  mesh.bufferNormal(normals);
  return mesh;
};

Geom.sphere = function sphere(size, numSegments, isInvert = false, drawType = 4) {
  const positions = [];
  const coords = [];
  const indices = [];
  const normals = [];
  const gapUV = 1 / numSegments;
  let index = 0;

  function getPosition(i, j, isNormal = false) {
    //	rx : -90 ~ 90 , ry : 0 ~ 360
    const rx = i / numSegments * Math.PI - Math.PI * 0.5;
    const ry = j / numSegments * Math.PI * 2;
    const r = isNormal ? 1 : size;
    const pos = [];
    pos[1] = Math.sin(rx) * r;
    const t = Math.cos(rx) * r;
    pos[0] = Math.cos(ry) * t;
    pos[2] = Math.sin(ry) * t;
    const precision = 10000;
    pos[0] = Math.floor(pos[0] * precision) / precision;
    pos[1] = Math.floor(pos[1] * precision) / precision;
    pos[2] = Math.floor(pos[2] * precision) / precision;
    return pos;
  }

  ;

  for (let i = 0; i < numSegments; i++) {
    for (let j = 0; j < numSegments; j++) {
      positions.push(getPosition(i, j));
      positions.push(getPosition(i + 1, j));
      positions.push(getPosition(i + 1, j + 1));
      positions.push(getPosition(i, j + 1));
      normals.push(getPosition(i, j, true));
      normals.push(getPosition(i + 1, j, true));
      normals.push(getPosition(i + 1, j + 1, true));
      normals.push(getPosition(i, j + 1, true));
      const u = j / numSegments;
      const v = i / numSegments;
      coords.push([1.0 - u, v]);
      coords.push([1.0 - u, v + gapUV]);
      coords.push([1.0 - u - gapUV, v + gapUV]);
      coords.push([1.0 - u - gapUV, v]);
      indices.push(index * 4 + 0);
      indices.push(index * 4 + 1);
      indices.push(index * 4 + 2);
      indices.push(index * 4 + 0);
      indices.push(index * 4 + 2);
      indices.push(index * 4 + 3);
      index++;
    }
  }

  if (isInvert) {
    indices.reverse();
  }

  const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](drawType);
  mesh.bufferVertex(positions);
  mesh.bufferTexCoord(coords);
  mesh.bufferIndex(indices);
  mesh.bufferNormal(normals);
  return mesh;
};

Geom.cube = function cube(w, h, d, drawType = 4) {
  h = h || w;
  d = d || w;
  const x = w / 2;
  const y = h / 2;
  const z = d / 2;
  const positions = [];
  const coords = [];
  const indices = [];
  const normals = [];
  let count = 0; // BACK

  positions.push([-x, y, -z]);
  positions.push([x, y, -z]);
  positions.push([x, -y, -z]);
  positions.push([-x, -y, -z]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // RIGHT

  positions.push([x, y, -z]);
  positions.push([x, y, z]);
  positions.push([x, -y, z]);
  positions.push([x, -y, -z]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // FRONT

  positions.push([x, y, z]);
  positions.push([-x, y, z]);
  positions.push([-x, -y, z]);
  positions.push([x, -y, z]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // LEFT

  positions.push([-x, y, z]);
  positions.push([-x, y, -z]);
  positions.push([-x, -y, -z]);
  positions.push([-x, -y, z]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // TOP

  positions.push([x, y, -z]);
  positions.push([-x, y, -z]);
  positions.push([-x, y, z]);
  positions.push([x, y, z]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // BOTTOM

  positions.push([x, -y, z]);
  positions.push([-x, -y, z]);
  positions.push([-x, -y, -z]);
  positions.push([x, -y, -z]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++;
  const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](drawType);
  mesh.bufferVertex(positions);
  mesh.bufferTexCoord(coords);
  mesh.bufferIndex(indices); //mesh.bufferNormal(normals);

  mesh.computeNormals(normals);
  return mesh;
};

Geom.skybox = function skybox(size, drawType = 4) {
  const positions = [];
  const coords = [];
  const indices = [];
  const normals = [];
  let count = 0; // BACK

  positions.push([size, size, -size]);
  positions.push([-size, size, -size]);
  positions.push([-size, -size, -size]);
  positions.push([size, -size, -size]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  normals.push([0, 0, -1]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // RIGHT

  positions.push([size, -size, -size]);
  positions.push([size, -size, size]);
  positions.push([size, size, size]);
  positions.push([size, size, -size]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  normals.push([1, 0, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // FRONT

  positions.push([-size, size, size]);
  positions.push([size, size, size]);
  positions.push([size, -size, size]);
  positions.push([-size, -size, size]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  normals.push([0, 0, 1]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // LEFT

  positions.push([-size, -size, size]);
  positions.push([-size, -size, -size]);
  positions.push([-size, size, -size]);
  positions.push([-size, size, size]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  normals.push([-1, 0, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // TOP

  positions.push([size, size, size]);
  positions.push([-size, size, size]);
  positions.push([-size, size, -size]);
  positions.push([size, size, -size]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  normals.push([0, 1, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  count++; // BOTTOM

  positions.push([size, -size, -size]);
  positions.push([-size, -size, -size]);
  positions.push([-size, -size, size]);
  positions.push([size, -size, size]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  normals.push([0, -1, 0]);
  coords.push([0, 0]);
  coords.push([1, 0]);
  coords.push([1, 1]);
  coords.push([0, 1]);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 1);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 0);
  indices.push(count * 4 + 2);
  indices.push(count * 4 + 3);
  const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](drawType);
  mesh.bufferVertex(positions);
  mesh.bufferTexCoord(coords);
  mesh.bufferIndex(indices);
  mesh.bufferNormal(normals);
  return mesh;
};

Geom.bigTriangle = function bigTriangle() {
  if (!meshTri) {
    const indices = [2, 1, 0];
    const positions = [[-1, -1], [-1, 4], [4, -1]];
    meshTri = new _Mesh__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]();
    meshTri.bufferData(positions, 'position', 2);
    meshTri.bufferIndex(indices);
  }

  return meshTri;
};

/* harmony default export */ __webpack_exports__["a"] = (Geom);/* harmony import */ var _glsl_skybox_skybox_frag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);
/* harmony import */ var _glsl_skybox_skybox_frag__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_glsl_skybox_skybox_frag__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glsl_skybox_skybox_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72);
/* harmony import */ var _glsl_skybox_skybox_vert__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_glsl_skybox_skybox_vert__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _glsl_gltf_gltf_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73);
/* harmony import */ var _glsl_gltf_gltf_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_glsl_gltf_gltf_frag__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _glsl_gltf_gltf_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74);
/* harmony import */ var _glsl_gltf_gltf_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_glsl_gltf_gltf_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _glsl_bigTriangle_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);
/* harmony import */ var _glsl_bigTriangle_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_glsl_bigTriangle_vert__WEBPACK_IMPORTED_MODULE_4__);





const CustomShaders = {
  skyboxVert: (_glsl_skybox_skybox_vert__WEBPACK_IMPORTED_MODULE_1___default()),
  skyboxFrag: (_glsl_skybox_skybox_frag__WEBPACK_IMPORTED_MODULE_0___default()),
  gltfVert: (_glsl_gltf_gltf_vert__WEBPACK_IMPORTED_MODULE_3___default()),
  gltfFrag: (_glsl_gltf_gltf_frag__WEBPACK_IMPORTED_MODULE_2___default()),
  bigTriangleVert: (_glsl_bigTriangle_vert__WEBPACK_IMPORTED_MODULE_4___default())
};
/* harmony default export */ __webpack_exports__["a"] = (CustomShaders);module.exports = "#version 300 es\n#define SHADER_NAME SKYBOX_FRAGMENT\n\nprecision highp float;\n#define GLSLIFY 1\nin   vec2 TexCoords;\nin vec3 vertex;\nuniform samplerCube tex;\nuniform float uGamma;\nuniform float uExposure;\nout vec4 outColor;\n\n// Filmic tonemapping from\n// http://filmicgames.com/archives/75\n\nconst float A = 0.15;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\n\nvec3 Uncharted2Tonemap( vec3 x )\n{\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvoid main(void){\n    vec3 color = texture(tex, vertex).rgb;\n    color\t\t\t\t= Uncharted2Tonemap( color * uExposure );\n\t// white balance\n\tcolor\t\t\t\t= color * ( 1.0 / Uncharted2Tonemap( vec3( 20.0 ) ) );\n\t\n\t// gamma correction\n\tcolor\t\t\t\t= pow( color, vec3( 1.0 / uGamma ) );\n\n    outColor = vec4(color, 1.);\n}\n"module.exports = "#version 300 es\n#define SHADER_NAME SKYBOX_VERTEX\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nuniform   mat4 mvpMatrix;\nout   vec2 TexCoords;\nout vec3 vertex;\n\n\nvoid main(void){\n    TexCoords = texCoord;\n    vertex = position;\n    vec4 pos = mvpMatrix * vec4(position, 1.0);\n    gl_Position = pos.xyww;\n}\n"module.exports = "#version 300 es\n#define SHADER_NAME gltf_frag\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D \tuBRDFMap;\nuniform samplerCube uRadianceMap;\nuniform samplerCube uIrradianceMap;\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D uColorMap;\n#endif\n\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D uMetallicRoughnessMap;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D uAoMap;\nuniform float uOcclusionStrength;\n#endif\n\n#ifdef HAS_NORMALMAP\nuniform sampler2D uNormalMap;\nuniform float uNormalScale;\n#endif\n\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D uEmissiveMap;\nuniform vec3 uEmissiveFactor;\n#endif\n\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\nuniform vec3 uCameraPos;\n\nuniform vec4 uScaleDiffBaseMR;\nuniform vec4 uScaleFGDSpec;\nuniform vec4 uScaleIBLAmbient;\n\nuniform vec3 uBaseColor;\nuniform float uRoughness;\nuniform float uMetallic;\nuniform float uGamma;\n\nin vec2 vTextureCoord;\nin vec3 vPosition;\n\n#ifdef HAS_NORMALS\nin vec3 vNormal;\n#endif\nout vec4 FragColor;\n\n//\tFrom GLTF WebGL PBR :\n//\thttps://github.com/KhronosGroup/glTF-WebGL-PBR\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n\tfloat NdotL;                  // cos angle between normal and light direction\n\tfloat NdotV;                  // cos angle between normal and view direction\n\tfloat NdotH;                  // cos angle between normal and half vector\n\tfloat LdotH;                  // cos angle between light direction and half vector\n\tfloat VdotH;                  // cos angle between view direction and half vector\n\tfloat perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n\tfloat metalness;              // metallic value at the surface\n\tvec3 reflectance0;            // full reflectance color (normal incidence angle)\n\tvec3 reflectance90;           // reflectance color at grazing angle\n\tfloat alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n\tvec3 diffuseColor;            // color contribution from diffuse lighting\n\tvec3 specularColor;           // color contribution from specular lighting\n};\n\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n\t#ifdef MANUAL_SRGB\n\t#ifdef SRGB_FAST_APPROXIMATION\n\tvec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n\t#else //SRGB_FAST_APPROXIMATION\n\tvec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n\tvec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n\t#endif //SRGB_FAST_APPROXIMATION\n\treturn vec4(linOut,srgbIn.w);;\n\t#else //MANUAL_SRGB\n\treturn srgbIn;\n\t#endif //MANUAL_SRGB\n}\n\n\nvec3 getNormal() {\n\tvec3 pos_dx = dFdx(vPosition);\n\tvec3 pos_dy = dFdy(vPosition);\n\tvec3 tex_dx = dFdx(vec3(vTextureCoord, 0.0));\n\tvec3 tex_dy = dFdy(vec3(vTextureCoord, 0.0));\n\tvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n\t\n#ifdef HAS_NORMALS\n\tvec3 ng = normalize(vNormal);\n#else\n\tvec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n\tt = normalize(t - ng * dot(ng, t));\n\tvec3 b = normalize(cross(ng, t));\n\tmat3 tbn = mat3(t, b, ng);\n\n#ifdef HAS_NORMALMAP\n\tvec3 n = texture(uNormalMap, vTextureCoord).rgb;\n\tn = normalize(tbn * ((2.0 * n - 1.0) * vec3(uNormalScale, uNormalScale, 1.0)));\n#else\n\t// The tbn matrix is linearly interpolated, so we need to re-normalize\n\tvec3 n = normalize(tbn[2].xyz);\n#endif\n\n\treturn n;\n}\n\n\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n\tfloat mipCount = 7.0; // resolution of 512x512\n\tfloat lod = (pbrInputs.perceptualRoughness * mipCount);\n\t// retrieve a scale and bias to F0. See [1], Figure 3\n\tvec2 brdf = SRGBtoLINEAR(texture(uBRDFMap, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rg;\n\tvec3 diffuseLight = SRGBtoLINEAR(texture(uIrradianceMap, n)).rgb;\n\n\tvec3 specularLight = SRGBtoLINEAR(texture(uRadianceMap, reflection, lod)).rgb;\n\n\tvec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n\tvec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n\n\t// For presentation, this allows us to disable IBL terms\n\tdiffuse *= uScaleIBLAmbient.x;\n\tspecular *= uScaleIBLAmbient.y;\n\n\treturn diffuse + specular;\n}\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.diffuseColor / M_PI;\n}\n\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n\tfloat NdotL = pbrInputs.NdotL;\n\tfloat NdotV = pbrInputs.NdotV;\n\tfloat r = pbrInputs.alphaRoughness;\n\n\tfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n\tfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n\treturn attenuationL * attenuationV;\n}\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n\tfloat roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n\tfloat f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n\treturn roughnessSq / (M_PI * f * f);\n}\n\nvoid main() {\n\n\tfloat perceptualRoughness   = uRoughness;\n\tfloat metallic              = uMetallic;\n#ifdef HAS_METALROUGHNESSMAP\n\t// Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n\t// This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n\tvec4 mrSample = texture(uMetallicRoughnessMap, vTextureCoord);\n\tperceptualRoughness = mrSample.g * perceptualRoughness;\n\tmetallic = mrSample.b * metallic;\n#endif\t\n\tperceptualRoughness         = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n\tmetallic                    = clamp(metallic, 0.0, 1.0);\n\tfloat alphaRoughness        = perceptualRoughness * perceptualRoughness;\n\n#ifdef HAS_BASECOLORMAP\t\n\tvec4 baseColor = SRGBtoLINEAR(texture(uColorMap, vTextureCoord));\n#else\n\tvec4 baseColor              = vec4(uBaseColor, 1.0);\n#endif\t\n\t\n\tvec3 f0                     = vec3(0.04);\n\tvec3 diffuseColor           = baseColor.rgb * (vec3(1.0) - f0);\n\tdiffuseColor                *= 1.0 - metallic;\n\tvec3 specularColor          = mix(f0, baseColor.rgb, metallic);\n\t\n\t// Compute reflectance.\n\tfloat reflectance           = max(max(specularColor.r, specularColor.g), specularColor.b);\n\t\n\t// For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n\t// For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n\tfloat reflectance90         = clamp(reflectance * 50.0, 0.0, 1.0);\n\tvec3 specularEnvironmentR0  = specularColor.rgb;\n\tvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\t\n\tvec3 n                      = getNormal();                             // normal at surface point\n\tvec3 v                      = normalize(uCameraPos - vPosition);        // Vector from surface point to camera\n\tvec3 l                      = normalize(uLightDirection);             // Vector from surface point to light\n\tvec3 h                      = normalize(l+v);                          // Half vector between both l and v\n\tvec3 reflection             = -normalize(reflect(v, n));\n\t\n\tfloat NdotL                 = clamp(dot(n, l), 0.001, 1.0);\n\tfloat NdotV                 = abs(dot(n, v)) + 0.001;\n\tfloat NdotH                 = clamp(dot(n, h), 0.0, 1.0);\n\tfloat LdotH                 = clamp(dot(l, h), 0.0, 1.0);\n\tfloat VdotH                 = clamp(dot(v, h), 0.0, 1.0);\n\n\tPBRInfo pbrInputs = PBRInfo(\n\t\tNdotL,\n\t\tNdotV,\n\t\tNdotH,\n\t\tLdotH,\n\t\tVdotH,\n\t\tperceptualRoughness,\n\t\tmetallic,\n\t\tspecularEnvironmentR0,\n\t\tspecularEnvironmentR90,\n\t\talphaRoughness,\n\t\tdiffuseColor,\n\t\tspecularColor\n\t);\n\n\t// Calculate the shading terms for the microfacet specular shading model\n\tvec3 F              = specularReflection(pbrInputs);\n\tfloat G             = geometricOcclusion(pbrInputs);\n\tfloat D             = microfacetDistribution(pbrInputs);\n\t\n\t// Calculation of analytical lighting contribution\n\tvec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n\tvec3 specContrib    = F * G * D / (4.0 * NdotL * NdotV);\n\t// Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n\tvec3 color          = NdotL * uLightColor * (diffuseContrib + specContrib);\n\t\n#ifdef USE_IBL\n\tcolor += getIBLContribution(pbrInputs, n, reflection);\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\t\n\tfloat ao            = texture(uAoMap, vTextureCoord).r;\n\tcolor               = mix(color, color * ao, uOcclusionStrength);\n#endif\t\n\n#ifdef HAS_EMISSIVEMAP\n\tvec3 emissive = SRGBtoLINEAR(texture(uEmissiveMap, vTextureCoord)).rgb * uEmissiveFactor;\n\tcolor += emissive;\n#endif\n\t\n\t// This section uses mix to override final color for reference app visualization\n\t// of various parameters in the lighting equation.\n\tcolor               = mix(color, F, uScaleFGDSpec.x);\n\tcolor               = mix(color, vec3(G), uScaleFGDSpec.y);\n\tcolor               = mix(color, vec3(D), uScaleFGDSpec.z);\n\tcolor               = mix(color, specContrib, uScaleFGDSpec.w);\n\t\n\tcolor               = mix(color, diffuseContrib, uScaleDiffBaseMR.x);\n\tcolor               = mix(color, baseColor.rgb, uScaleDiffBaseMR.y);\n\tcolor               = mix(color, vec3(metallic), uScaleDiffBaseMR.z);\n\tcolor               = mix(color, vec3(perceptualRoughness), uScaleDiffBaseMR.w);\n\t\n\t// output the fragment color\n\tFragColor        = vec4(pow(color,vec3(1.0/uGamma)), baseColor.a);\n\t//FragColor        = vec4(vec3(baseColor), 1.0);\n\n}"module.exports = "#version 300 es\n#define SHADER_NAME gltf_vert\n\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\n\n#ifdef HAS_UV\nin vec2 texCoord;\n#endif\n\n#ifdef HAS_NORMALS\nin vec3 normal;\n#endif\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform mat3 uModelViewMatrixInverse;\n\n\nout vec3 vPosition;\nout vec2 vTextureCoord;\n\n#ifdef HAS_NORMALS\nout vec3 vNormal;\n#endif\n\n\nvoid main(void) {\n\tvec4 tPosition = uModelMatrix * vec4(position, 1.0);\n\tvPosition     = tPosition.xyz / tPosition.w;\n\t\n\t#ifdef HAS_UV\n\tvTextureCoord = vec2(texCoord.x, texCoord.y);\n\t#else\n\tvTextureCoord = vec2(0.,0.);\n\t#endif\n\n\t#ifdef HAS_NORMALS\n\tvNormal       = normalize(vec3(uModelMatrix * vec4(normal, 0.0)));\n\t#endif\n\t\n\tgl_Position   = uProjectionMatrix * uViewMatrix * tPosition;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec2 position;\nout vec2 TexCoords;\n\n\n\nvoid main(void){\n\n\n\tgl_Position    = vec4(position, 0., 1.);\n\tTexCoords = position * .5 + .5;\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\n\nout vec3 FragPos;\nout vec3 Normal;\nout vec2 TexCoords;\n\n\nuniform mat4 uProjectionMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uModelMatrix;\n\nvoid main()\n{\n    FragPos = vec3(uModelMatrix * vec4(position, 1.0));   \n    TexCoords = texCoord;\n        \n    mat3 normalMatrix = transpose(inverse(mat3(uModelMatrix)));\n    Normal = normalize(normalMatrix * normal);\n    \n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n}"module.exports = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nlayout (location = 0) out vec4 FragColor;\nlayout (location = 1) out vec4 BrightColor;\n\n\nin  vec3 FragPos;\nin  vec3 Normal;\nin  vec2 TexCoords;\n\n\nstruct Light {\n    vec3 Position;\n    vec3 Color;\n};\n\nuniform Light lights[5];\nuniform vec3 baseColor;\nuniform vec3 uCameraPos;\nuniform float uAlpha;\n\nvoid main()\n{           \n    vec3 normal = normalize(Normal);\n    // ambient\n    vec3 ambient = 0.0 * baseColor;\n    // lighting\n    vec3 lighting = vec3(0.0);\n    vec3 viewDir = normalize(uCameraPos - FragPos);\n    for(int i = 0; i < 5; i++)\n    {\n        // diffuse\n        vec3 lightDir = normalize(lights[i].Position - FragPos);\n        float diff = max(dot(lightDir, normal), 0.0);\n        vec3 result = lights[i].Color * diff * baseColor;      \n        // attenuation (use quadratic as we have gamma correction)\n        float distance = length(FragPos - lights[i].Position);\n        result *= 1.0 / (distance * distance);\n        lighting += result;\n                \n    }\n    vec3 result = ambient + lighting;\n    // check whether result is higher than some threshold, if so, output as bloom threshold color\n    // tranform to grayscale\n    float brightness = dot(result, vec3(0.2126, 0.7152, 0.0722));\n    if(brightness > 1.0)\n        BrightColor = vec4(result, uAlpha);\n    else\n        BrightColor = vec4(0.0, 0.0, 0.0, 1.0);\n    FragColor = vec4(result, uAlpha);\n}\n"module.exports = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec2 TexCoords;\n\nuniform sampler2D image;\n\nuniform bool horizontal;\nuniform float texOffsetScale;\nfloat weight[5] = float[] (0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162);\nout vec4 FragColor;\nfloat lod =3.;\n\nvoid main()\n{             \n    vec2 tex_offset = texOffsetScale * vec2(1.0/ float(textureSize(image, 0).x), 1.0/ float(textureSize(image, 0).y)); // gets size of single texel\n    vec3 result = textureLod(image, TexCoords, lod).rgb * weight[0];\n    if(horizontal)\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n        result += textureLod(image, TexCoords + vec2(tex_offset.x * float(i), 0.0), lod).rgb * weight[i];\n        result += textureLod(image, TexCoords - vec2(tex_offset.x * float(i), 0.0), lod).rgb * weight[i];\n        }\n    }\n    else\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n            result += textureLod(image, TexCoords + vec2(0.0, tex_offset.y * float(i)), lod).rgb * weight[i];\n            result += textureLod(image, TexCoords - vec2(0.0, tex_offset.y * float(i)), lod).rgb * weight[i];\n        }\n    }\n    FragColor = vec4(result, 1.0);\n}"module.exports = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D scene;\nuniform sampler2D bloomBlur;\nuniform bool bloom;\nuniform float exposure;\n\nvoid main()\n{             \n    const float gamma = 2.2;\n    vec3 hdrColor = texture(scene, TexCoords).rgb;      \n    vec3 bloomColor = texture(bloomBlur, TexCoords).rgb;\n    if(bloom)\n        hdrColor += bloomColor; // additive blending\n    // tone mapping\n    vec3 result = vec3(1.0) - exp(-hdrColor * exposure);\n    // also gamma correct while we're at it       \n    result = pow(result, vec3(1.0 / gamma));\n    FragColor = vec4(result, 1.0);\n}"module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\n\nout vec2 TexCoords;\nvoid main(){\n  TexCoords = texCoord;\n  gl_Position = vec4(position, 1.);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Torus", function() { return Torus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsva", function() { return hsva; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plane", function() { return plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadData", function() { return QuadData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnot", function() { return TorusKnot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "regularPolyhedron", function() { return regularPolyhedron; });
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);

function Torus(circlePoints, circleNum, rdius, Origin2CicleCenter, colors) {
  let pos = [];
  let index = [];
  let normal = [];
  let color = [];
  let texCoord = [];
  let tc;

  for (let i = 0; i <= circlePoints; i++) {
    let theta = Math.PI * 2 / circlePoints * i; // 圆平面弧度计算 x,y平面，得到y

    let rr = Math.cos(theta);
    let ry = Math.sin(theta); // Origin2Cicle平面计算 x,z 平面

    for (let j = 0; j <= circleNum; j++) {
      texCoord.push(j / circleNum, i / circlePoints);
      let alpha = Math.PI * 2 / circleNum * j;
      let px = (rr * rdius + Origin2CicleCenter) * Math.cos(alpha);
      let py = ry * rdius;
      let pz = (rr * rdius + Origin2CicleCenter) * Math.sin(alpha);
      pos.push(px, py, pz);
      if (colors) tc = colors;else tc = hsva(360 / circleNum * j, 1, 1, 1); // hue色调，360度，红色为0°，绿色为120°,蓝色为240°

      color.push(tc[0], tc[1], tc[2], tc[3]);
      let rx = rr * Math.cos(alpha);
      let rz = rr * Math.sin(alpha);
      normal.push(rx, ry, rz);
    }
  } // 每4个顶点，6个index，2个三角形


  for (let i = 0; i < circlePoints; i++) {
    for (let j = 0; j < circleNum; j++) {
      let r = (circleNum + 1) * i + j;
      index.push(r, r + circleNum + 1, r + 1);
      index.push(r + circleNum + 1, r + circleNum + 2, r + 1);
    }
  }

  let t = {
    pos,
    texCoord,
    index,
    normal,
    color
  };
  let torus = new libs_Mesh__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]();
  torus.bufferFlattenData(pos, 'position', 3);
  torus.bufferFlattenData(texCoord, 'texCoord', 2);
  torus.bufferFlattenData(color, 'color', 4);
  torus.bufferIndex(index);
  torus.bufferFlattenData(normal, 'normal', 3);
  return torus;
}
function hsva(h, s, v, a) {
  if (s > 1 || v > 1 || a > 1) {
    return;
  }

  let th = h % 360;
  let i = Math.floor(th / 60);
  let f = th / 60 - i;
  let m = v * (1 - s);
  let n = v * (1 - s * f);
  let k = v * (1 - s * (1 - f));
  let color = [];

  if (!s > 0 && !s < 0) {
    color.push(v, v, v, a);
  } else {
    let r = [v, n, m, m, k, v];
    let g = [k, v, v, n, m, m];
    let b = [m, m, k, v, v, n];
    color.push(r[i], g[i], b[i], a);
  }

  return color;
} // 从平面到球，也是采用经纬度的方式

function Sphere(row, column, rad, color) {
  var pos = [],
      nor = [],
      col = [],
      st = [],
      idx = [];

  for (var i = 0; i <= row; i++) {
    var r = Math.PI / row * i;
    var ry = Math.cos(r);
    var rr = Math.sin(r);

    for (var ii = 0; ii <= column; ii++) {
      var tr = Math.PI * 2 / column * ii;
      var tx = rr * rad * Math.cos(tr);
      var ty = ry * rad;
      var tz = rr * rad * Math.sin(tr);
      var rx = rr * Math.cos(tr);
      var rz = rr * Math.sin(tr);

      if (color) {
        var tc = color;
      } else {
        tc = hsva(360 / row * i, 1, 1, 1);
      }

      pos.push(tx, ty, tz);
      nor.push(rx, ry, rz);
      col.push(tc[0], tc[1], tc[2], tc[3]);
      st.push(1 - 1 / column * ii, 1 / row * i);
    }
  }

  r = 0;

  for (i = 0; i < row; i++) {
    for (ii = 0; ii < column; ii++) {
      r = (column + 1) * i + ii;
      idx.push(r, r + 1, r + column + 2);
      idx.push(r, r + column + 2, r + column + 1);
    }
  }

  return {
    pos,
    normal: nor,
    color: col,
    uv: st,
    index: idx
  };
} // simply xz空间平面，normal y+

function plane(xSize, yPos, zSize) {
  const xPos = xSize / 2;
  const zPos = zSize / 2;
  return [// Positions          // Normals         // Texture Coords
  xPos, yPos, zPos, 0.0, 1.0, 0.0, 1.0, 0.0, -xPos, yPos, -zPos, 0.0, 1.0, 0.0, 0.0, 1.0, -xPos, yPos, zPos, 0.0, 1.0, 0.0, 0.0, 0.0, xPos, yPos, zPos, 0.0, 1.0, 0.0, 1.0, 0.0, xPos, yPos, -zPos, 0.0, 1.0, 0.0, 1.0, 1.0, -xPos, yPos, -zPos, 0.0, 1.0, 0.0, 0.0, 1.0];
}
const QuadData = [// position texCoord
-1.0, 1.0, 0.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 0.0, 1.0, 0.0];

function f() {}

function g() {}

function h() {}

function TorusKnot() {}
function regularPolyhedron() {}/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MTLLoader; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var load_asset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);
/* harmony import */ var load_asset__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(load_asset__WEBPACK_IMPORTED_MODULE_2__);


 // code from https://github.com/mrdoob/three.js

class MTLLoader {
  constructor(name, path) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "_materials", {});

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "materialsInfo", {});

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "name", '');

    this.name = name;
    this.path = path;
  }

  parse(text) {
    var lines, info, delimiterPattern, i, line, pos, key, value, ss;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          lines = text.split('\n');
          info = {};
          delimiterPattern = /\s+/;
          i = 0;

        case 4:
          if (!(i < lines.length)) {
            _context.next = 18;
            break;
          }

          line = lines[i];
          line = line.trim();

          if (!(line.length === 0 || line.charAt(0) === '#')) {
            _context.next = 9;
            break;
          }

          return _context.abrupt("continue", 15);

        case 9:
          pos = line.indexOf(' ');
          key = pos >= 0 ? line.substring(0, pos) : line;
          key = key.toLowerCase();
          value = pos >= 0 ? line.substring(pos + 1) : '';
          value = value.trim();

          if (key === 'newmtl') {
            // New material
            info = {
              name: value
            };
            this.materialsInfo[value] = info;
          } else {
            if (key === 'ka' || key === 'kd' || key === 'ks') {
              ss = value.split(delimiterPattern, 3);
              info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
            } else {
              info[key] = value;
            }
          }

        case 15:
          i++;
          _context.next = 4;
          break;

        case 18:
          _context.next = 20;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMaterials());

        case 20:
          return _context.abrupt("return", this.materials);

        case 21:
        case "end":
          return _context.stop();
      }
    }, null, this);
  } //


  setMaterials() {
    var n, key, prop, value;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.t0 = _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.materialsInfo);

        case 1:
          if ((_context2.t1 = _context2.t0()).done) {
            _context2.next = 50;
            break;
          }

          key = _context2.t1.value;
          this._materials[key] = {};
          _context2.t2 = _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.materialsInfo[key]);

        case 5:
          if ((_context2.t3 = _context2.t2()).done) {
            _context2.next = 48;
            break;
          }

          prop = _context2.t3.value;
          value = this.materialsInfo[key][prop];
          _context2.t4 = prop.toLowerCase();
          _context2.next = _context2.t4 === 'kd' ? 11 : _context2.t4 === 'ks' ? 13 : _context2.t4 === 'map_kd' ? 15 : _context2.t4 === 'map_ks' ? 19 : _context2.t4 === 'norm' ? 23 : _context2.t4 === 'map_bump' ? 27 : _context2.t4 === 'bump' ? 27 : _context2.t4 === 'map_d' ? 31 : _context2.t4 === 'ns' ? 36 : _context2.t4 === 'd' ? 38 : _context2.t4 === 'tr' ? 41 : 45;
          break;

        case 11:
          this._materials[key].kd = value;
          return _context2.abrupt("break", 46);

        case 13:
          this._materials[key].ks = value;
          return _context2.abrupt("break", 46);

        case 15:
          _context2.next = 17;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("diffuseMap", value));

        case 17:
          this._materials[key].diffuseMap = _context2.sent;
          return _context2.abrupt("break", 46);

        case 19:
          _context2.next = 21;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("specularMap", value));

        case 21:
          this._materials[key].specularMap = _context2.sent;
          return _context2.abrupt("break", 46);

        case 23:
          _context2.next = 25;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("normalMap", value));

        case 25:
          this._materials[key].normalMap = _context2.sent;
          return _context2.abrupt("break", 46);

        case 27:
          _context2.next = 29;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("bumpMap", value));

        case 29:
          this._materials[key].bumpMap = _context2.sent;
          return _context2.abrupt("break", 46);

        case 31:
          _context2.next = 33;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(this.setMapType("alphaMap", value));

        case 33:
          this._materials[key].alphaMap = _context2.sent;
          params.transparent = true;
          return _context2.abrupt("break", 46);

        case 36:
          // The specular exponent (defines the focus of the specular highlight)
          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.
          this._materials[key].shininess = parseFloat(value);
          return _context2.abrupt("break", 46);

        case 38:
          n = parseFloat(value);

          if (n < 1) {
            this._materials[key].opacity = n;
          }

          return _context2.abrupt("break", 46);

        case 41:
          n = parseFloat(value);
          n = 1 - n;

          if (n > 0) {
            this._materials[key].opacity = 1 - n;
          }

          return _context2.abrupt("break", 46);

        case 45:
          return _context2.abrupt("break", 46);

        case 46:
          _context2.next = 5;
          break;

        case 48:
          _context2.next = 1;
          break;

        case 50:
        case "end":
          return _context2.stop();
      }
    }, null, this);
  }

  setMapType(name, text) {
    var url, asset;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          //simply skip texture params
          url = text.split(/\s+/).pop();
          _context3.next = 3;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(load_asset__WEBPACK_IMPORTED_MODULE_2___default()(this.path + '/' + url));

        case 3:
          asset = _context3.sent;
          return _context3.abrupt("return", asset);

        case 5:
        case "end":
          return _context3.stop();
      }
    }, null, this);
  } // material: { materialName: { ...params, aoMap: ..., diffuseMap: ..., ....}


  get materials() {
    return this._materials;
  }

  set materials(value) {
    this._materials = value;
  }

}__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DeferredShading; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_deferred_shading_finalQuad_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(76);
/* harmony import */ var shaders_deferred_shading_finalQuad_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_finalQuad_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_deferred_shading_gBuffer_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(77);
/* harmony import */ var shaders_deferred_shading_gBuffer_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_gBuffer_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_deferred_shading_gBuffer_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(78);
/* harmony import */ var shaders_deferred_shading_gBuffer_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_gBuffer_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_deferred_shading_fbo_debug_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(79);
/* harmony import */ var shaders_deferred_shading_fbo_debug_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_fbo_debug_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_deferred_shading_fbo_debug_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(80);
/* harmony import */ var shaders_deferred_shading_fbo_debug_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_fbo_debug_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(30);
/* harmony import */ var shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(31);
/* harmony import */ var shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var libs_Geom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(8);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(3);
/* harmony import */ var libs_loaders_ObjLoader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(18);
/* harmony import */ var libs_loaders_MTLLoader__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(35);


















const offset = 10.;
const objectPositions = [[-offset, -offset, -offset], [0.0, -offset, -offset], [offset, -offset, -offset], [-offset, -offset, 0.0], [0.0, -offset, 0.0], [offset, -offset, 0.0], [-offset, -offset, offset], [0.0, -offset, offset], [offset, -offset, offset]];
const NR_LIGHTS = 32;
const lightPositions = [];
const lightColors = [];

for (let i = 0; i < NR_LIGHTS; i++) {
  // calculate slightly random offsets
  let xPos = Math.random() * 33 - 16.0;
  let yPos = Math.random() * 10 - 2.0;
  let zPos = Math.random() * 20 - 4.0;
  lightPositions.push([xPos, yPos, zPos]); // lightPositions.push()
  // also calculate random color

  let rColor = Math.random() / 2.0 + 0.5; // between 0.5 and 1.0

  let gColor = Math.random() / 2.0 + 0.5; // between 0.5 and 1.0

  let bColor = Math.random() / 2.0 + 0.5; // between 0.5 and 1.0

  lightColors.push([rColor, gColor, bColor]);
}

class DeferredShading extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    // gl.getExtension('OES_texture_float_linear') // Even WebGL2 requires OES_texture_float_linear
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension("EXT_color_buffer_float"); // gl.getExtension('OES_texture_half_float')

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension('OES_texture_half_float_linear'); // gl.getExtension('EXT_shader_texture_lod')

    this.prg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_deferred_shading_finalQuad_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.gBufferPrg = this.compile(shaders_deferred_shading_gBuffer_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_deferred_shading_gBuffer_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.fboPrg = this.compile(shaders_deferred_shading_fbo_debug_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_deferred_shading_fbo_debug_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
    this.lampPrg = this.compile(shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_10___default.a, shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_11___default.a);
  }

  attrib() {
    var quad, materials;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          this.cube = libs_Geom__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"].cube(1);
          quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"]();
          quad.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_13__["QuadData"], ['position', 'texCoord'], [3, 2]);
          this.quad = quad;
          _context.next = 6;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(new libs_loaders_MTLLoader__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"]('nanosuit.mtl', './assets/models/nanosuit').parse(getAssets.nanosuitMTL));

        case 6:
          materials = _context.sent;
          this.nanosuit = new libs_loaders_ObjLoader__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]().parseObj(getAssets.nanosuit, materials);

        case 8:
        case "end":
          return _context.stop();
      }
    }, null, this);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearColor(0., 0., 0., 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LEQUAL); //position, normal, AlbedoSpec(diffuse, specular indensity)

    this.mrt = framebufferMRT(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height, ['16f', '16f', 'rgba']); // execute once

    this.camera.target = [0, -1., 0];
    this.camera.offset = [1, 3., 0];
    this.camera.radius = 18;
  }

  uniform() {
    this.vMatrix = this.camera.viewMatrix;
    this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].perspective(this.pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientHeight, .1, 100);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, this.mrt.frameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.gBufferPrg.use();

    if (this.nanosuit) {
      // loaded
      this.gBufferPrg.style({
        vMatrix: this.vMatrix,
        pMatrix: this.pMatrix
      });

      for (let i = 0; i < objectPositions.length; i++) {
        let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].create());
        gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].translate(mMatrix, mMatrix, objectPositions[i]);
        this.gBufferPrg.style({
          mMatrix
        });

        for (let i = 0; i < this.nanosuit.length; i++) {
          this.nanosuit[i].bind(this.gBufferPrg, ['position', 'normal', 'texCoord']);
          this.nanosuit[i].draw();
        }
      }
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT); // gl.activeTexture(gl.TEXTURE0)
    // gl.bindTexture(gl.TEXTURE_2D, this.mrt.texture[1])
    // this.fboPrg.use()
    // this.fboPrg.style({
    //   fboAttachment: 0
    // })
    // this.quad.bind(this.fboPrg, ['position', 'texCoord'])
    // this.quad.draw(gl.TRIANGLE_STRIP)

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.mrt.texture[0]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE1);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.mrt.texture[1]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE2);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.mrt.texture[2]);
    this.prg.use();
    this.prg.style({
      gPosition: 0,
      gNormal: 1,
      gAlbedoSpec: 2,
      viewPos: this.camera.position
    }, true);

    for (let i = 0; i < lightPositions.length; i++) {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].uniform3fv(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getUniformLocation(this.prg.program, [`lights[${i}].Position`]), lightPositions[i]);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].uniform3fv(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getUniformLocation(this.prg.program, [`lights[${i}].Color`]), lightColors[i]);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].uniform1f(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getUniformLocation(this.prg.program, [`lights[${i}].Linear`]), .1);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].uniform1f(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getUniformLocation(this.prg.program, [`lights[${i}].Quadratic`]), .12);
    }

    this.quad.bind(this.prg, ['position', 'texCoord']);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TRIANGLE_STRIP); // copy depth

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].READ_FRAMEBUFFER, this.mrt.frameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DRAW_FRAMEBUFFER, null); // write to default framebuffer
    // blit to default framebuffer. Note that this may or may not work as the internal formats of both the FBO and default framebuffer have to match.
    // the internal formats are implementation defined. This works on all of my systems, but if it doesn't on yours you'll likely have to write to the
    // depth buffer in another shader stage (or somehow see to match the default framebuffer's internal format with the FBO's internal format).

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].blitFramebuffer(0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height, 0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].NEAREST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null); // render light cubes

    this.lampPrg.use();
    this.lampPrg.style({
      vMatrix: this.vMatrix,
      pMatrix: this.pMatrix
    });

    for (let i = 0; i < lightPositions.length; i++) {
      let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].create());
      gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].translate(mMatrix, mMatrix, lightPositions[i]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_14__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [.3, .3, .3]);
      this.lampPrg.style({
        mMatrix,
        lightColor: lightColors[i]
      });
      this.cube.bind(['position']);
      this.cube.draw();
    }
  }

}

function framebufferMRT(width, height, type) {
  let frameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createFramebuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, frameBuffer);
  let fTexture = [];
  const bufferList = [];

  for (let i = 0; i < type.length; ++i) {
    fTexture[i] = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, fTexture[i]);

    if (type[i] === '16f') {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA16F, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].HALF_FLOAT, null);
    } else {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].UNSIGNED_BYTE, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0 + i, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, fTexture[i], 0);
    bufferList.push(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0 + i);
  }

  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].drawBuffers(bufferList); // 指定渲染目标

  const depthRenderBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createRenderbuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, depthRenderBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].renderbufferStorage(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH24_STENCIL8, width, height);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_ATTACHMENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, depthRenderBuffer);
  const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER);

  if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER_COMPLETE) {
    console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
  }

  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null);
  return {
    frameBuffer: frameBuffer,
    depthBuffer: depthRenderBuffer,
    texture: fTexture
  };
}
/*
while (...) // 游戏循环
{
  // 1. 几何处理阶段：渲染所有的几何/颜色数据到G缓冲
  glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  gBufferShader.Use();
  for (Object obj: Objects) {
    ConfigureShaderTransformsAndUniforms();
    obj.Draw();
  }
  // 2. 光照处理阶段：使用G缓冲计算场景的光照
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  glClear(GL_COLOR_BUFFER_BIT);
  lightingPassShader.Use();
  BindAllGBufferTextures();
  SetLightingUniforms();
  RenderQuad();
}

*/module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nout vec4 outColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedoSpec;\n\nstruct Light {\n    vec3 Position;\n    vec3 Color;\n\n    float Linear;\n    float Quadratic;\n};\nconst int NR_LIGHTS = 32;\nuniform Light lights[NR_LIGHTS];\nuniform vec3 viewPos;\n\nvoid main() {\n    vec3 FragPos = texture(gPosition, TexCoords).rgb;\n    vec3 Normal = texture(gNormal, TexCoords).rgb;\n    vec3 Diffuse = texture(gAlbedoSpec, TexCoords).rgb;\n    float Specular = texture(gAlbedoSpec, TexCoords).a;\n\n    // then calculate lighting as usual\n    vec3 lighting  = Diffuse * .1; // hard-coded ambient component\n    vec3 viewDir  = normalize(viewPos - FragPos);\n    for(int i = 0; i < NR_LIGHTS; ++i)\n    {\n        // diffuse\n        vec3 lightDir = normalize(lights[i].Position - FragPos);\n        vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * lights[i].Color;\n        // specular\n        vec3 halfwayDir = normalize(lightDir + viewDir);\n        float spec = pow(max(dot(Normal, halfwayDir), 0.0), 16.0);\n        vec3 specular = lights[i].Color * spec * Specular;\n        // attenuation\n        float distance = length(lights[i].Position - FragPos);\n        float attenuation = 1.0 / (1.0 + lights[i].Linear * distance + lights[i].Quadratic * distance * distance);\n        diffuse *= attenuation;\n        specular *= attenuation;\n        lighting += diffuse + specular;\n    }\n    outColor = vec4(lighting, 1.0);\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\nout vec3 FragPos;\nout vec2 TexCoords;\nout vec3 Normal;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    vec4 worldPos = mMatrix * vec4(position, 1.0);\n    FragPos = vec3(worldPos);\n\n    TexCoords = texCoord;\n\n    mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n    Normal = normalMatrix * normal;\n\n    gl_Position = pMatrix * vMatrix * worldPos;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nlayout (location = 0) out vec3 gPosition;\nlayout (location = 1) out vec3 gNormal;\nlayout (location = 2) out vec4 gAlbedoSpec;\n\nin vec2 TexCoords;\nin vec3 FragPos;\nin vec3 Normal;\n\nuniform sampler2D diffuseMap1;\nuniform sampler2D specularMap1;\n\nvoid main()\n{\n    // store the fragment position vector in the first gbuffer texture\n    gPosition = FragPos;\n    // also store the per-fragment normals into the gbuffer\n    gNormal = normalize(Normal);\n    // and the diffuse per-fragment color\n    gAlbedoSpec.rgb = texture(diffuseMap1, TexCoords).rgb;\n    // store specular intensity in gAlbedoSpec's alpha component\n    gAlbedoSpec.a = texture(specularMap1, TexCoords).r;\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\n\nout vec2 TexCoords;\nvoid main(){\n  TexCoords = texCoord;\n  gl_Position = vec4(position, 1.);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nout vec4 FragColor;\nin  vec2 TexCoords;\n\nuniform sampler2D fboAttachment;\n\nvoid main()\n{\n    FragColor = vec4(texture(fboAttachment, TexCoords).rgb, 1.);\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\nuniform vec3 lightColor;\nvoid main()\n{\n    FragColor = vec4(lightColor, 1.0); \n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EnvMap; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_Geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var libs_shaders_CustomShaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
/* harmony import */ var shaders_env_map_env_specular_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81);
/* harmony import */ var shaders_env_map_env_specular_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_env_map_env_specular_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_env_map_env_specular_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82);
/* harmony import */ var shaders_env_map_env_specular_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_env_map_env_specular_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_env_map_env_refract_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(83);
/* harmony import */ var shaders_env_map_env_refract_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_env_map_env_refract_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_env_map_env_refract_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(84);
/* harmony import */ var shaders_env_map_env_refract_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_env_map_env_refract_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_env_map_fresnell_chromatic_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(85);
/* harmony import */ var shaders_env_map_fresnell_chromatic_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_env_map_fresnell_chromatic_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_env_map_fresnell_chromatic_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(86);
/* harmony import */ var shaders_env_map_fresnell_chromatic_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_env_map_fresnell_chromatic_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(0);


/*
 https://developer.download.nvidia.cn/CgTutorial/cg_tutorial_chapter07.html
*/











class EnvMap extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(libs_shaders_CustomShaders__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].skyboxVert, libs_shaders_CustomShaders__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].skyboxFrag);
    this.specularPrg = this.compile(shaders_env_map_env_specular_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_env_map_env_specular_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.refractPrg = this.compile(shaders_env_map_env_refract_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_env_map_env_refract_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.frenellPrg = this.compile(shaders_env_map_fresnell_chromatic_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_env_map_fresnell_chromatic_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
  }

  attrib() {
    this.skybox = libs_Geom__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].skybox(40);
  }

  prepare() {
    this.skyMap = getAssets.outputskybox;
    this.venus = getAssets.statue;
    this.camera.radius = 6;
  }

  uniform() {
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].perspective(this.pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "d"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* canvas */ "b"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].multiply(this.tmpMatrix, this.pMatrix, this.vMatrix);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.skyMap.texture);
    this.prg.use();
    this.prg.style({
      mvpMatrix: this.mvpMatrix,
      uGamma: 2.2,
      uExposure: 5.,
      tex: 0
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.prg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* GlTools */ "a"].draw(this.skybox);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(mMatrix, mMatrix, [-3, 0, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
    this.specularPrg.use();
    this.specularPrg.style({
      mMatrix: mMatrix,
      vMatrix: this.vMatrix,
      pMatrix: this.pMatrix,
      skybox: 0,
      cameraPos: this.camera.position
    });

    for (let i = 0; i < this.venus.length; i++) {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* GlTools */ "a"].draw(this.venus[i], true);
    }

    mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(mMatrix, mMatrix, [3, 0, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
    this.refractPrg.use();
    this.refractPrg.style({
      mMatrix: mMatrix,
      vMatrix: this.vMatrix,
      pMatrix: this.pMatrix,
      skybox: 0,
      cameraPos: this.camera.position
    });

    for (let i = 0; i < this.venus.length; i++) {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* GlTools */ "a"].draw(this.venus[i], true);
    }

    mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(mMatrix, mMatrix, [0, 0, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
    this.refractPrg.use();
    this.refractPrg.style({
      mMatrix: mMatrix,
      vMatrix: this.vMatrix,
      pMatrix: this.pMatrix,
      skybox: 0,
      cameraPos: this.camera.position,
      etaRatio: [.65, .67, .69],
      fresnelPower: .8,
      fresnelBias: .1,
      fresnelScale: .9
    });

    for (let i = 0; i < this.venus.length; i++) {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* GlTools */ "a"].draw(this.venus[i], true);
    }
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec3 Normal;\nout vec3 Position;\n\nvoid main()\n{\n    Normal = mat3(transpose(inverse(mMatrix))) * normal;\n    Position = vec3(mMatrix * vec4(position, 1.0));\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}  "module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin vec3 Normal;\nin vec3 Position;\nuniform vec3 cameraPos;\nuniform samplerCube skybox;\nout vec4 FragColor;\n\nvec3 reflect (vec3  I, vec3 N)\n{\n  return I - 2.0 * N * dot(N, I);\n}\n\nvoid main()\n{             \n    vec3 I = normalize(Position - cameraPos);\n    vec3 R = reflect(I, normalize(Normal));\n    FragColor = vec4(texture(skybox, R).rgb, 1.0);\n}"module.exports = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec3 normal;\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec3 Normal;\nout vec3 Position;\n\nvoid main()\n{\n    Normal = mat3(transpose(inverse(mMatrix))) * normal;\n    Position = vec3(mMatrix * vec4(position, 1.0));\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}  "module.exports = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec3 Normal;\nin vec3 Position;\nuniform vec3 cameraPos;\nuniform samplerCube skybox;\nout vec4 FragColor;\n\nvoid main()\n{             \n    float ratio = 1.00 / 1.52;\n    vec3 I = normalize(Position - cameraPos);\n    vec3 R = refract(I, normalize(Normal), ratio);\n    FragColor = vec4(texture(skybox, R).rgb, 1.0);\n}  "module.exports = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec3 position;\nin vec3 normal;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec3 Normal;\nout vec3 Position;\n\nvoid main()\n{\n    Normal = mat3(transpose(inverse(mMatrix))) * normal;\n    Position = vec3(mMatrix * vec4(position, 1.0));\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}  "module.exports = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec3 Normal;\nin vec3 Position;\nuniform vec3 cameraPos;\nuniform samplerCube skybox;\nuniform float fresnelBias;\n\nuniform float fresnelScale;\n\nuniform float fresnelPower;\n\nuniform vec3 etaRatio;\n\nout vec4 FragColor;\n\nvoid main()\n{             \n    float ratio = 1.00 / 1.52;\n    vec3 I = normalize(Position - cameraPos);\n    vec3 N = normalize(Normal);\n    vec3 R = refract(I, N, ratio);\n    \n    vec3 TRed   = refract(I, N, etaRatio.x);\n\n    vec3 TGreen = refract(I, N, etaRatio.y);\n\n    vec3 TBlue  = refract(I, N, etaRatio.z);\n\n     // Compute the reflection factor\n\n    float reflectionFactor = fresnelBias + fresnelScale * pow(1. + dot(I, N), fresnelPower);\n    vec4 reflectedColor = texture(skybox, R);\n\n\n    // Compute the refracted environment color\n\n    vec4 refractedColor;\n\n    refractedColor.r = texture(skybox, TRed).r;\n\n    refractedColor.g = texture(skybox, TGreen).g;\n\n    refractedColor.b = texture(skybox, TBlue).b;\n\n    refractedColor.a = 1.;\n\n\n    // Compute the final color\n\n    FragColor = mix(refractedColor, reflectedColor, vec4(reflectionFactor));\n\n}  "__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NormalMap; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var shaders_normal_map_normal_map_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87);
/* harmony import */ var shaders_normal_map_normal_map_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_normal_map_normal_map_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_normal_map_normal_map_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88);
/* harmony import */ var shaders_normal_map_normal_map_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_normal_map_normal_map_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);







let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* mat4 */ "b"].create());
let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* mat4 */ "b"].create()); // http://ogldev.atspace.co.uk/www/tutorial26/tutorial26.html
// Gramm-Schmid 正交可将从fragment里被光栅化，不再正交与normal的tangent重新正交化
// https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E5%A7%86-%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96
// 和cemra的lookat一样，将基坐标乘以切线空间的normal得到贴图方向的normal，乘法基于scalar project得到三个方向的向量
// normalmap是当前平面方向的微调，所以得到平面或者叫贴图的normal就行
// 比如一个朝向y+方向的面，得到的normal还是垂直表面的，normalmap上不经过转化，是指向z的，蓝色的，计算后，应该是以表面normal为基准的分量
// 即指向y+的，只是有些微调

/* eg.
  let T = vec3.fromValues(0, .3, 1)
  let N = vec3.fromValues(0, 1, 0)
  console.log(vec3.subtract(T, T, vec3.scale(N, N, vec3.dot(T, N))))
  施密特正交后是[0, 0, 1]，与N垂直
  按照想法，normalmap上的（0，0，1）与N（0，1，0）经过TBN乘法得到的还是（0，1，0）
  TBN乘法项与摄像机XYZ单位向量相同 http: //ogldev.atspace.co.uk/www/tutorial13/tutorial13.html
  因此，normalmap切线空间的（0，0，1）只在z轴，即N上有投影，得到的与N相同（0，1，0）
  mat4[T,B,N,1] * [0,0,1,1] = [0,1,0,1] （N = [0,1,0]）
  世界空间坐标系 * 切线空间坐标 = 世界空间坐标 ＜（＾－＾）＞

*/

const caculateTBN = N => {
  const leftTop = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].fromValues(-1., 0, -1.);
  const leftBottom = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].fromValues(-1, 0, 1);
  const rightBootm = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].fromValues(1, 0, 1);
  const rightTop = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].fromValues(1, 0, -1);
  const uv1 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].fromValues(0, 1);
  const uv2 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].fromValues(0, 0);
  const uv3 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].fromValues(1, 0);
  const uv4 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].fromValues(1, 1);
  const nm = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].fromValues(0.0, 1.0, 0.0);
  const edge1 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].create();
  const edge2 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].create();
  const deltaUV1 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].create();
  const deltaUV2 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].create(); // triangle 1
  // ----------

  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].subtract(edge1, leftBottom, leftTop);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].subtract(edge2, rightBootm, leftTop);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].subtract(deltaUV1, uv2, uv1);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].subtract(deltaUV2, uv3, uv1);
  let f = 1.0 / (deltaUV1[0] * deltaUV2[1] - deltaUV2[0] * deltaUV1[1]);
  const tangent1 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].create();
  const bitangent1 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].create();
  const tangent2 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].create();
  const bitangent2 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].create();
  tangent1[0] = f * (deltaUV2[1] * edge1[0] - deltaUV1[1] * edge2[0]);
  tangent1[1] = f * (deltaUV2[1] * edge1[1] - deltaUV1[1] * edge2[1]);
  tangent1[2] = f * (deltaUV2[1] * edge1[2] - deltaUV1[1] * edge2[2]);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].normalize(tangent1, tangent1);
  bitangent1[0] = f * (-deltaUV2[0] * edge1[0] + deltaUV1[0] * edge2[0]);
  bitangent1[1] = f * (-deltaUV2[0] * edge1[1] + deltaUV1[0] * edge2[1]);
  bitangent1[2] = f * (-deltaUV2[0] * edge1[2] + deltaUV1[0] * edge2[2]);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].normalize(bitangent1, bitangent1); // triangle 2
  // ----------

  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].subtract(edge1, rightBootm, leftTop);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].subtract(edge2, rightTop, leftTop);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].subtract(deltaUV1, uv3, uv1);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec2 */ "d"].subtract(deltaUV2, uv4, uv1);
  f = 1.0 / (deltaUV1[0] * deltaUV2[1] - deltaUV2[0] * deltaUV1[1]);
  tangent2[0] = f * (deltaUV2[1] * edge1[0] - deltaUV1[1] * edge2[0]);
  tangent2[1] = f * (deltaUV2[1] * edge1[1] - deltaUV1[1] * edge2[1]);
  tangent2[2] = f * (deltaUV2[1] * edge1[2] - deltaUV1[1] * edge2[2]);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].normalize(tangent2, tangent2);
  bitangent2[0] = f * (-deltaUV2[0] * edge1[0] + deltaUV1[0] * edge2[0]);
  bitangent2[1] = f * (-deltaUV2[0] * edge1[1] + deltaUV1[0] * edge2[1]);
  bitangent2[2] = f * (-deltaUV2[0] * edge1[2] + deltaUV1[0] * edge2[2]);
  gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* vec3 */ "e"].normalize(bitangent2, bitangent2);
  const quadVertices = [// positions            // normal         // texcoords  // tangent                          // bitangent
  leftTop[0], leftTop[1], leftTop[2], nm[0], nm[1], nm[2], uv1[0], uv1[1], tangent1[0], tangent1[1], tangent1[2], bitangent1[0], bitangent1[1], bitangent1[2], leftBottom[0], leftBottom[1], leftBottom[2], nm[0], nm[1], nm[2], uv2[0], uv2[1], tangent1[0], tangent1[1], tangent1[2], bitangent1[0], bitangent1[1], bitangent1[2], rightBootm[0], rightBootm[1], rightBootm[2], nm[0], nm[1], nm[2], uv3[0], uv3[1], tangent1[0], tangent1[1], tangent1[2], bitangent1[0], bitangent1[1], bitangent1[2], leftTop[0], leftTop[1], leftTop[2], nm[0], nm[1], nm[2], uv1[0], uv1[1], tangent2[0], tangent2[1], tangent2[2], bitangent2[0], bitangent2[1], bitangent2[2], rightBootm[0], rightBootm[1], rightBootm[2], nm[0], nm[1], nm[2], uv3[0], uv3[1], tangent2[0], tangent2[1], tangent2[2], bitangent2[0], bitangent2[1], bitangent2[2], rightTop[0], rightTop[1], rightTop[2], nm[0], nm[1], nm[2], uv4[0], uv4[1], tangent2[0], tangent2[1], tangent2[2], bitangent2[0], bitangent2[1], bitangent2[2]];
  return quadVertices;
};

const lightPos = [0, 3, 0];
class NormalMap extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_normal_map_normal_map_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_normal_map_normal_map_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
  }

  attrib() {
    const quadVertices = caculateTBN();
    this.quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]();
    this.quad.bufferFlattenData(quadVertices, ['position', 'normal', 'texCoord', 'tangent', 'bitangent'], [3, 3, 2, 3, 3]);
  }

  prepare() {
    this.camera.offset = [0, 2, 0];
    libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* gl */ "c"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* gl */ "c"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* gl */ "c"].clearDepth(1.0);
    const brickwall = getAssets.brickwall;
    const brickwallNormal = getAssets.brickwallNormal;
    brickwall.bind(0);
    brickwallNormal.bind(1);
  }

  uniform() {
    vMatrix = this.camera.viewMatrix;
    gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* mat4 */ "b"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* toRadian */ "d"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* canvas */ "b"].clientHeight, .1, 100);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_5__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [1.8, 1.8, 1.8]);
    this.prg.use();
    this.prg.style({
      mMatrix,
      vMatrix,
      pMatrix,
      viewPos: this.camera.position,
      lightPos,
      diffuseMap: 0,
      normalMap: 1
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.prg.use();
    this.quad.bind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_6__[/* GlTools */ "a"].draw(this.quad);
  }

}module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\nlayout (location = 3) in vec3 tangent;\nlayout (location = 4) in vec3 bitangent;\n\n\nout vec3 FragPos;\nout vec2 TexCoords;\nout vec3 TangentLightPos;\nout vec3 TangentViewPos;\nout vec3 TangentFragPos;\n\n\nuniform mat4 pMatrix;\nuniform mat4 vMatrix;\nuniform mat4 mMatrix;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nvoid main() {\n  FragPos = vec3(mMatrix * vec4(position, 1.));\n  TexCoords = texCoord;\n\n  mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n  vec3 T = normalize(normalMatrix * tangent);\n  vec3 N = normalize(normalMatrix * normal);\n  T = normalize(T - dot(T, N) * N);\n  vec3 B = cross(N, T);\n\n   mat3 TBN = transpose(mat3(T, B, N));\n  TangentLightPos = TBN * lightPos;\n  TangentViewPos  = TBN * viewPos;\n  TangentFragPos  = TBN * FragPos;\n\n  gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec3 FragPos;\nin vec2 TexCoords;\nin vec3 TangentLightPos;\nin vec3 TangentViewPos;\nin vec3 TangentFragPos;\n\n\nuniform sampler2D diffuseMap;\nuniform sampler2D normalMap;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nvoid main()\n{\n     // obtain normal from normal map in range [0,1]\n    vec3 normal = texture(normalMap, TexCoords).rgb;\n    // transform normal vector to range [-1,1]\n    normal = normalize(normal * 2.0 - 1.0);  // this normal is in tangent space\n\n    // get diffuse color\n    vec3 color = texture(diffuseMap, TexCoords).rgb;\n    // ambient\n    vec3 ambient = 0.1 * color;\n    // diffuse\n    vec3 lightDir = normalize(TangentLightPos - TangentFragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * color;\n    // specular\n    vec3 viewDir = normalize(TangentViewPos - TangentFragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n\n    vec3 specular = vec3(0.2) * spec;\n    FragColor = vec4(ambient + diffuse + specular, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SSAO; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_ssao_ssao_geometry_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89);
/* harmony import */ var shaders_ssao_ssao_geometry_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_geometry_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_ssao_ssao_geometry_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90);
/* harmony import */ var shaders_ssao_ssao_geometry_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_geometry_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_ssao_ssao_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(91);
/* harmony import */ var shaders_ssao_ssao_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_ssao_ssao_blur_frag__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(92);
/* harmony import */ var shaders_ssao_ssao_blur_frag__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_blur_frag__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_ssao_ssao_lighting_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(93);
/* harmony import */ var shaders_ssao_ssao_lighting_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_ssao_ssao_lighting_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3);
/* harmony import */ var libs_loaders_ObjLoader__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(18);
/* harmony import */ var libs_loaders_MTLLoader__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(35);
/* harmony import */ var libs_glFbo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(26);
/* harmony import */ var libs_glFbo__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(libs_glFbo__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var libs_Geom__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(8);


















const lightPositions = [0, -1, 0];
const lightColors = [.2, .2, .7];
const kernelSize = 64;
let ssaoKernel = new Float32Array(64 * 3);
let ssaoNoise = new Float32Array(16 * 3);

const generateSample = () => {
  for (let i = 0; i < kernelSize; i++) {
    let sample = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* vec3 */ "e"].fromValues(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random());
    ssaoKernel[i * 3] = sample[0];
    ssaoKernel[i * 3 + 1] = sample[1];
    ssaoKernel[i * 3 + 2] = sample[2];
  }
};

const generateNoise = () => {
  for (let i = 0; i < 16; i++) {
    let noise = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* vec3 */ "e"].fromValues(Math.random() * 2 - 1, Math.random() * 2 - 1, 0);
    ssaoNoise[i * 3] = noise[0];
    ssaoNoise[i * 3 + 1] = noise[1];
    ssaoNoise[i * 3 + 2] = noise[2];
  }
};

class SSAO extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension('OES_texture_float_linear'); // Even WebGL2 requires OES_texture_float_linear

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension("EXT_color_buffer_float"); // gl.getExtension('OES_texture_half_float')

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension('OES_texture_half_float_linear'); // gl.getExtension('EXT_shader_texture_lod')

    this.gBufferPrg = this.compile(shaders_ssao_ssao_geometry_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_ssao_ssao_geometry_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.ssaoPrg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_ssao_ssao_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.blurPrg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_ssao_ssao_blur_frag__WEBPACK_IMPORTED_MODULE_8___default.a);
    this.prg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_ssao_ssao_lighting_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
  }

  attrib() {
    var quad, materials;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          this.cube = libs_Geom__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"].cube(2);
          quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]();
          quad.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_10__["QuadData"], ['position', 'texCoord'], [3, 2]);
          this.quad = quad;
          _context.next = 6;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(new libs_loaders_MTLLoader__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"]('nanosuit.mtl', './assets/models/nanosuit').parse(getAssets.nanosuitMTL));

        case 6:
          materials = _context.sent;
          this.nanosuit = new libs_loaders_ObjLoader__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"]().parseObj(getAssets.nanosuit, materials);

        case 8:
        case "end":
          return _context.stop();
      }
    }, null, this);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearColor(0., 0., 0., 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LEQUAL); //position, normal, AlbedoSpec(diffuse, specular indensity)

    this.mrt = framebufferMRT(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height, ['16f', '16f', 'rgba']);
    this.ssaoFbo = new libs_glFbo__WEBPACK_IMPORTED_MODULE_15___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]);
    this.ssaoFbo.resize(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height);
    this.blurFbo = new libs_glFbo__WEBPACK_IMPORTED_MODULE_15___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]);
    this.blurFbo.resize(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height);
    generateSample();
    generateNoise();
    this.noiseTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_16___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGB).fromData(4, 4, ssaoNoise, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGB32F);
    this.noiseTexture.bind();
    this.noiseTexture.repeat(); // execute once

    this.camera.target = [0, -1., 0];
    this.camera.offset = [0, 0., 0];
    this.camera.radius = 3;
    this.camera.rx = -1.5;
  }

  uniform() {
    this.vMatrix = this.camera.viewMatrix;
    this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].perspective(this.pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientHeight, .1, 100);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, this.mrt.frameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.gBufferPrg.use();
    this.gBufferPrg.style({
      vMatrix: this.vMatrix,
      pMatrix: this.pMatrix
    });

    if (this.nanosuit) {
      // loaded
      let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].create());
      gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].translate(mMatrix, mMatrix, [-1.0, -3.3, 3.]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [.4, .4, .4]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].rotate(mMatrix, mMatrix, -Math.PI / 2, [1, 0, 0]);
      this.gBufferPrg.style({
        mMatrix,
        invertedNormals: 0
      });

      for (let i = 0; i < this.nanosuit.length; i++) {
        this.nanosuit[i].bind(this.gBufferPrg, ['position', 'normal', 'texCoord']);
        this.nanosuit[i].draw();
      }
    }

    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_11__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [8, 4, 8]);
    this.gBufferPrg.style({
      mMatrix,
      invertedNormals: 1
    });
    this.cube.bind(this.gBufferPrg, ['position', 'normal', 'texCoord']);
    this.cube.draw();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null);
    this.ssaoFbo.bind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.mrt.texture[0]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE1);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.mrt.texture[1]);
    this.noiseTexture.bind(2);
    this.ssaoPrg.use();
    this.ssaoPrg.style({
      gPositionDepth: 0,
      gNormal: 1,
      texNoise: 2,
      samples: ssaoKernel,
      pMatrix: this.pMatrix
    });
    this.quad.bind(this.ssaoPrg, ['position', 'texCoord']);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TRIANGLE_STRIP);
    this.ssaoFbo.unbind();
    this.blurFbo.bind();
    this.ssaoFbo.color.bind(0);
    this.blurPrg.use();
    this.blurPrg.style({
      ssaoInput: 0
    });
    this.quad.bind(this.blurPrg, ['position', 'texCoord']);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TRIANGLE_STRIP);
    this.blurFbo.unbind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.mrt.texture[0]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE1);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.mrt.texture[1]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE2);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.mrt.texture[2]);
    this.blurFbo.color.bind(3);
    this.prg.use();
    this.prg.style({
      gPosition: 0,
      gNormal: 1,
      gAlbedoSpec: 2,
      ssao: 3,
      viewPos: this.camera.position,
      'lights.Position': lightPositions,
      'lights.Color': lightColors,
      'lights.Linear': .09,
      'lights.Quadratic': .032
    });
    this.quad.bind(this.prg, ['position', 'texCoord']);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TRIANGLE_STRIP);
  }

}

function framebufferMRT(width, height, type) {
  let frameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createFramebuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, frameBuffer);
  let fTexture = [];
  const bufferList = [];

  for (let i = 0; i < type.length; ++i) {
    fTexture[i] = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, fTexture[i]);

    if (type[i] === '16f') {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA16F, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].HALF_FLOAT, null);
    } else {
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].UNSIGNED_BYTE, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0 + i, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, fTexture[i], 0);
    bufferList.push(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0 + i);
  }

  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].drawBuffers(bufferList); // 指定渲染目标

  const depthRenderBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createRenderbuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, depthRenderBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].renderbufferStorage(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH24_STENCIL8, width, height);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_ATTACHMENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, depthRenderBuffer);
  const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER);

  if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER_COMPLETE) {
    console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
  }

  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null);
  return {
    frameBuffer: frameBuffer,
    depthBuffer: depthRenderBuffer,
    texture: fTexture
  };
}
/*
  // 几何处理阶段: 渲染到G缓冲中
  glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);
  [...]
  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  // 使用G缓冲渲染SSAO纹理
  glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);
  glClear(GL_COLOR_BUFFER_BIT);
  shaderSSAO.Use();
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, gPositionDepth);
  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, gNormal);
  glActiveTexture(GL_TEXTURE2);
  glBindTexture(GL_TEXTURE_2D, noiseTexture);
  SendKernelSamplesToShader();
  glUniformMatrix4fv(projLocation, 1, GL_FALSE, glm::value_ptr(projection));
  RenderQuad();
  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  // 光照处理阶段: 渲染场景光照
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  shaderLightingPass.Use();
  [...]
  glActiveTexture(GL_TEXTURE3);
  glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);
  [...]
  RenderQuad();
*/module.exports = "#version 300 es\n#define GLSLIFY 1\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\nout vec3 FragPos;\nout vec2 TexCoords;\nout vec3 Normal;\n\nuniform bool invertedNormals;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    vec4 viewPos = vMatrix * mMatrix * vec4(position, 1.0);\n    FragPos = vec3(viewPos);\n    TexCoords = texCoord;\n\n    mat3 normalMatrix = transpose(inverse(mat3(mMatrix)));\n    Normal = normalMatrix * (invertedNormals ? -normal : normal);\n\n    gl_Position = pMatrix * viewPos;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nlayout (location = 0) out vec3 gPositionDepth;\nlayout (location = 1) out vec3 gNormal;\nlayout (location = 2) out vec4 gAlbedoSpec;\n\nin vec2 TexCoords;\nin vec3 FragPos;\nin vec3 Normal;\n\nconst float NEAR = 0.1; // 投影矩阵的近平面\nconst float FAR = 50.0f; // 投影矩阵的远平面\nfloat LinearizeDepth(float depth)\n{\n    float z = depth * 2.0 - 1.0; // 回到NDC\n    return (2.0 * NEAR * FAR) / (FAR + NEAR - z * (FAR - NEAR));\n}\n\n\nvoid main()\n{\n    // store the fragment position vector in the first gbuffer texture\n    gPositionDepth.xyz = FragPos;\n    // // 储存线性深度到gPositionDepth的alpha分量\n    // gPositionDepth.a = LinearizeDepth(gl_FragCoord.z);\n    // also store the per-fragment normals into the gbuffer\n    gNormal = normalize(Normal);\n    // and the diffuse per-fragment color\n    gAlbedoSpec.rgb = vec3(0.95);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout float FragColor;\nin vec2 TexCoords;\n\nuniform sampler2D gPositionDepth;\nuniform sampler2D gNormal;\nuniform sampler2D texNoise;\n\nuniform vec3 samples[64];\nuniform mat4 pMatrix;\n\nint kernelSize = 64;\nfloat radius = 0.5;\nfloat bias = 0.025;\n// 屏幕的平铺噪声纹理会根据屏幕分辨率除以噪声大小的值来决定\nconst vec2 noiseScale = vec2(960.0/4.0, 640.0/4.0);\n\nvoid main() {\n    vec3 fragPos = texture(gPositionDepth, TexCoords).xyz;\n    vec3 normal = texture(gNormal, TexCoords).rgb;\n    vec3 randomVec = texture(texNoise, TexCoords * noiseScale).xyz;\n\n    // Gramm-Schmidt正交化\n    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\n    vec3 bitangent = cross(normal, tangent);\n    mat3 TBN = mat3(tangent, bitangent, normal);\n\n    float occlusion = 0.0;\n    for(int i = 0; i < kernelSize; ++i)\n    {\n        // 获取样本位置\n        vec3 sample1 = TBN * samples[i]; // 切线->观察空间\n        sample1 = fragPos + sample1 * radius;\n\n        vec4 offset = vec4(sample1, 1.0);\n        offset = pMatrix * offset; // 观察->裁剪空间\n        offset.xyz /= offset.w; // 透视划分\n        offset.xyz = offset.xyz * 0.5 + 0.5; // 变换到0.0 - 1.0的值域\n\n        float sampleDepth = texture(gPositionDepth, offset.xy).z;\n        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));\n        occlusion += (sampleDepth >= sample1.z ? 1.0 : 0.0) * rangeCheck;\n\n    }\n    occlusion = 1.0 - (occlusion / float(kernelSize));\n    FragColor = occlusion;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin vec2 TexCoords;\nout float FragColor;\nuniform sampler2D ssaoInput;\n\nvoid main() {\n  // simple box filter\n  vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0));\n  float result = 0.0;\n  for (int x = -2; x < 2; ++x)\n  {\n    for (int y = -2; y < 2; ++y)\n    {\n        vec2 offset = vec2(float(x), float(y)) * texelSize;\n        result += texture(ssaoInput, TexCoords + offset).r;\n    }\n  }\n  FragColor = result / (4.0 * 4.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nout vec4 outColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedoSpec;\nuniform sampler2D ssao;\n\nstruct Light {\n    vec3 Position;\n    vec3 Color;\n\n    float Linear;\n    float Quadratic;\n};\nuniform Light lights;\nuniform vec3 viewPos;\n\nvoid main() {\n    vec3 FragPos = texture(gPosition, TexCoords).rgb;\n    vec3 Normal = texture(gNormal, TexCoords).rgb;\n    vec3 Diffuse = texture(gAlbedoSpec, TexCoords).rgb;\n    float AmbientOcclusion = texture(ssao, TexCoords).r;\n\n    // then calculate lighting as usual\n    vec3 ambient = vec3(0.3 * Diffuse * AmbientOcclusion);\n    vec3 lighting  = ambient;\n    vec3 viewDir  = normalize(- FragPos);\n\n\n    // diffuse\n    vec3 lightDir = normalize(lights.Position - FragPos);\n    vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * lights.Color;\n    // specular\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(Normal, halfwayDir), 0.0), 16.0);\n    vec3 specular = lights.Color * spec;\n    // attenuation\n    float distance = length(lights.Position - FragPos);\n    float attenuation = 1.0 / (1.0 + lights.Linear * distance + lights.Quadratic * distance * distance);\n    diffuse *= attenuation;\n    specular *= attenuation;\n    lighting += diffuse + specular;\n\n    outColor = vec4(lighting, 1.0);\n}\n"var Texture = __webpack_require__(4);
/**
 * @class
 * @param {WebGLRenderingContext} gl      the webgl context this Fbo belongs to
 * @param {Object} [opts]
 * @param {boolean} [opts.depth=false] if true, a depth renderbuffer is attached
 * @param {boolean} [opts.stencil=false] if true, a stencil renderbuffer is attached
 * @param {GLenum|GLenum[]} [opts.type=GL_UNSIGNED_BYTE] the pixel type of the Fbo, can be gl.UNSIGNED_BYTE, gl.FLOAT, half.HALF_FLOAT_OES etc. you can also provide an array of types used as cascaded fallbacks
 * @param {GLenum} [opts.format=GL_RGB] the internal pixel format.
 *
 */


function Fbo(gl, opts) {
  this.gl = gl;
  this.width = 0;
  this.height = 0;
  this.fbo = null;
  opts = opts || DEFAULT_OPTS;
  var flags = opts.depth | opts.stencil << 1;
  var types = opts.type || gl.UNSIGNED_BYTE;
  this.types = Array.isArray(types) ? types : [types];
  this.color = new Texture(gl, opts.format);
  this.attachment = new DepthStencilAttachment(this, flags);
}

Fbo.prototype = {
  /**
   * Resize FBO attachments
   *  @param {uint} w new width
   *  @param {uint} h new height
   */
  resize: function (w, h) {
    if (this.width !== w || this.height !== h) {
      this.width = w | 0;
      this.height = h | 0;

      if (this.fbo === null) {
        this._init();
      }

      this._allocate();
    }
  },

  /**
   * Bind the color texture of this Fbo to a sampler2D location and a unit
   * The related program must be in use.
   * @param {WebGLUniformLocation} location the program's sampler to bind the textue to
   * @param {} unit the texture unit to use
   */
  bindColor: function (location, unit) {
    var gl = this.gl;
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, this.color.id);
    gl.uniform1i(location, unit);
  },

  /**
   * Bind the Fbo and set gl viewport to it's size
   */
  bind: function () {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
    gl.viewport(0, 0, this.width, this.height);
  },
  unbind: function () {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  },

  /**
   * Clear all buffer of the Fbo.
   * The Fbo must be explicitly bound before calling this method
   */
  clear: function () {
    var gl = this.gl;
    var bits = gl.COLOR_BUFFER_BIT | this.attachment.clearBits();
    gl.clear(bits);
  },

  /**
   * Check if the Fbo is valid,
   * The Fbo must be explicitely bound before calling this method
   */
  isValid: function () {
    var gl = this.gl;
    return gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
  },

  /**
   * return the actual pixel type of the underlying color texture (UNSIGNED_BYTE, FLOAT, HALF_FLOAT_EOS etc)
   * after possibles types has been tested
   */
  getActualType: function () {
    return this.color.type;
  },

  /**
   * Delete all webgl objects related to this Fbo (fbo, color attachment and depth/stencil renderbuffer )
   */
  dispose: function () {
    var gl = this.gl;
    gl.deleteFramebuffer(this.fbo);
    this.color.dispose();
    this.attachment.dispose();
    this.valid = false;
    this.fbo = null;
    this.gl = null;
  },
  // create render buffers and set attchment points
  _init: function () {
    var gl = this.gl;
    this.fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.color.id, 0);

    this.attachment._init();
  },
  // (re)allocate render buffers to size
  _allocate: function () {
    var gl = this.gl;

    this.attachment._allocate();

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
    var tIndex = 0;
    var nextFmt = this.types[tIndex];

    do {
      this.color.fromData(this.width, this.height, null, nextFmt);
      gl.getError(); // clear possible texture error
    } while (!(this.valid = this.isValid()) && (nextFmt = this.types[++tIndex]));

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
}; //---------------------------------
//         Depth/Stencil Attachment
//---------------------------------

function DepthStencilAttachment(fbo, flags) {
  this.fbo = fbo;
  this.flags = flags;
  this.buffer = null;
}

DepthStencilAttachment.prototype = {
  _init: function () {
    var gl = this.fbo.gl;
    var attType = this.flags & 3;
    var depth = null;

    if (attType !== 0) {
      depth = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, depth);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, getAttachmentType(gl, attType), gl.RENDERBUFFER, depth);
    }

    this.buffer = depth;
  },
  _allocate: function () {
    var gl = this.fbo.gl;
    var attType = this.flags & 3;

    if (attType !== 0) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.buffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, getAttachmentFormat(gl, attType), this.fbo.width, this.fbo.height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
  },
  dispose: function () {
    if (this.buffer) {
      this.fbo.gl.deleteRenderbuffer(this.buffer);
    }

    this.buffer = null;
  },
  clearBits: function () {
    return (this.flags & 1 ? 0x0100 : 0) | (this.flags & 2 ? 0x0400 : 0);
  }
}; //---------------------------------
//                        Utilities
//---------------------------------
// renderbuffer format

function getAttachmentFormat(gl, type) {
  switch (type) {
    case 1:
      return 0x81A5;
    // DEPTH_COMPONENT16;

    case 2:
      return 0x8D48;
    // STENCIL_INDEX8;

    case 3:
      return 0x84F9;
    // DEPTH_STENCIL;

    default:
      throw new Error('unknown attachment type ' + type);
  }
}

function getAttachmentType(gl, type) {
  switch (type) {
    case 1:
      return 0x8D00;
    // DEPTH_ATTACHMENT

    case 2:
      return 0x8D20;
    // STENCIL_ATTACHMENT;

    case 3:
      return 0x821A;
    // DEPTH_STENCIL_ATTACHMENT;

    default:
      throw new Error('unknown attachment type ' + type);
  }
}

var DEFAULT_OPTS = {};
module.exports = Fbo;var _UID = 0;
var T2D = 0x0DE1;
/*
 * compute filtering enum, return one of the following :
 *  NEAREST
 *  LINEAR
 *  NEAREST_MIPMAP_NEAREST
 *  LINEAR_MIPMAP_NEAREST
 *  NEAREST_MIPMAP_LINEAR
 *  LINEAR_MIPMAP_LINEAR
 */

function getFilter(smooth, mipmap, miplinear) {
  return 0x2600 | +smooth | +mipmap << 8 | +(mipmap && miplinear) << 1;
}
/**
 * @class
 * @classdesc Texture class manage TEXTURE_2D types textures
 *
 *  @param {WebGLRenderingContext} gl webgl context the texture belongs to
 *  @param {GLenum} [format=GL_RGB] the pixel format, default to gl.RGB (can be gl.RGB, gl.RGBA, gl.LUMINANCE...)
 */


function Texture(gl, format) {
  this._uid = _UID++;
  this.gl = gl;
  this.id = this.gl.createTexture();
  this.width = 0;
  this.height = 0;
  this.format = format || gl.RGB;
  this.type = gl.UNSIGNED_BYTE;
  this.img = null;
  gl.bindTexture(T2D, this.id);
  this.setFilter(true);
  return this;
}

Texture.prototype = {
  /**
   * set texture data from html source
   *   @param {TexImageSource} img the source. Can be ImageBitmap, ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement
   */
  fromImage: function (img) {
    var gl = this.gl;
    this.img = img;
    this.width = img.width;
    this.height = img.height;
    gl.bindTexture(T2D, this.id);
    gl.texImage2D(T2D, 0, this.format, this.format, this.type, img);
    return this;
  },

  /**
   * Allocate texture to the given size, with optional data (TypedArray) and data type
   *  @param {number} width     the new texture's width
   *  @param {number} height    the new texture's height
   *  @param {TypedArray} [data=null]  TypedArray of texture data, can be null
   *  @param {GLenum} [dataType=GL_UNSIGNED_BYTE] can be gl.UNSIGNED_BYTE, gl.FLOAT, half.HALF_FLOAT_OES etc depending on available extensions
   */
  fromData: function (width, height, data, dataType) {
    var gl = this.gl;
    this.width = width;
    this.height = height;
    data = data || null;
    this.type = dataType || gl.UNSIGNED_BYTE;
    gl.bindTexture(T2D, this.id);

    if (window.useWebgl2) {
      // type = gl.RGBA16F etc..
      if (dataType === gl.RGBA16F) gl.texImage2D(gl.TEXTURE_2D, 0, this.type, width, height, 0, this.format, gl.HALF_FLOAT, data);else if (dataType === gl.RG32F || dataType === gl.RGBA32F || dataType === gl.RGB32F) gl.texImage2D(gl.TEXTURE_2D, 0, this.type, width, height, 0, this.format, gl.FLOAT, data);else gl.texImage2D(T2D, 0, this.format, width, height, 0, this.format, this.type, data);
    } else gl.texImage2D(T2D, 0, this.format, width, height, 0, this.format, this.type, data);

    return this;
  },

  /**
   * Bind the texture
   *   @param {uint} [unit=undefined] optional texture unit to make active before binding
   */
  bind: function (unit) {
    var gl = this.gl;

    if (unit !== undefined) {
      gl.activeTexture(gl.TEXTURE0 + (0 | unit));
    }

    gl.bindTexture(T2D, this.id);
  },

  /**
   * delete the webgl texture
   *
   */
  dispose: function () {
    this.gl && this.gl.deleteTexture(this.id);
    this.id = null;
    this.gl = null;
  },

  /**
   * Change the filtering parameters
   *   @param {boolean} [smooth=false]    if true, use LINEAR filtering
   *   @param {boolean} [mipmap=false]    if true, enable mipmaping
   *   @param {boolean} [miplinear=false] if true, use linear Mipmapping
   */
  setFilter: function (smooth, mipmap, miplinear) {
    var gl = this.gl;
    var filter = getFilter(!!smooth, !!mipmap, !!miplinear);
    gl.texParameteri(T2D, gl.TEXTURE_MAG_FILTER, getFilter(!!smooth, false, false));
    gl.texParameteri(T2D, gl.TEXTURE_MIN_FILTER, filter);
  },

  /**
   * Set both WRAP_S and WRAP_T property to gl.REPEAT
   */
  repeat: function () {
    this.wrap(this.gl.REPEAT);
  },

  /**
   * Set both WRAP_S and WRAP_T property to gl.CLAMP_TO_EDGE
   */
  clamp: function () {
    this.wrap(this.gl.CLAMP_TO_EDGE);
  },

  /**
   * Set both WRAP_S and WRAP_T property to gl.MIRRORED_REPEAT
   */
  mirror: function () {
    this.wrap(this.gl.MIRRORED_REPEAT);
  },

  /**
   * Set both WRAP_S and WRAP_T property to the given value
   *  @param {GLenum} wrap the wrap enum
   */
  wrap: function (wrap) {
    var gl = this.gl;
    gl.texParameteri(T2D, gl.TEXTURE_WRAP_S, wrap);
    gl.texParameteri(T2D, gl.TEXTURE_WRAP_T, wrap);
  }
};
module.exports = Texture;__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Shadow; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_shadow_depth_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94);
/* harmony import */ var shaders_shadow_depth_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_depth_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_shadow_depth_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(95);
/* harmony import */ var shaders_shadow_depth_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_depth_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17);
/* harmony import */ var shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_shadow_depthQuad_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(96);
/* harmony import */ var shaders_shadow_depthQuad_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_depthQuad_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_shadow_shadowMapping_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(97);
/* harmony import */ var shaders_shadow_shadowMapping_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_shadowMapping_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_shadow_shadowMapping_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(98);
/* harmony import */ var shaders_shadow_shadowMapping_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_shadow_shadowMapping_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(6);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3);













const shadowWidth = 1024;
const shadowHeight = 1024;
const lightPos = [0, 4, -1];
let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
class Shadow extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_shadow_depth_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_shadow_depth_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.depthQuadPrg = this.compile(shaders_deferred_shading_finalQuad_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_shadow_depthQuad_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.shadowPrg = this.compile(shaders_shadow_shadowMapping_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_shadow_shadowMapping_frag__WEBPACK_IMPORTED_MODULE_9___default.a); // flip texture

    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].UNPACK_FLIP_Y_WEBGL, true);
  }

  attrib() {
    let planeData = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    30., -1.01, 30., 1.0, 0.0, -30., -1.01, 30., 0.0, 0.0, -30., -1.01, -30., 0.0, 1.0, 30., -1.01, 30., 1.0, 0.0, -30., -1.01, -30., 0.0, 1.0, 30., -1.01, -30., 1.0, 1.0];
    this.plane = new libs_Mesh__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]();
    this.plane.bufferData(planeData, ['position', 'texCoord'], [3, 2]);
    this.cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]();
    this.cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_11__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]();
    this.quad.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_11__["QuadData"], ['position', 'texCoord'], [3, 2]);
  }

  prepare() {
    // gl.getExtension("WEBGL_depth_texture")
    let lightView = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    let lightProjection = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    const nearPlane = .1;
    const farPlane = 18.5; // out, left, right, bottom, top, near, far

    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].ortho(lightProjection, -25, 25, -25, 25, nearPlane, farPlane);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].lookAt(lightView, lightPos, [0, 0, 0], [0, 1, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].multiply(this.tmpMatrix, lightProjection, lightView);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].LESS);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clearColor(0.3, 0.3, .3, 1.0);
    this.depthBuffer = depthTextureFbo(shadowWidth, shadowHeight);
    this.camera.radius = 11;
    this.wood = new libs_glTexture__WEBPACK_IMPORTED_MODULE_3___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"]).fromImage(getAssets.wood);
    this.wood.bind();
    this.wood.repeat();
  }

  uniform() {
    vMatrix = this.camera.viewMatrix;
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].viewport(0, 0, shadowWidth, shadowHeight);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].FRAMEBUFFER, this.depthBuffer.frameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.prg.use();
    this.prg.style({
      lightSpaceMatrix: this.tmpMatrix
    });

    this._renderScene(this.prg, ['position']);

    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].FRAMEBUFFER, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].viewport(0, 0, canvasWidth, canvasHeight);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_2D, this.depthBuffer.depthTexture); // for debug
    // this.depthQuadPrg.use()
    // this.depthQuadPrg.style({
    //   depthMap: 0
    // })
    // this.quad.bind(this.depthQuadPrg, ['position', 'texCoord'])
    // this.quad.draw(gl.TRIANGLE_STRIP)

    this.wood.bind(1);
    this.shadowPrg.use();
    this.shadowPrg.style({
      shadowMap: 0,
      diffuseTexture: 1,
      lightPos,
      viewPos: this.camera.position,
      mMatrix: this.mMatrix,
      pMatrix,
      vMatrix,
      lightSpaceMatrix: this.tmpMatrix
    });

    this._renderScene(this.shadowPrg);
  }

  _renderScene(shader, arg) {
    this.mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    shader.style({
      mMatrix: this.mMatrix
    });
    this.plane.bind(shader, arg);
    this.plane.draw();
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(this.mMatrix, this.mMatrix, [-1.2, 0, 5]);
    shader.style({
      mMatrix: this.mMatrix
    });
    this.cube.bind(shader, arg);
    this.cube.draw();
    this.mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(this.mMatrix, this.mMatrix, [2, 2, 4]);
    shader.style({
      mMatrix: this.mMatrix
    });
    this.cube.bind(shader, arg);
    this.cube.draw();
    this.mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(this.mMatrix, this.mMatrix, [-2.2, .4, 1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].rotate(this.mMatrix, this.mMatrix, toRadian(30), [2, 2, 4]);
    shader.style({
      mMatrix: this.mMatrix
    });
    this.cube.bind(shader, arg);
    this.cube.draw();
  }

}

function depthTextureFbo(width, height) {
  const frameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].createFramebuffer();
  const depthTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].createTexture();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_2D, depthTexture);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].DEPTH_COMPONENT16, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].DEPTH_COMPONENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].UNSIGNED_SHORT, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].NEAREST);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].NEAREST);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].REPEAT);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].REPEAT);
  const borderColor = [1.0, 1.0, 1.0, 1.0]; // gl.texParameterfv(gl.TEXTURE_2D, gl.TEXTURE_BORDER_COLOR, borderColor)

  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].FRAMEBUFFER, frameBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].DEPTH_ATTACHMENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].TEXTURE_2D, depthTexture, 0);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].drawBuffers([libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].NONE]);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].readBuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].NONE);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].FRAMEBUFFER, null);
  return {
    frameBuffer,
    depthTexture
  };
}
/*
  // 1. 首选渲染深度贴图
  glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);
  glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
  glClear(GL_DEPTH_BUFFER_BIT);
  ConfigureShaderAndMatrices();
  RenderScene();
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  // 2. 像往常一样渲染场景，但这次使用深度贴图
  glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  ConfigureShaderAndMatrices();
  glBindTexture(GL_TEXTURE_2D, depthMap);
  RenderScene();
*/module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\n\nuniform mat4 lightSpaceMatrix;\nuniform mat4 mMatrix;\n\nvoid main(void){\n    gl_Position = lightSpaceMatrix * mMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n\nvoid main(){\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D depthMap;\nuniform float near_plane;\nuniform float far_plane;\n\n// required when using a perspective projection matrix\nfloat LinearizeDepth(float depth)\n{\n    float z = depth * 2.0 - 1.0; // Back to NDC\n    return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));\n}\n\nvoid main()\n{\n    float depthValue = texture(depthMap, TexCoords).r;\n    // FragColor = vec4(vec3(LinearizeDepth(depthValue) / far_plane), 1.0); // perspective\n    FragColor = vec4(vec3(depthValue), 1.0); // orthographic\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\n\nout vec3 FragPos;\nout  vec3 Normal;\nout  vec2 TexCoords;\nout vec4 FragPosLightSpace;\n\n\nuniform mat4 pMatrix;\nuniform mat4 vMatrix;\nuniform mat4 mMatrix;\nuniform mat4 lightSpaceMatrix;\n\nvoid main(){\n  gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.);\n  FragPos = vec3(mMatrix * vec4(position, 1.));\n  Normal = transpose(inverse(mat3(mMatrix))) * normal;\n  TexCoords = texCoord;\n  FragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.); // 从lightPos视角看的坐标\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\nin vec4 FragPosLightSpace;\n\n\nuniform sampler2D diffuseTexture;\nuniform sampler2D shadowMap;\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nfloat ShadowCalculation(vec4 fragPosLightSpace, float bias){\n      // 执行透视除法\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n    // 变换到[0,1]的范围\n    projCoords = projCoords * 0.5 + 0.5;\n    // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)\n    float closestDepth = texture(shadowMap, projCoords.xy).r;\n    // 取得当前片元在光源视角下的深度\n    float currentDepth = projCoords.z;\n    // 检查当前片元是否在阴影中\n\n    float shadow = 0.0;\n    vec2 texelSize = vec2(1. / float(textureSize(shadowMap, 0).x));\n    for(int x = -1; x <= 1; ++x)\n    {\n        for(int y = -1; y <= 1; ++y)\n        {\n            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;\n            shadow += currentDepth - bias > pcfDepth ? .7 : 0.0;\n        }\n    }\n    shadow /= 9.0;\n\n    if(projCoords.z > 1.0) shadow = 0.0;\n\n    return shadow;\n}\n\nvoid main(){\n    vec3 color = texture(diffuseTexture, TexCoords).rgb;\n    vec3 normal = normalize(Normal);\n    vec3 lightColor = vec3(2.0);\n    // Ambient\n    vec3 ambient = 0.15 * color;\n    // Diffuse\n    vec3 lightDir = normalize(lightPos - FragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * lightColor;\n    // Specular\n    vec3 viewDir = normalize(viewPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = 0.0;\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);\n    vec3 specular = spec * lightColor;\n    // 计算阴影\n    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);\n    float shadow = ShadowCalculation(FragPosLightSpace, bias);\n    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;\n\n    FragColor = vec4(lighting, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Color; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_Geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);
/* harmony import */ var shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_color_colors_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/* harmony import */ var shaders_color_colors_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_color_colors_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_color_lamp_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(100);
/* harmony import */ var shaders_color_lamp_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_color_lamp_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);








const lightColor = [0.83, 0.82, 0.88];
class Color extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_color_colors_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
    this.lampPrg = this.compile(shaders_color_colors_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_color_lamp_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
  }

  attrib() {
    this.cube = libs_Geom__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].cube(.5);
    this.lamp = libs_Geom__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].sphere(.05, 60);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "c"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "c"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "c"].clearDepth(1.0);
    this.camera.radius = 3;
  }

  uniform() {
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "b"].create());
    this.prg.use();
    this.prg.style({
      mMatrix,
      vMatrix: this.camera.viewMatrix,
      pMatrix: this.camera.projMatrix,
      objectColor: [0.1, .1, .1],
      lightColor
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* GlTools */ "a"].draw(this.cube);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "b"].translate(mMatrix, mMatrix, [1, .1, 1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [.2, .2, .2]);
    this.lampPrg.use();
    this.lampPrg.style({
      mMatrix,
      vMatrix: this.camera.viewMatrix,
      pMatrix: this.camera.projMatrix,
      lightColor
    });
    libs_GlTools__WEBPACK_IMPORTED_MODULE_7__[/* GlTools */ "a"].draw(this.lamp);
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nuniform vec3 objectColor;\nuniform vec3 lightColor;\n\nvoid main()\n{\n    FragColor = vec4(lightColor * objectColor, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\nuniform vec3 lightColor;\nvoid main()\n{\n    FragColor = vec4(lightColor, 1.0); // 将向量的四个分量全部设置为1.0\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LightCaster; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_Geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);
/* harmony import */ var shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_light_caster_directionalLight_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(101);
/* harmony import */ var shaders_light_caster_directionalLight_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_directionalLight_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_light_caster_pointLight_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(102);
/* harmony import */ var shaders_light_caster_pointLight_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_pointLight_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_light_caster_spotLight_frag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(103);
/* harmony import */ var shaders_light_caster_spotLight_frag__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_spotLight_frag__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_light_caster_lamp_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(104);
/* harmony import */ var shaders_light_caster_lamp_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_lamp_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_light_caster_lamp_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(105);
/* harmony import */ var shaders_light_caster_lamp_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_light_caster_lamp_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(0);












let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
const lightColor = [0.33, 0.42, 0.18];
const ligthPos = [0.2, -1.0, -0.3].map(v => v * 50);
const cubePosition = [[0.0, 0.0, 0.0], [2.0, 5.0, -15.0], [-1.5, -2.2, -2.5], [-3.8, -2.0, -12.3], [2.4, -0.4, -3.5], [-1.7, 3.0, -7.5], [1.3, -2.0, -2.5], [1.5, 2.0, -2.5], [1.5, 0.2, -1.5], [-1.3, 1.0, -1.5]];
class LightCaster extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_light_caster_directionalLight_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
    this.pointPrg = this.compile(shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_light_caster_pointLight_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.spotPrg = this.compile(shaders_light_caster_directionalLight_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_light_caster_spotLight_frag__WEBPACK_IMPORTED_MODULE_6___default.a);
    this.lampPrg = this.compile(shaders_light_caster_lamp_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_light_caster_lamp_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
  }

  attrib() {
    this.cube = libs_Geom__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].cube(1);
    this.lamp = libs_Geom__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].s;
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].clearDepth(1.0);
    this.diffuseTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].RGBA).fromImage(getAssets.cubeDiffuse);
    this.specularTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].RGBA).fromImage(getAssets.cubeSpecular);
    this.emissionTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].RGBA).fromImage(getAssets.cubeEmission);
    this.camera.radius = 6;
  }

  _setGUI() {
    this.addGUIParams({
      directionalLight: true,
      pointLight: false,
      spotLight: false
    });
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'directionalLight').listen().onChange(() => {
      this.setChecked('directionalLight');
    });
    folder1.add(this.params, 'pointLight').listen().onChange(() => {
      this.setChecked('pointLight');
    });
    folder1.add(this.params, 'spotLight').listen().onChange(() => {
      this.setChecked('spotLight');
    });
    folder1.open();
  }

  setChecked(prop) {
    this.params.directionalLight = false;
    this.params.pointLight = false;
    this.params.spotLight = false;
    this.params[prop] = true;
  }

  uniform() {
    vMatrix = this.camera.viewMatrix;
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "d"])(60), libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* canvas */ "b"].clientHeight, .1, 100);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.diffuseTexture.bind(0);
    this.specularTexture.bind(1);
    this.emissionTexture.bind(2);

    if (this.params.directionalLight) {
      this.prg.use();
      this.cube.bind(this.prg);
      this.prg.style({
        vMatrix,
        pMatrix,
        camPos: this.camera.position,
        'material.shininess': 30,
        'material.diffuse': 0,
        'material.specular': 1,
        'material.emission': 2,
        'light.ambient': [.2, .2, .2],
        'light.diffuse': [.5, .5, .5],
        'light.specular': [1., 1., 1.],
        // specular 还和视角有关
        'light.direction': [-ligthPos[0], -ligthPos[1], -ligthPos[2]] //光源方向为从光源出发，因此是坐标向量取负

      });
      cubePosition.map((position, i) => {
        let cubemMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create(); // mat4.scale(cubemMatrix, cubemMatrix, [.5, .5, .5])

        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].rotate(cubemMatrix, cubemMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "d"])(20 * i), ligthPos);
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(cubemMatrix, cubemMatrix, position);
        this.prg.style({
          mMatrix: cubemMatrix
        });
        this.cube.draw();
      });
    } else if (this.params.pointLight) {
      this.pointPrg.use();
      this.cube.bind(this.pointPrg);
      this.pointPrg.style({
        vMatrix,
        pMatrix,
        camPos: this.camera.position,
        'material.shininess': 30,
        'material.diffuse': 0,
        'material.specular': 1,
        'material.emission': 2,
        'light.ambient': [.2, .2, .2],
        'light.diffuse': [.5, .5, .5],
        'light.specular': [1., 1., 1.],
        'light.position': [0, 0, 1],
        //衰减系数
        'light.constant': 1,
        'light.linear': .09,
        'light.quadratic': .032
      });
      cubePosition.map((position, i) => {
        let cubemMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].rotate(cubemMatrix, cubemMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "d"])(20 * i), ligthPos);
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(cubemMatrix, cubemMatrix, position);
        this.pointPrg.style({
          mMatrix: cubemMatrix
        });
        this.cube.draw();
      });
    } else if (this.params.spotLight) {
      this.spotPrg.use();
      this.cube.bind(this.spotPrg);
      this.spotPrg.style({
        vMatrix,
        pMatrix,
        camPos: this.camera.position,
        'material.shininess': 30,
        'material.diffuse': 0,
        'material.specular': 1,
        'material.emission': 2,
        'light.ambient': [.1, .1, .1],
        'light.diffuse': [.5, .5, .5],
        'light.specular': [1., 1., 1.],
        'light.position': this.camera.position,
        'light.direction': [-this.camera.position[0], -this.camera.position[1], -this.camera.position[2]],
        'light.cutOff': Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "d"])(12.5)
      });
      cubePosition.map((position, i) => {
        let cubemMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].rotate(cubemMatrix, cubemMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* toRadian */ "d"])(20 * i), ligthPos);
        gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(cubemMatrix, cubemMatrix, position);
        this.spotPrg.style({
          mMatrix: cubemMatrix
        });
        this.cube.draw();
      });
    }

    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [.05, .05, .05]); //先缩放再位移，防止先位移缩放改变了位移值

    gl_matrix__WEBPACK_IMPORTED_MODULE_10__[/* mat4 */ "b"].translate(mMatrix, mMatrix, ligthPos);
    this.lampPrg.use();
    this.lampPrg.style({
      mMatrix,
      vMatrix,
      pMatrix,
      lightColor
    });
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].bindVertexArray(this.lampVao);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].drawArrays(libs_GlTools__WEBPACK_IMPORTED_MODULE_11__[/* gl */ "c"].TRIANGLES, 0, 36);
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec2 TexCoords;\nout vec3 Normal;\nout vec3 FragPos;\n\nvoid main()\n{\n    FragPos = vec3(mMatrix * vec4(position, 1.0));\n    Normal = mat3(transpose(inverse(mMatrix))) * normal;\n    TexCoords = texCoord;\n\n    gl_Position = pMatrix * vMatrix * vec4(FragPos, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    sampler2D emission;\n    float shininess;\n};\nstruct Light {\n    // vec3 position; // directional light only has direction\n    vec3 direction;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\n\nvoid main()\n{\n  // ambient\n  vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\n\n  // diffuse\n  vec3 norm = normalize(Normal);\n  // vec3 lightDir = normalize(light.position - FragPos);\n  vec3 lightDir = normalize(-light.direction);\n  float diff = max(dot(norm, lightDir), 0.0);\n   vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\n\n  // specular\n  vec3 viewDir = normalize(camPos - FragPos);\n  vec3 reflectDir = reflect(-lightDir, norm);\n  float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n  vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\n\n  vec3 emission = vec3(0.);//texture(material.emission, TexCoords).rgb;\n\n  vec3 result = ambient + diffuse + specular + emission;\n  FragColor = vec4(result, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    float shininess;\n};\n\nstruct Light {\n    vec3 position;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\n    float constant;\n    float linear;\n    float quadratic;\n};\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\nvoid main()\n{\n    // ambient\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\n\n    // diffuse\n    vec3 norm = normalize(Normal);\n    vec3 lightDir = normalize(light.position - FragPos);\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\n\n    // specular\n    vec3 viewDir = normalize(camPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\n\n    // attenuation\n    float distance    = length(light.position - FragPos);\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n\n    ambient  *= attenuation;\n    diffuse   *= attenuation;\n    specular *= attenuation;\n\n    vec3 result = ambient + diffuse + specular;\n    FragColor = vec4(result, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    float shininess;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 direction;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\n    float cutOff;\n};\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\nvoid main()\n{\n  vec3 result;\n  vec3 lightDir = normalize(light.position - FragPos);\n  float theta = dot(lightDir, normalize(-light.direction));\n  if(theta > light.cutOff)\n  {\n    // ambient\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\n\n    // diffuse\n    vec3 norm = normalize(Normal);\n\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\n\n    // specular\n    vec3 viewDir = normalize(camPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\n\n    result = ambient + diffuse + specular;\n  }\n  else {\n    // 否则，使用环境光，让场景在聚光之外时不至于完全黑暗\n    result = light.ambient * vec3(texture(material.diffuse, TexCoords));\n  }\n\n  FragColor = vec4(result, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\n\nvoid main() {\n  FragColor = vec4(1.0);\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Color; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var shaders_material_material_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(106);
/* harmony import */ var shaders_material_material_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_material_material_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_material_material_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(107);
/* harmony import */ var shaders_material_material_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_material_material_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(31);
/* harmony import */ var shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30);
/* harmony import */ var shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var libs_Geom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(0);










const lightColor = [0.83, 0.82, 0.88];
const ligthPos = [1, 1.5, 1.5];
class Color extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_material_material_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_material_material_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
    this.lampPrg = this.compile(shaders_material_lamp_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_material_lamp_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
  }

  attrib() {
    this.cube = libs_Geom__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].cube(1);
    this.lamp = libs_Geom__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].sphere(.1, 60);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* gl */ "c"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* gl */ "c"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* gl */ "c"].clearDepth(1.0);
  }

  uniform() {
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create());
    this.prg.use();
    this.prg.style({
      mMatrix,
      vMatrix: this.camera.viewMatrix,
      pMatrix: this.camera.projMatrix,
      camPos: this.camera.position,
      'light.position': ligthPos,
      'material.ambient': [1, .5, .31],
      'material.diffuse': [.0, .0, .0],
      'material.specular': [1., 1., 1.],
      'material.shininess': 50,
      'light.ambient': [.1, .1, .1],
      'light.diffuse': [1., 1., 1.],
      'light.specular': [1., 1., 1.]
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* GlTools */ "a"].draw(this.cube);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].translate(mMatrix, mMatrix, ligthPos);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [.2, .2, .2]);
    this.lampPrg.use();
    this.lampPrg.style({
      mMatrix,
      vMatrix: this.camera.viewMatrix,
      pMatrix: this.camera.projMatrix,
      lightColor
    });
    libs_GlTools__WEBPACK_IMPORTED_MODULE_9__[/* GlTools */ "a"].draw(this.lamp);
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec3 Normal;\nout vec3 FragPos;\nvoid main()\n{\n  Normal = mat3(transpose(inverse(mMatrix))) * normal; // 法线矩阵 修复不等比缩放\n  FragPos = vec3(mMatrix * vec4(position, 1.0));\n  gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\nstruct Light {\n    vec3 position;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\nin vec3 FragPos;\nin vec3 Normal;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\n\nvoid main()\n{\n  // ambient\n  vec3 ambient = light.ambient * material.ambient;\n\n  // diffuse\n  vec3 norm = normalize(Normal);\n  vec3 lightDir = normalize(light.position - FragPos);\n  float diff = max(dot(norm, lightDir), 0.0);\n  vec3 diffuse = light.diffuse * (diff * material.diffuse);\n\n  // specular\n  vec3 viewDir = normalize(camPos - FragPos);\n  vec3 reflectDir = reflect(-lightDir, norm);\n  float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n  vec3 specular = light.specular * (spec * material.specular);\n\n  vec3 result = ambient + diffuse + specular;\n  FragColor = vec4(result, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Reflection; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var shaders_reflection_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(108);
/* harmony import */ var shaders_reflection_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(shaders_reflection_vert__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var shaders_reflection_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(109);
/* harmony import */ var shaders_reflection_frag__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_reflection_frag__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);






class Reflection extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    this.prg = this.compile(shaders_reflection_vert__WEBPACK_IMPORTED_MODULE_2___default.a, shaders_reflection_frag__WEBPACK_IMPORTED_MODULE_3___default.a);
  }

  attrib() {
    this.statue = getAssets.statue;
  }

  prepare() {
    this.camera.radius = 3.5;
  }

  _setGUI() {
    this.addGUIParams({
      color: [0, 0, 0]
    });
    this.gui.addColor(this.params, 'color');
  }

  uniform() {
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_4__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_4__[/* mat4 */ "b"].create());
    let invMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_4__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_4__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_4__[/* mat4 */ "b"].invert(invMatrix, mMatrix);
    this.prg.use();
    this.prg.style({
      uModelMatrix: mMatrix,
      invMatrix,
      color: [this.params.color[0] / 255, this.params.color[1] / 255, this.params.color[2] / 255],
      lightDirection: [-0.5, 0.5, 0.5],
      eyeDirection: this.camera.position,
      ambientColor: [0.1, 0.1, 0.1, 1.0]
    });
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_5__[/* gl */ "c"].clearColor(0.3, 0.3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_5__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_5__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_5__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_5__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.prg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_5__[/* GlTools */ "a"].draw(this.statue);
  }

}module.exports = "#version 300 es\n#define GLSLIFY 1\n// 漫射光diffuse不考虑视线\n// 通过取光和眼睛的半矢量和normal的内积来确定反射光的强度\nin vec3 position;\nin vec3 normal;\nuniform vec3 color;\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nout   vec3 vNormal;\nout   vec3 vColor;\n\nvoid main(void){\n    vNormal     = normal;\n    vColor      = color;\n    gl_Position = uProjectionMatrix* uViewMatrix * uModelMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform mat4 invMatrix;\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform vec4 ambientColor;\nin vec3 vNormal;\nin vec3 vColor;\nout vec4 FragColor;\n\nvoid main(void){\n    vec3  invLight  = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n    vec3  invEye    = normalize(invMatrix * vec4(eyeDirection, 0.0)).xyz;\n    vec3  halfLE    = normalize(invLight + invEye);\n    float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0);\n    float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0);\n    vec4  destColor = vec4(vColor, 1.) * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;\n    FragColor    = destColor;\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nout   vec2 TexCoords;\nout vec3 Pos;\nvoid main(void){\n    TexCoords = texCoord;\n    Pos = position;\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin   vec2 TexCoords;\nout vec4 outColor;\nuniform sampler2D texture;\nuniform float lod;\nvoid main(void){\n\n    outColor = textureLod(texture, TexCoords, lod);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin vec3 Pos;\nout vec4 outColor;\n\nvoid main()\n{\n  outColor = vec4(0.+Pos.x, 0.0, 0.0+Pos.z, .2);\n}"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mirror; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var shaders_mirror_simple_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var shaders_mirror_simple_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shaders_mirror_simple_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var shaders_mirror_simple_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(113);
/* harmony import */ var shaders_mirror_simple_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_mirror_simple_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_mirror_mirror_vert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(114);
/* harmony import */ var shaders_mirror_mirror_vert__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_mirror_mirror_vert__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_mirror_mirror_frag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(115);
/* harmony import */ var shaders_mirror_mirror_frag__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_mirror_mirror_frag__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1);
/* harmony import */ var libs_glFbo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26);
/* harmony import */ var libs_glFbo__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(libs_glFbo__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3);











class Mirror extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "ortMatrix", gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create()));
  }

  init() {
    this.prg = this.compile(shaders_mirror_simple_vert__WEBPACK_IMPORTED_MODULE_3___default.a, shaders_mirror_simple_frag__WEBPACK_IMPORTED_MODULE_4___default.a);
    this.mPrg = this.compile(shaders_mirror_mirror_vert__WEBPACK_IMPORTED_MODULE_5___default.a, shaders_mirror_mirror_frag__WEBPACK_IMPORTED_MODULE_6___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      color
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_7__["Torus"])(64, 64, 0.2, 0.7);
    let torus = new libs_Mesh__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]();
    torus.bufferVertex(pos);
    torus.bufferIndex(index);
    torus.bufferNormal(normal);
    torus.bufferColor(color);
    this.torus = torus;
    let position = [-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];
    color = [0.3, 0.5, 0.5, 1.0, 0.5, 0.5, 0.1, 1.0, 0.5, 0.5, 0.1, 1.0, 0.5, 0.5, 0.1, 1.0];
    let texCoord = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0];
    index = [0, 2, 1, 1, 2, 3];
    let plane = new libs_Mesh__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]();
    plane.bufferVertex(position);
    plane.bufferIndex(index);
    plane.bufferTexCoord(texCoord);
    plane.bufferColor(color);
    this.plane = plane;
  }

  prepare() {
    this.fbo = new libs_glFbo__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"]);
    this.fbo.resize(512, 512);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].CULL_FACE);
  }

  uniform() {
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create());
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create());
    let eyeDirection = [];
    let camUpDirection = [];
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* vec3 */ "e"].transformQuat(eyeDirection, [0.0, 5.0, 5.0], this.rotateQ);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* vec3 */ "e"].transformQuat(camUpDirection, [0.0, 1.0, -1.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].lookAt(vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].perspective(pMatrix, 45, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* canvas */ "b"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].multiply(this.tmpMatrix, pMatrix, vMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].lookAt(vMatrix, [0.0, 0.0, .1], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].ortho(pMatrix, -1.0, 1.0, -1.0, 1.0, 0.1, 1.);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].multiply(this.ortMatrix, pMatrix, vMatrix);
  }

  render() {
    this.fbo.bind();
    this.fbo.clear();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clearColor(0.3, 0.8, 0.4, 0.3);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].cullFace(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].FRONT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].rotate(mMatrix, mMatrix, 1 * 2 * Math.PI / 9, [0, 1, 0]);
    let invMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].invert(invMatrix, mMatrix);
    this.prg.use();
    this.prg.style({
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix,
      invMatrix,
      lightDirection: [0., -0.5, 0.577],
      eyeDirection: this.eyeDirection,
      ambientColor: [0., 0., 0., 0.0],
      mirror: true
    });
    this.torus.bind(this.prg);
    this.torus.draw();
    this.fbo.unbind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clearColor(0.0, 0.7, 0.7, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clearStencil(0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].DEPTH_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].STENCIL_BUFFER_BIT);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].cullFace(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].BACK); // this.torus.bind(this.prg)
    // this.torus.draw()

    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].STENCIL_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].stencilFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].ALWAYS, 1, ~0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].stencilOp(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].REPLACE); // 只有通过深度测试和模板测试时才替换为1

    mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(mMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].translate(mMatrix, mMatrix, [0.0, 1., 0.0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [1.7, 1.7, 1.7]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].rotate(mMatrix, mMatrix, Math.PI * 1.5, [1, 0, 0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].invert(invMatrix, mMatrix);
    this.prg.style({
      mMatrix: mMatrix,
      invMatrix
    });
    this.plane.bind(this.prg, ['position', 'color', 'normal']);
    this.plane.draw();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].stencilFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].EQUAL, 1, ~0); // 等于1才通过,不然正交投影会到整个屏幕

    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].stencilOp(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].KEEP, libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].KEEP);
    this.mPrg.use();
    this.fbo.bindColor(this.mPrg.texture(), 0);
    this.mPrg.style({
      alpha: .9,
      texture: 0,
      ortMatrix: this.ortMatrix
    });
    this.plane.bind(this.mPrg, ['position', 'texCoord']); // this.plane.draw(gl.LINE_STRIP)

    this.plane.draw();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].disable(libs_GlTools__WEBPACK_IMPORTED_MODULE_2__[/* gl */ "c"].STENCIL_TEST);
  }

}module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\nuniform   bool mirror;\nvarying   vec3 vNormal;\nvarying   vec4 vColor;\nuniform vec3 eyeDirection;\nvarying float dist;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tif(mirror){pos = vec4(pos.x, -pos.y, pos.zw);}\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = normal;\n  vColor      = color;\n  dist = distance(position.xyz, eyeDirection);\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform mat4 invMatrix;\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform vec4 ambientColor;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying float dist;\n\nvoid main(void){\n    vec3  invLight  = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n    vec3  invEye    = normalize(invMatrix * vec4(eyeDirection, 0.0)).xyz;\n    vec3  halfLE    = normalize(invLight + invEye);\n    float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0);\n    float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0); // 50.0来模仿粗糙度\n    vec4  destColor = vColor * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;\n    // float gamma = 2.2; // 我们本身用的已经是数字颜色，而不是看到的颜色，所以不需要gamma校正\n    // destColor.rgb = pow(destColor.rgb, vec3(1.0/gamma));\n    gl_FragColor    = destColor;\n    // gl_FragColor = vec4(700.,0.3,1.,1.);\n}\n"module.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nuniform   mat4 ortMatrix;\nvarying   vec2 vTexCoord;\n\nvoid main(void){\n    vTexCoord   = texCoord;\n    gl_Position = ortMatrix * vec4(position, 1.0);\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\nuniform float     alpha;\nvarying vec2      vTexCoord;\n\nvoid main(void){\n    vec2 tc      = vec2(vTexCoord.s, 1. - vTexCoord.t);\n    gl_FragColor = vec4(texture2D(texture, tc).rgb, alpha);\n    // gl_FragColor = vec4(vec3(vTexCoord.t),1.);\n}\n"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return IndexBuffer; });
var BufferUtils = {
  getComponentSize: function (type) {
    switch (type) {
      case 0x1400: // gl.BYTE:

      case 0x1401:
        // gl.UNSIGNED_BYTE:
        return 1;

      case 0x1402: // gl.SHORT:

      case 0x1403:
        // gl.UNSIGNED_SHORT:
        return 2;

      case 0x1404: // gl.INT:

      case 0x1405: // gl.UNSIGNED_INT:

      case 0x1406:
        // gl.FLOAT:
        return 4;

      default:
        return 0;
    }
  },
  Drawable: function (proto) {
    proto.drawPoints = function (count, offset) {
      this.draw(0
      /* POINTS         */
      , count, offset);
    };

    proto.drawLines = function (count, offset) {
      this.draw(1
      /* LINES          */
      , count, offset);
    };

    proto.drawLineLoop = function (count, offset) {
      this.draw(2
      /* LINE_LOOP      */
      , count, offset);
    };

    proto.drawLineStrip = function (count, offset) {
      this.draw(3
      /* LINE_STRIP     */
      , count, offset);
    };

    proto.drawTriangles = function (count, offset) {
      this.draw(4
      /* TRIANGLES      */
      , count, offset);
    };

    proto.drawTriangleStrip = function (count, offset) {
      this.draw(5
      /* TRIANGLE_STRIP */
      , count, offset);
    };

    proto.drawTriangleFan = function (count, offset) {
      this.draw(6
      /* TRIANGLE_FAN   */
      , count, offset);
    };
  }
  /*
   * GL_ARRAY_BUFFER */

};
var TGT = 0x8892;
/**
 * @class
 * @implements {Drawable}
 * @param {WebGLRenderingContext} gl      then webgl context this ArrayBuffer belongs to
 * @param {TypedArray|uint} [data]   optional data to copy to buffer, or the size (in bytes)
 * @param {GLenum} [usage=GL_STATIC_DRAW] the usage hint for this buffer.
 *
 */

function ArrayBuffer(gl, data, usage) {
  this.gl = gl;
  this.usage = usage || gl.STATIC_DRAW;
  this.buffer = gl.createBuffer();
  this.attribs = [];
  this.stride = 0;
  this.byteLength = 0;
  this.length = 0;

  if (data) {
    this.data(data);
  }
}

ArrayBuffer.prototype = {
  /**
   * Bind the underlying webgl buffer.
   */
  bind: function () {
    this.gl.bindBuffer(TGT, this.buffer);
  },

  /**
   * Add attribute declaration for this buffer. Once attributes declared, the buffer can be linked to
   * programs attributes using {@link ArrayBuffer#attribPointer}
   *  @param {string} name the name of the program's attribute
   *  @param {uint} size the size of the attribute (3 for a vec3)
   *  @param {GLenum} type the type of data (GL_FLOAT, GL_SHORT etc)
   *  @param {boolean} [normalize=false] indicate if the data must be normalized
   */
  attrib: function (name, size, type, normalize) {
    this.attribs.push({
      name: name,
      type: 0 | type,
      size: 0 | size,
      normalize: !!normalize,
      offset: this.stride
    }); // use only one buffer for multiple attributes

    this.stride += BufferUtils.getComponentSize(type) * size;

    this._computeLength();

    return this;
  },

  /**
   * Fill webgl buffer with the given data. You can also pass a uint  to allocate the buffer to the given size.
   *   @param {TypedArray|uint} array the data to send to the buffer, or a size.
   */
  data: function (array) {
    var gl = this.gl;
    gl.bindBuffer(TGT, this.buffer);
    gl.bufferData(TGT, array, this.usage);
    gl.bindBuffer(TGT, null);
    this.byteLength = array.byteLength === undefined ? array : array.byteLength;

    this._computeLength();
  },

  /**
   * Set a part of the buffer with the given data, starting a offset (in bytes)
   *  @param {typedArray} array the data to send to buffer
   *  @param {uint} offset the offset in byte where the data will be written
   */
  subData: function (array, offset) {
    var gl = this.gl;
    gl.bindBuffer(TGT, this.buffer);
    gl.bufferSubData(TGT, offset, array);
    gl.bindBuffer(TGT, null);
  },

  /**
   * Link given program attributes to this buffer. You should first declare attributes using {@link ArrayBuffer#attrib}
   * before calling this method.
   *   @param {Program} program the nanogl Program
   */
  attribPointer: function (program, list) {
    var gl = this.gl;
    gl.bindBuffer(TGT, this.buffer);

    if (list && list.length) {
      for (let i = 0; i < list.length; i++) {
        for (var j = 0; j < this.attribs.length; j++) {
          let attrib = this.attribs[j];

          if (list[i] === attrib.name) {
            if (program[attrib.name] !== undefined) {
              let aLocation = program[attrib.name]();
              gl.enableVertexAttribArray(aLocation);
              gl.vertexAttribPointer(aLocation, attrib.size, attrib.type, attrib.normalize, this.stride, attrib.offset);
            } else {
              console.warn(`glBuffer can't get Attribute "${attrib.name}" Location.`);
            }
          }
        }
      }

      return;
    }

    for (var i = 0; i < this.attribs.length; i++) {
      var attrib = this.attribs[i];

      if (program[attrib.name] !== undefined) {
        var aLocation = program[attrib.name]();
        gl.enableVertexAttribArray(aLocation);
        gl.vertexAttribPointer(aLocation, attrib.size, attrib.type, attrib.normalize, this.stride, attrib.offset);
      } else {
        console.warn(`glBuffer can't get Attribute "${attrib.name}" Location.`);
      }
    }
  },

  /**
   * Shortcut to gl.drawArrays
   *   @param {GLenum} mode the type of primitive to draw (GL_TRIANGLE, GL_POINTS etc)
   *   @param {uint} [count] the number of vertices to draw (full buffer is used if omited)
   *   @param {uint} [offset=0] the position of the first vertex to draw
   */
  draw: function (mode, count, offset) {
    count = count === undefined ? this.length : count;
    this.gl.drawArrays(mode, offset, 0 | count);
  },

  /**
   * Delete underlying webgl objects
   */
  dispose: function () {
    this.gl && this.gl.deleteBuffer(this.buffer);
    this.buffer = null;
    this.gl = null;
  },
  _computeLength: function () {
    if (this.stride > 0) {
      this.length = this.byteLength / this.stride;
    }
  }
  /*
   * Implement Drawable
   */

};
BufferUtils.Drawable(ArrayBuffer.prototype);
/* GL_ELEMENT_ARRAY_BUFFER 34963 */

var ELEMENT_ARRAY_BUFFER = 0x8893;
/**
 * @class
 * @implements {Drawable}
 * @param {WebGLRenderingContext} gl      then webgl context this ArrayBuffer belongs to
 * @param {GLenum} [type=GL_UNSIGNED_SHORT]  the inetger type of the indices (GL_UNSIGNED_BYTE, GL_UNSIGNED_INT etc)
 * @param {TypedArray|uint} [data]   optional data to copy to buffer, or the size (in bytes)
 * @param {GLenum} [usage=GL_STATIC_DRAW] the usage hint for this buffer.
 *
 */

function IndexBuffer(gl, type, data, usage) {
  this.gl = gl;
  this.buffer = gl.createBuffer();
  this.usage = usage || gl.STATIC_DRAW;
  this.type = 0;
  this.typeSize = 0;
  this.size = 0;
  this.setType(type || gl.UNSIGNED_SHORT);

  if (data) {
    this.data(data);
  }
}

IndexBuffer.prototype = {
  /**
   * Bind the underlying webgl buffer.
   */
  bind: function () {
    this.gl.bindBuffer(ELEMENT_ARRAY_BUFFER, this.buffer);
  },

  /**
   *  Change the type of internal type of the IndexBuffer
   *  @param {GLenum} type  the integer type of the indices (GL_UNSIGNED_BYTE, GL_UNSIGNED_INT etc)
   */
  setType: function (type) {
    this.type = type;
    this.typeSize = BufferUtils.getComponentSize(type);
  },

  /**
   * Fill webgl buffer with the given data. You can also pass a uint  to allocate the buffer to the given size.
   *   @param {TypedArray|uint} array the data to send to the buffer, or a size.
   */
  data: function (array) {
    var gl = this.gl;
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, this.buffer);
    gl.bufferData(ELEMENT_ARRAY_BUFFER, array, this.usage);
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, null);
    this.size = array.byteLength === undefined ? array : array.byteLength;
  },

  /**
   * Set a part of the buffer with the given data, starting a offset (in bytes)
   *  @param {typedArray} array the data to send to buffer
   *  @param {uint} offset the offset in byte where the data will be written
   */
  subData: function (array, offset) {
    var gl = this.gl;
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, this.buffer);
    gl.bufferSubData(ELEMENT_ARRAY_BUFFER, offset, array);
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, null);
  },

  /**
   * Delete underlying webgl objects
   */
  dispose: function () {
    this.gl.deleteBuffer(this.buffer);
    this.buffer = null;
    this.gl = null;
  },

  /**
   * Shortcut to gl.drawArrays
   *   @param {GLenum} mode the type of primitive to draw (GL_TRIANGLE, GL_POINTS etc)
   *   @param {uint} [count] the number of indices to draw (full buffer is used if omited)
   *   @param {uint} [offset=0] the position of the first index to draw
   */
  draw: function (mode, count, offset) {
    count = count === undefined ? this.size / this.typeSize : count;
    this.gl.drawElements(mode, count, this.type, 0 | offset);
  }
  /*
   * Implement Drawable
   */

};
BufferUtils.Drawable(IndexBuffer.prototype);
function shimGL(gl, ext) {
  gl.bindVertexArray = function () {
    return ext.bindVertexArrayOES.apply(ext, arguments);
  };

  gl.createVertexArray = function () {
    return ext.createVertexArrayOES.apply(ext, arguments);
  };

  gl.deleteVertexArray = function () {
    return ext.deleteVertexArrayOES.apply(ext, arguments);
  };

  gl.isVertexArray = function () {
    return ext.isVertexArrayOES.apply(ext, arguments);
  };
}
/**
 * @class
 * @classdesc Vao manage attributes pointers setup for given arraybuffer and program
 * It provide a transparent fallback if extension isn't available
 *
 *  @param {WebGLRenderingContext} gl webgl context the vao belongs to
 */


function Vao(gl) {
  this.gl = gl;

  if (gl.bindVertexArray !== undefined) {
    this._impl = new NativeVao(this);
  } else {
    var ext = gl.getExtension('OES_vertex_array_object');

    if (ext) {
      shimGL(gl, ext);
      this._impl = new NativeVao(this);
    } else {
      this._impl = new EmulateVao(this);
    }
  }
}

Vao.prototype = {
  /**
    * release the internal webgl vao
    */
  dispose: function () {
    this._impl.dispose();

    this._impl = null;
  },

  /**
   * Initialize attrib pointer setup for given program and arraybuffers
   *   @param {Program} prg the nanogl Program
   *   @param {ArrayBuffer[]} buffers an array of ArrayBuffers containing the attributes
   */
  setup: function (prg, buffers, indices) {
    if (!prg.ready) {
      prg._grabParameters();
    }

    this._impl.setup(prg, buffers, indices);
  },

  /**
   * Bind the VAO. Call this method before each draw call
   */
  bind: function () {
    this._impl.bind();
  },

  /**
   * Unbind the VAO. Call this method after each draw call
   */
  unbind: function () {
    this._impl.unbind();
  }
}; // ---------------------------
//   Native Implementation Webgl1 extension or Webgl2 native
// ---------------------------

function NativeVao(vao) {
  this._vao = vao;
  this._handle = null;
}

NativeVao.prototype = {
  dispose: function () {
    this.release();
    this._vao = null;
  },
  setup: function (prg, buffers, indices) {
    this.release();
    var gl = this._vao.gl;
    this._handle = gl.createVertexArray();
    gl.bindVertexArray(this._handle);

    for (var i = 0; i < buffers.length; i++) {
      buffers[i].attribPointer(prg);
    }

    if (indices !== undefined) {
      indices.bind();
    }

    gl.bindVertexArray(null);
  },
  bind: function () {
    this._vao.gl.bindVertexArray(this._handle);
  },
  unbind: function () {
    this._vao.gl.bindVertexArray(null);
  },
  release: function () {
    if (this._handle) {
      this._vao.gl.deleteVertexArray(this._handle);

      this._handle = null;
    }
  }
}; // ---------------------------
//   Emulation Implementation
// ---------------------------

function EmulateVao(vao) {
  this._vao = vao;
}

EmulateVao.prototype = {
  dispose: function () {
    this._vao = null;
    this.prg = null;
    this.buffers = null;
    this.indices = null;
  },
  setup: function (prg, buffers, indices) {
    this.prg = prg;
    this.buffers = buffers;
    this.indices = indices;
  },
  bind: function () {
    for (var i = 0; i < this.buffers.length; i++) {
      this.buffers[i].attribPointer(this.prg);
    }

    if (this.indices !== undefined) {
      this.indices.bind();
    }
  },
  unbind: function () {// noop
  }
};
module.exports = Vao;__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mrt; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_mrt_mrt_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(116);
/* harmony import */ var shaders_mrt_mrt_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_mrt_mrt_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_mrt_mrt_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(117);
/* harmony import */ var shaders_mrt_mrt_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_mrt_mrt_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_mrt_simple_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(118);
/* harmony import */ var shaders_mrt_simple_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_mrt_simple_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_mrt_simple_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(119);
/* harmony import */ var shaders_mrt_simple_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_mrt_simple_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(15);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(libs_vao__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6);











let mrtStatus = {
  color_attachments: 0,
  draw_buffers: 0
};
let ext;
let frameBuffer;
class Mrt extends _PipeLine__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "count", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, "offset", [[-0.5, -0.5, 0.0], [-0.5, 0.5, 0.0], [0.5, -0.5, 0.0], [0.5, 0.5, 0.0]]);
  }

  init() {
    ext = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension('WEBGL_draw_buffers');

    if (!ext) {
      alert('WEBGL_draw_buffers not supported');
      return;
    } else {
      mrtStatus.color_attachments = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL);
      mrtStatus.draw_buffers = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getParameter(ext.MAX_DRAW_BUFFERS_WEBGL);
      console.log('MAX_COLOR_ATTACHMENTS_WEBGL: ' + mrtStatus.color_attachments);
      console.log('MAX_DRAW_BUFFERS_WEBGL: ' + mrtStatus.draw_buffers);
    }

    this.mrtPrg = this.compile(shaders_mrt_mrt_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_mrt_mrt_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.prg = this.compile(shaders_mrt_simple_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_mrt_simple_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      color
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_10__["Torus"])(64, 64, 1.0, 3.0, [1.0, 1.0, 1.0, 1.0]);
    const tPosBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], new Float32Array(pos));
    const tNormalBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], new Float32Array(normal));
    const tColorBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], new Float32Array(color));
    this.indexBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* IndexBuffer */ "b"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].UNSIGNED_SHORT, new Uint16Array(index), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].STATIC_DRAW);
    tPosBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT);
    tNormalBuffer.attrib('normal', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT);
    tColorBuffer.attrib('color', 4, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT);
    this.torusVao = new libs_vao__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]);
    this.torusVao.setup(this.mrtPrg, [tPosBuffer, tNormalBuffer, tColorBuffer]);
    let vPos = [-0.5, 0.5, 0.0, 0.5, 0.5, 0.0, -0.5, -0.5, 0.0, 0.5, -0.5, 0.0];
    let vTexCoord = [0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0];
    let vIndex = [0, 2, 1, 2, 3, 1];
    const vPosBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], new Float32Array(vPos));
    const vTexBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], new Float32Array(vTexCoord));
    this.vIndexBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_2__[/* IndexBuffer */ "b"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].UNSIGNED_SHORT, new Uint16Array(vIndex), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].STATIC_DRAW);
    vPosBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT);
    vTexBuffer.attrib('texCoord', 2, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT);
    this.mainVao = new libs_vao__WEBPACK_IMPORTED_MODULE_9___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]);
    this.mainVao.setup(this.prg, [vPosBuffer, vTexBuffer]);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CULL_FACE); //double side

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearColor(.3, .3, .3, 1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearDepth(1.0);
    frameBuffer = createFramebufferMRT(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height); //full canvas size

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, frameBuffer.t[0]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE1);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, frameBuffer.t[1]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE2);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, frameBuffer.t[2]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE3);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, frameBuffer.t[3]); //z值为pespecte之后的z，camera从上往下看，z相同，所以depth里圆圈颜色相同，转动后，透视z值改变，颜色改变

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, frameBuffer.f);
    const bufferList = [ext.COLOR_ATTACHMENT0_WEBGL, ext.COLOR_ATTACHMENT1_WEBGL, ext.COLOR_ATTACHMENT2_WEBGL, ext.COLOR_ATTACHMENT3_WEBGL];
    ext.drawBuffersWEBGL(bufferList); // 指定渲染目标

    this.camera.radius = 28;
  }

  uniform() {
    let vMatrix = this.camera.viewMatrix;
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create();
    this.mvpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create();
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].multiply(this.tmpMatrix, pMatrix, vMatrix);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, frameBuffer.f);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    const lightDirection = [-0.577, 0.577, 0.577];
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create();
    let invMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].create();
    this.count++;
    let rad = this.count % 360 * Math.PI / 180;
    this.mrtPrg.use();
    this.torusVao.bind();
    this.indexBuffer.bind();

    for (let i = 0; i < 9; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].identity(mMatrix); //绕y轴旋转，改变model坐标系方向，便于后续移动错开

      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].rotate(mMatrix, mMatrix, i * 2 * Math.PI / 9, [0, 1, 0]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].translate(mMatrix, mMatrix, [0.0, 0.0, 15.0]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].rotate(mMatrix, mMatrix, rad, [1, 1, 0]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_8__[/* mat4 */ "b"].invert(invMatrix, mMatrix);
      let ambient = Object(_Torus__WEBPACK_IMPORTED_MODULE_10__["hsva"])(i * 40, 1.0, 1.0, 1.0); //hue 0-360为各常见色彩

      this.mrtPrg.style({
        lightDirection,
        mvpMatrix: this.mvpMatrix,
        ambient,
        invMatrix
      });
      this.indexBuffer.drawTriangles();
    }

    this.torusVao.unbind();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.prg.use();
    this.mainVao.bind();
    this.vIndexBuffer.bind();

    for (let i = 0; i < 4; ++i) {
      this.prg.style({
        offset: this.offset[i],
        texture: i
      });
      this.vIndexBuffer.drawTriangles();
    }

    this.mainVao.unbind();
  }

} //链接纹理到framebuffer

function createFramebufferMRT(width, height) {
  let frameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createFramebuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, frameBuffer);
  let fTexture = [];

  for (let i = 0; i < 4; ++i) {
    fTexture[i] = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, fTexture[i]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, width, height, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].UNSIGNED_BYTE, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL + i, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, fTexture[i], 0);
  }

  let depthRenderBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createRenderbuffer();
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, depthRenderBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].renderbufferStorage(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_COMPONENT16, width, height);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_ATTACHMENT, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, depthRenderBuffer);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindRenderbuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RENDERBUFFER, null);
  libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null);
  return {
    f: frameBuffer,
    d: depthRenderBuffer,
    t: fTexture
  };
}module.exports = "#define GLSLIFY 1\nattribute vec3  position;\nattribute vec3  normal;\nattribute vec4  color;\nuniform   mat4  mvpMatrix;\nuniform   mat4  invMatrix;\nuniform   vec3  lightDirection;\nuniform   vec4  ambient;\nvarying   vec4  vDest;\nvarying   vec4  vColor;\nvarying   vec3  vNormal;\nvarying   float vDepth;\n\nvoid main(){\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n    vec3 invLight = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n    float diff = clamp(dot(normal, invLight), 0.1, 1.0);\n    vDest = vec4(color.rgb * ambient.rgb * diff, 1.0);\n    vColor = color * ambient;\n    vNormal = normal;\n    vDepth = gl_Position.z / gl_Position.w;\n}\n"module.exports = "#extension GL_EXT_draw_buffers: require\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec4  vDest;\nvarying vec4  vColor;\nvarying vec3  vNormal;\nvarying float vDepth;\n\nfloat near = 0.1;\nfloat far  = 100.0;\n\n// https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/\n// http://www.songho.ca/opengl/gl_projectionmatrix.html\nfloat LinearizeDepth(float depth)\n{\n    float z = depth * 2.0 - 1.0; // back to NDC\n    return (2.0 * near * far) / (far + near - z * (far - near));\n}\n\nvoid main(){\n    gl_FragData[0] = vDest;\n    gl_FragData[1] = vColor;\n    gl_FragData[2] = vec4((vNormal + 1.0) / 2.0, 1.0);\n    float depth = (LinearizeDepth(gl_FragCoord.z) -near) /(far-near);\n    gl_FragData[3] = vec4(vec3(depth), 1.);\n\n    // gl_FragColor = vec4(.3,.3,.3,1.);\n}\n"module.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nuniform vec3 offset;\nvarying vec2 vTexCoord;\n\nvoid main(){\n\tvTexCoord = texCoord;\n\tgl_Position = vec4(position + offset, 1.0);\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\nvarying vec2 vTexCoord;\n\nvoid main(){\n\tgl_FragColor = texture2D(texture, vTexCoord);\n  // gl_FragColor = vec4(.3, .0, .3, 1.);\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying   vec3 vNormal;\nvarying vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 kS = fresnelSchlick(max(dot(N, V), 0.0), F0);\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n    vec3 irradiance = textureCube(irradianceMap, N).rgb;\n    vec3 diffuse      = irradiance * albedo;\n    vec3 ambient = (kD * diffuse) * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"module.exports = "#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\n#define GLSLIFY 1\n// material map\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture2D(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture2D(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture2D(metallicMap, TexCoords).r;\n    float roughness = texture2D(roughnessMap, TexCoords).r;\n    float ao        = texture2D(aoMap, TexCoords).r;\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"module.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 WorldPos;\nvarying vec2 vUv;\nvoid main(void){\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  WorldPos = pos.xyz;\n  vUv = texCoord;\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D equirectangularMap;\nvarying vec3 WorldPos;\nvarying vec2 vUv;\n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec2 SampleSphericalMap(vec3 v)\n{\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y)); // [-PI/2,PI/2]\n    uv *= invAtan; //[-.5,.5]\n    uv += 0.5;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = SampleSphericalMap(normalize(WorldPos));\n    vec3 color = texture2D(equirectangularMap, uv).rgb;\n\n    gl_FragColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(WorldPos,1.);\n}\n"module.exports = "#define GLSLIFY 1\nattribute vec3 position;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 WorldPos;\n\nvoid main()\n{\n\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tvec4 clipPos    = vpMatrix * pos;\n\tgl_Position = clipPos.xyww; // 设置深度测试的z为1，这样只会在没有遮挡时渲染skybox，节省性能\n\n  WorldPos = pos.xyz;\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform samplerCube environmentMap;\nvarying vec3 WorldPos;\n\nvoid main()\n{\n    vec3 envColor = textureCube(environmentMap, WorldPos).rgb;\n\n    // HDR tonemap and gamma correct\n    envColor = envColor / (envColor + vec3(1.0));\n    envColor = pow(envColor, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(envColor, 1.0);\n}\n"module.exports = "precision mediump float;\n#define GLSLIFY 1\nvarying vec3 WorldPos;\n\nuniform samplerCube environmentMap;\n\nconst float PI = 3.14159265359;\n\nvoid main()\n{\n\t// The world vector acts as the normal of a tangent surface\n    // from the origin, aligned to WorldPos. Given this normal, calculate all\n    // incoming radiance of the environment. The result of this radiance\n    // is the radiance of light coming from -Normal direction, which is what\n    // we use in the PBR shader to sample irradiance.\n    vec3 N = normalize(WorldPos);\n\n    vec3 irradiance = vec3(0.0);\n\n    // tangent space calculation from origin point\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up            = cross(N, right);\n\n    const float sampleDelta = 0.025;\n    float nrSamples = 0.0;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\n\n            irradiance += textureCube(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n    gl_FragColor = vec4(irradiance, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Pbr; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_pbr_pbr_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(126);
/* harmony import */ var shaders_pbr_pbr_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_pbr_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_pbr_pbr_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(127);
/* harmony import */ var shaders_pbr_pbr_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_pbr_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_pbr_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(32);
/* harmony import */ var shaders_pbr_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_pbr_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(33);
/* harmony import */ var shaders_pbr_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_11__);












const nrRows = 7;
const nrColumns = 7;
const spacing = .8;
class Pbr extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension('OES_standard_derivatives');
    this.prg = this.compile(shaders_pbr_pbr_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_pbr_pbr_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.mapPrg = this.compile(shaders_pbr_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_pbr_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      uv
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_8__["Sphere"])(256, 256, .25);
    let sphere = new libs_Mesh__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]();
    sphere.bufferVertex(pos);
    sphere.bufferIndex(index);
    sphere.bufferNormal(normal);
    sphere.bufferTexCoord(uv);
    this.sphere = sphere;
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LEQUAL);
  }

  uniform() {
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].create());
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].create());
    let eyeDirection = [];
    let camUpDirection = [];
    if (this.params.map === 'none') gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* vec3 */ "e"].transformQuat(eyeDirection, [0.0, 0.0, 5.0], this.rotateQ);else gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* vec3 */ "e"].transformQuat(eyeDirection, [0.0, 0.0, 1.0], this.rotateQ);
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* vec3 */ "e"].transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].lookAt(vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].multiply(this.tmpMatrix, pMatrix, vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_11___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearColor(0.3, 0.3, 0.3, 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.eyeDirection,
      lambertDiffuse: this.params.lambertDiffuse
    };

    if (this.params.map === 'none') {
      this.prg.use();
      this.prg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        albedo: [.5, .0, .0],
        ao: 1.
      }));
      this.sphere.bind(this.prg, ['position', 'normal']);

      for (let row = 0; row < nrRows; row++) {
        this.prg.style({
          metallic: row / nrRows
        });

        for (let col = 0; col < nrColumns; col++) {
          gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].translate(mMatrix, gl_matrix__WEBPACK_IMPORTED_MODULE_9__[/* mat4 */ "b"].create(), [(col - nrColumns / 2) * spacing, (row - nrRows / 2) * spacing, 0.0]); // mat4.translate(mMatrix, mMatrix, [1, 0, 0])

          this.prg.style({
            roughness: clamp(col / nrColumns, 0.05, 1.),
            mMatrix
          });
          this.sphere.draw();
        }
      }
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      this.mapPrg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        mMatrix: mMatrix,
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4
      }));
      this.sphere.bind(this.mapPrg);
      this.sphere.draw();
    }
  }

}

function clamp(value, min, max) {
  if (min > max) {
    return clamp(value, max, min);
  }

  if (value < min) return min;else if (value > max) return max;else return value;
}module.exports = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying   vec3 vNormal;\nvarying vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PbrFlow; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_pbr_flow_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(128);
/* harmony import */ var shaders_pbr_flow_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_flow_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_pbr_flow_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(129);
/* harmony import */ var shaders_pbr_flow_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_flow_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_pbr_flow_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(130);
/* harmony import */ var shaders_pbr_flow_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_flow_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_pbr_flow_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(131);
/* harmony import */ var shaders_pbr_flow_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_flow_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(16);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(21);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(22);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(24);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(25);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(11);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(15);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(libs_vao__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(9);
/* harmony import */ var libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(12);






















const nrRows = 7;
const nrColumns = 7;
const spacing = .42;
/* irradianceMap, prefilterMap 用cmftStudio生成

*/

class PbrFlow extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension('OES_texture_float_linear'); // Even WebGL2 requires OES_texture_float_linear

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension("EXT_color_buffer_float"); // // gl.getExtension('OES_texture_half_float')
    // gl.getExtension('OES_texture_half_float_linear')
    // gl.getExtension('EXT_shader_texture_lod')

    this.prg = this.compile(shaders_pbr_flow_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_pbr_flow_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.mapPrg = this.compile(shaders_pbr_flow_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_pbr_flow_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.cubePrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
    this.skyboxPrg = this.compile(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default.a, shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default.a);
    this.brdfPrg = this.compile(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12___default.a, shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      uv
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_16__["Sphere"])(256, 256, .15);
    let sphere = new libs_Mesh__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"]();
    sphere.bufferVertex(pos);
    sphere.bufferIndex(index);
    sphere.bufferNormal(normal);
    sphere.bufferTexCoord(uv);
    this.sphere = sphere;
    let cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"]();
    cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_16__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.cube = cube;
    let planeVertices = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, 3.0, 0.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, -3.0, 1.0, 1.0];
    this.planeBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_14__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], new Float32Array(planeVertices));
    this.planeBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT);
    this.planeBuffer.attrib('texCoord', 2, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT);
    this.planeVao = new libs_vao__WEBPACK_IMPORTED_MODULE_15___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]);
    this.planeVao.setup(this.cubePrg, [this.planeBuffer]);
    let quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"]();
    let quadData = [-1.0, 1.0, 0.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 0.0, 1.0, 0.0];
    quad.bufferData(quadData, ['position', 'texCoord'], [3, 2]);
    this.quad = quad;
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].UNPACK_FLIP_Y_WEBGL, true);
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create());
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create());
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create());
    let vpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(90), 1., .1, 100);
    const CAMERA_SETTINGS = [[gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(-1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, 1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, -1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, -1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, 1), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, 0, -1), gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].fromValues(0, -1, 0)]];
    let hdrInfo = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.equirectangular);
    console.log('hdrInfo', hdrInfo);
    this.hdrTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.hdrTexture.id);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA32F, hdrInfo.shape[0], hdrInfo.shape[1], 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT, hdrInfo.data);
    this.hdrTexture.clamp(); // cubemap

    let cubemapTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, cubemapTexture);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA32F, 512, 512, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR_MIPMAP_LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    this.cubemapTexture = cubemapTexture;
    this.cubePrg.use();
    this.hdrTexture.bind(0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, 512, 512);
    let captureFrameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createFramebuffer();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, captureFrameBuffer);

    for (let i = 0; i < 6; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].multiply(vpMatrix, pMatrix, vMatrix);
      this.cubePrg.style({
        equirectangularMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.cubemapTexture, 0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
      this.cube.bind(this.cubePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER);

    if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER_COMPLETE) {
      console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null); //brdf lookup texture

    this.brdfLUTTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RG).fromData(512, 512, null, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RG32F);
    this.brdfLUTTexture.bind();
    this.brdfLUTTexture.clamp();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, captureFrameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.brdfLUTTexture.id, 0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, 512, 512);
    this.brdfPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.quad.bind(this.brdfPrg);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TRIANGLE_STRIP);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null);
    let irr_posx = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradiancePosX);
    let irr_negx = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradianceNegX);
    let irr_posy = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradiancePosY);
    let irr_negy = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradianceNegY);
    let irr_posz = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradiancePosZ);
    let irr_negz = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(getAssets.irradianceNegZ);
    this.irradianceMap = new libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"]([irr_posx, irr_negx, irr_posy, irr_negy, irr_posz, irr_negz]);
    this.prefilterMap = libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"].parseDDS(getAssets.radiance);
  }

  uniform() {
    this.vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create());
    this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create();
    let eyeDirection = [];
    let camUpDirection = [];
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].transformQuat(eyeDirection, [0.0, 0., 3.], this.rotateQ);
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* vec3 */ "e"].transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].lookAt(this.vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].perspective(this.pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].multiply(this.tmpMatrix, this.pMatrix, this.vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_19___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearColor(0.3, 0.3, 0.3, 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.eyeDirection,
      lambertDiffuse: this.params.lambertDiffuse
    };

    if (this.params.map === 'none') {
      this.prg.use();
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.irradianceMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE1);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.prefilterMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE2);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.brdfLUTTexture.id);
      this.prg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        albedo: [.5, .0, .0],
        ao: 1.,
        irradianceMap: 0,
        prefilterMap: 1,
        brdfLUT: 2
      }));
      this.sphere.bind(this.prg, ['position', 'normal']);

      for (let row = 0; row < nrRows; row++) {
        this.prg.style({
          metallic: row / nrRows
        });

        for (let col = 0; col < nrColumns; col++) {
          gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].translate(mMatrix, gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create(), [(col - nrColumns / 2) * spacing, (row - nrRows / 2) * spacing, 0.0]); // mat4.translate(mMatrix, mMatrix, [1, 0, 0])

          this.prg.style({
            roughness: clamp(col / nrColumns, 0.05, 1.),
            mMatrix
          });
          this.sphere.draw();
        }
      }
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE5);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.irradianceMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE6);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.prefilterMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE7);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.brdfLUTTexture);
      gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [2, 2, 2]);
      this.mapPrg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        mMatrix: mMatrix,
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4,
        irradianceMap: 5,
        prefilterMap: 6,
        brdfLUT: 7
      }));
      this.sphere.bind(this.mapPrg);
      this.sphere.draw();
    } // this.cubePrg.use()
    // this.hdrTexture.bind(0)
    // this.cubePrg.style({
    //   equirectangularMap: 0,
    //   vpMatrix: this.tmpMatrix,
    //   mMatrix: mMatrix
    // })
    // this.cube.bind(this.cubePrg, ['position', 'texCoord'])
    // this.cube.draw()
    // this.planeVao.bind()
    // this.planeBuffer.drawTriangles()
    // this.planeVao.unbind()


    this.skyboxPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.cubemapTexture);
    this.skyboxPrg.style({
      environmentMap: 0,
      vMatrix: this.vMatrix,
      pMatrix: this.pMatrix,
      mMatrix: gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_17__[/* mat4 */ "b"].create())
    });
    this.cube.bind(this.skyboxPrg, ['position']);
    this.cube.draw(); // brdf out为vec2，设置为vec4时显示正常
    // this.brdfPrg.use()
    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    // this.quad.bind(this.brdfPrg)
    // this.quad.draw(gl.TRIANGLE_STRIP)
  }

}

function clamp(value, min, max) {
  if (min > max) {
    return clamp(value, max, min);
  }

  if (value < min) return min;else if (value > max) return max;else return value;
}module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout   vec3 vNormal;\nout vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 6.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color =  ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 vNormal;\nout vec3 WorldPos;\nout vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nin vec2 TexCoords;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 WorldPos;\nout vec2 vUv;\nvoid main(void){\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  WorldPos = pos.xyz;\n  vUv = texCoord;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D equirectangularMap;\nin vec3 WorldPos;\nin vec2 vUv;\nout vec4 outColor;\n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec2 SampleSphericalMap(vec3 v)\n{\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y)); // [-PI/2,PI/2]\n    uv *= invAtan; //[-.5,.5]\n    uv += 0.5;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = SampleSphericalMap(normalize(WorldPos));\n    vec3 color = textureLod(equirectangularMap, uv, 0.).rgb;\n\n    outColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(WorldPos,1.);\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nuniform   mat4 mMatrix;\nuniform   mat4 vMatrix;\nuniform   mat4 pMatrix;\n\nout vec3 WorldPos;\n\nvoid main()\n{\n  mat4 rotView = mat4(mat3(vMatrix)); // remove translation from the view matrix\n  vec4 pos       = mMatrix * vec4(position, 1.0);\n\tvec4 clipPos    = pMatrix * rotView * pos;\n\tgl_Position = clipPos.xyww; // 设置深度测试的z为1，这样只会在没有遮挡时渲染skybox，节省性能\n\n  WorldPos = pos.xyz;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform samplerCube environmentMap;\nin vec3 WorldPos;\nout vec4 outColor;\nvoid main()\n{\n    vec3 envColor = textureLod(environmentMap, WorldPos, 0.).rgb;\n\n    // HDR tonemap and gamma correct\n    envColor = envColor / (envColor + vec3(1.0));\n    envColor = pow(envColor, vec3(1.0/2.2));\n\n    outColor = vec4(envColor, 1.0);\n}\n"module.exports = "#version 300 es\n#define GLSLIFY 1\n\nin vec3 position;\nin vec2 texCoord;\nout vec2 TexCoords;\n\nvoid main(void) {\n  gl_Position = vec4(position, 1.);\n  TexCoords = texCoord;\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec2 FragColor;\nin vec2 TexCoords;\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits)\n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t// from spherical coordinates to cartesian coordinates - halfway vector\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\n\t// from tangent-space H vector to world-space sample vector\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    // note that we use a different k for IBL\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 1024u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the\n        // preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec2 integratedBRDF = IntegrateBRDF(TexCoords.x, TexCoords.y);\n    FragColor = integratedBRDF;\n    // FragColor = vec4(integratedBRDF,0. ,1.);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PbrModel; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_pbr_model_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(132);
/* harmony import */ var shaders_pbr_model_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_model_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_pbr_model_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(133);
/* harmony import */ var shaders_pbr_model_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_model_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_pbr_model_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(134);
/* harmony import */ var shaders_pbr_model_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_model_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_pbr_model_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(135);
/* harmony import */ var shaders_pbr_model_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_pbr_model_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(16);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(21);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(22);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(24);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(25);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(9);
/* harmony import */ var libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(12);
/* harmony import */ var libs_loaders_ObjLoader__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(18);





















/* irradianceMap, prefilterMap 用cmftStudio生成

*/

class PbrModel extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension('OES_texture_float_linear'); // Even WebGL2 requires OES_texture_float_linear

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension("EXT_color_buffer_float"); // // gl.getExtension('OES_texture_half_float')
    // gl.getExtension('OES_texture_half_float_linear')
    // gl.getExtension('EXT_shader_texture_lod')

    this.prg = this.compile(shaders_pbr_model_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_pbr_model_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default.a);
    this.mapPrg = this.compile(shaders_pbr_model_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default.a, shaders_pbr_model_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default.a);
    this.cubePrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
    this.skyboxPrg = this.compile(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default.a, shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default.a);
    this.brdfPrg = this.compile(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_12___default.a, shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_13___default.a);
  }

  attrib() {
    let cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]();
    cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_14__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.cube = cube;
    let quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]();
    let quadData = [-1.0, 1.0, 0.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 0.0, 1.0, 0.0];
    quad.bufferData(quadData, ['position', 'texCoord'], [3, 2]);
    this.quad = quad;
    this.orb = new libs_loaders_ObjLoader__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]().parseObj(getAssets.orb);
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].UNPACK_FLIP_Y_WEBGL, true);
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].create());
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].create());
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].create());
    let vpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(90), 1., .1, 100);
    const CAMERA_SETTINGS = [[gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(-1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, 1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, -1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, -1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, 1), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, 0, -1), gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* vec3 */ "e"].fromValues(0, -1, 0)]];
    let hdrInfo = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.equirectangular);
    console.log('hdrInfo', hdrInfo);
    this.hdrTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.hdrTexture.id);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA32F, hdrInfo.shape[0], hdrInfo.shape[1], 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT, hdrInfo.data);
    this.hdrTexture.clamp(); // cubemap

    let cubemapTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, cubemapTexture);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA32F, 512, 512, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR_MIPMAP_LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    this.cubemapTexture = cubemapTexture;
    this.cubePrg.use();
    this.hdrTexture.bind(0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, 512, 512);
    let captureFrameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createFramebuffer();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, captureFrameBuffer);

    for (let i = 0; i < 6; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].multiply(vpMatrix, pMatrix, vMatrix);
      this.cubePrg.style({
        equirectangularMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.cubemapTexture, 0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
      this.cube.bind(this.cubePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER);

    if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER_COMPLETE) {
      console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null); //brdf lookup texture

    this.brdfLUTTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RG).fromData(512, 512, null, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RG32F);
    this.brdfLUTTexture.bind();
    this.brdfLUTTexture.clamp();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, captureFrameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.brdfLUTTexture.id, 0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, 512, 512);
    this.brdfPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.quad.bind(this.brdfPrg);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TRIANGLE_STRIP);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null);
    let irr_posx = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradiancePosX);
    let irr_negx = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradianceNegX);
    let irr_posy = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradiancePosY);
    let irr_negy = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradianceNegY);
    let irr_posz = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradiancePosZ);
    let irr_negz = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(getAssets.irradianceNegZ);
    this.irradianceMap = new libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"]([irr_posx, irr_negx, irr_posy, irr_negy, irr_posz, irr_negz]);
    this.prefilterMap = libs_GLCubeTexture__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"].parseDDS(getAssets.radiance);
  }

  uniform() {
    this.vMatrix = this.camera.viewMatrix;
    this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].perspective(this.pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].multiply(this.tmpMatrix, this.pMatrix, this.vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      roughness: 0.2,
      metallic: 6 / 7,
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder = this.gui.addFolder('material param');
    folder.add(this.params, 'roughness', 0.05, 1).step(0.01);
    folder.add(this.params, 'metallic', 0, 6 / 7).step(0.01);
    folder.open();
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearColor(0.3, 0.3, 0.3, 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.camera.position,
      lambertDiffuse: this.params.lambertDiffuse
    };

    if (this.params.map === 'none') {
      this.prg.use();
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.irradianceMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE1);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.prefilterMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE2);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.brdfLUTTexture.id);
      this.prg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        mMatrix,
        roughness: this.params.roughness,
        metallic: this.params.metallic,
        albedo: [.5, .0, .0],
        ao: 1.,
        irradianceMap: 0,
        prefilterMap: 1,
        brdfLUT: 2
      }));

      for (let i = 0; i < this.orb.length; i++) {
        this.orb[i].bind(this.prg, ['position', 'normal']);
        this.orb[i].draw();
      }
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE5);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.irradianceMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE6);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.prefilterMap.texture);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE7);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.brdfLUTTexture);
      gl_matrix__WEBPACK_IMPORTED_MODULE_15__[/* mat4 */ "b"].scale(mMatrix, mMatrix, [2, 2, 2]);
      this.mapPrg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        mMatrix,
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4,
        irradianceMap: 5,
        prefilterMap: 6,
        brdfLUT: 7
      }));
      this.sphere.bind(this.mapPrg);
      this.sphere.draw();
    } // this.skyboxPrg.use()
    // gl.activeTexture(gl.TEXTURE0)
    // gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.cubemapTexture)
    // this.skyboxPrg.style({
    //   environmentMap: 0,
    //   vMatrix: this.vMatrix,
    //   pMatrix: this.pMatrix,
    //   mMatrix: mat4.create(),
    // })
    // this.cube.bind(this.skyboxPrg, ['position'])
    // this.cube.draw()

  }

}

function clamp(value, min, max) {
  if (min > max) {
    return clamp(value, max, min);
  }

  if (value < min) return min;else if (value > max) return max;else return value;
}module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout   vec3 vNormal;\nout vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 6.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color =  ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 vNormal;\nout vec3 WorldPos;\nout vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nin vec2 TexCoords;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// D, G, F formula is refered from http://graphicrants.blogspot.tw/2013/08/specular-brdf-reference.html\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IblFinal; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _PipeLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var libs_GlTools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var shaders_ibl_final_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(136);
/* harmony import */ var shaders_ibl_final_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var shaders_ibl_final_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(137);
/* harmony import */ var shaders_ibl_final_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var shaders_ibl_final_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(146);
/* harmony import */ var shaders_ibl_final_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_pbr_map_vert__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var shaders_ibl_final_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(147);
/* harmony import */ var shaders_ibl_final_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_pbr_map_frag__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(16);
/* harmony import */ var shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(21);
/* harmony import */ var shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(22);
/* harmony import */ var shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23);
/* harmony import */ var shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var shaders_ibl_final_prefilter_frag__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(138);
/* harmony import */ var shaders_ibl_final_prefilter_frag__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_prefilter_frag__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(24);
/* harmony import */ var shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(25);
/* harmony import */ var shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var shaders_ibl_final_irradiance_convolution_frag__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(139);
/* harmony import */ var shaders_ibl_final_irradiance_convolution_frag__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(shaders_ibl_final_irradiance_convolution_frag__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var libs_glBuffer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(11);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(15);
/* harmony import */ var libs_vao__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(libs_vao__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _Torus__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(6);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(1);
/* harmony import */ var libs_Mesh__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(3);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(4);
/* harmony import */ var libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(libs_glTexture__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(9);























class IblFinal extends _PipeLine__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, "count", 0);
  }

  init() {
    // use webgl2
    // gl.getExtension('OES_standard_derivatives')
    // gl.getExtension('OES_texture_float')
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension('OES_texture_float_linear'); // Even WebGL2 requires OES_texture_float_linear

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].getExtension("EXT_color_buffer_float"); // // gl.getExtension('OES_texture_half_float')
    // gl.getExtension('OES_texture_half_float_linear')
    // gl.getExtension('EXT_shader_texture_lod')

    this.prg = this.compile(shaders_ibl_final_pbr_ibl_vert__WEBPACK_IMPORTED_MODULE_4___default.a, shaders_ibl_final_pbr_ibl_frag__WEBPACK_IMPORTED_MODULE_5___default.a); // this.mapPrg = this.compile(mapVs, mapFs)

    this.cubePrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_equirectangular_to_cubemap_frag__WEBPACK_IMPORTED_MODULE_9___default.a);
    this.skyboxPrg = this.compile(shaders_ibl_final_skybox_vert__WEBPACK_IMPORTED_MODULE_10___default.a, shaders_ibl_final_skybox_frag__WEBPACK_IMPORTED_MODULE_11___default.a);
    this.prefilterPrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_prefilter_frag__WEBPACK_IMPORTED_MODULE_12___default.a);
    this.brdfPrg = this.compile(shaders_ibl_final_simple2d_vert__WEBPACK_IMPORTED_MODULE_13___default.a, shaders_ibl_final_brdf_frag__WEBPACK_IMPORTED_MODULE_14___default.a);
    this.irradiancePrg = this.compile(shaders_ibl_final_cubemap_vert__WEBPACK_IMPORTED_MODULE_8___default.a, shaders_ibl_final_irradiance_convolution_frag__WEBPACK_IMPORTED_MODULE_15___default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      uv
    } = Object(_Torus__WEBPACK_IMPORTED_MODULE_18__["Sphere"])(256, 256, .15);
    let sphere = new libs_Mesh__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]();
    sphere.bufferVertex(pos);
    sphere.bufferIndex(index);
    sphere.bufferNormal(normal);
    sphere.bufferTexCoord(uv);
    this.sphere = sphere;
    let cube = new libs_Mesh__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]();
    cube.bufferData(_Torus__WEBPACK_IMPORTED_MODULE_18__["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.cube = cube;
    let planeVertices = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, 3.0, 0.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, -3.0, 1.0, 1.0];
    this.planeBuffer = new libs_glBuffer__WEBPACK_IMPORTED_MODULE_16__[/* ArrayBuffer */ "a"](libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"], new Float32Array(planeVertices));
    this.planeBuffer.attrib('position', 3, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT);
    this.planeBuffer.attrib('texCoord', 2, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT);
    this.planeVao = new libs_vao__WEBPACK_IMPORTED_MODULE_17___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]);
    this.planeVao.setup(this.cubePrg, [this.planeBuffer]);
    let quad = new libs_Mesh__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]();
    let quadData = [-1.0, 1.0, 0.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 0.0, 1.0, 0.0];
    quad.bufferData(quadData, ['position', 'texCoord'], [3, 2]);
    this.quad = quad;
  }

  prepare() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].enable(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_TEST);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].depthFunc(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LEQUAL);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].pixelStorei(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].UNPACK_FLIP_Y_WEBGL, true);
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].create());
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].create());
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].create());
    let vpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].create());
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(90), 1., .1, 100);
    const CAMERA_SETTINGS = [[gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(-1, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, 1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, -1, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, -1)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, 1), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, -1, 0)], [gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, 0, -1), gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].fromValues(0, -1, 0)]];
    let hdrInfo = Object(libs_loaders_HDRParser__WEBPACK_IMPORTED_MODULE_22__[/* default */ "a"])(getAssets.equirectangular);
    console.log('hdrInfo', hdrInfo);
    this.hdrTexture = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.hdrTexture.id);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA32F, hdrInfo.shape[0], hdrInfo.shape[1], 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT, hdrInfo.data);
    this.hdrTexture.clamp(); // cubemap

    let cubemapTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, cubemapTexture);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA32F, 512, 512, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR_MIPMAP_LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    this.cubemapTexture = cubemapTexture;
    this.cubePrg.use();
    this.hdrTexture.bind(0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, 512, 512);
    let captureFrameBuffer = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createFramebuffer();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, captureFrameBuffer);

    for (let i = 0; i < 6; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].multiply(vpMatrix, pMatrix, vMatrix);
      this.cubePrg.style({
        equirectangularMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.cubemapTexture, 0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
      this.cube.bind(this.cubePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].generateMipmap(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP); // has to be placed here，to generate each face data

    const status = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].checkFramebufferStatus(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER);

    if (status != libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER_COMPLETE) {
      console.log(`gl.checkFramebufferStatus() returned ${status.toString(16)}`);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null); // irradiance map

    let irradianceMap = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, irradianceMap);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA32F, 32, 32, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    this.irradianceMap = irradianceMap;
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, captureFrameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, 32, 32);
    this.irradiancePrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.cubemapTexture); // 放在这，防止new cubeframebuffer时绑定了tetxure0到null

    for (let i = 0; i < 6; i++) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].multiply(vpMatrix, pMatrix, vMatrix);
      this.irradiancePrg.style({
        environmentMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.irradianceMap, 0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
      this.cube.bind(this.irradiancePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null); // prefilter map

    this.prefilterMap = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createTexture();
    let prefilterSize = 128;
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.prefilterMap);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA32F, prefilterSize, prefilterSize, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RGBA, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT, null);
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR_MIPMAP_LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].generateMipmap(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP);
    this.prefilterPrg.use();
    let maxMipLevels = 5;
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.cubemapTexture); // 放在这，防止new cubeframebuffer时绑定了tetxure0到null

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, captureFrameBuffer);

    for (let mip = 0; mip < maxMipLevels; mip++) {
      let mipWidth = 128 * Math.pow(.5, mip);
      let mipHeight = mipWidth;
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, mipWidth, mipHeight);
      let roughness = mip / (maxMipLevels - 1);

      for (let i = 0; i < 6; i++) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].multiply(vpMatrix, pMatrix, vMatrix);
        this.prefilterPrg.style({
          environmentMap: 0,
          vpMatrix,
          mMatrix: mMatrix,
          roughness
        });
        libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.prefilterMap, mip);
        libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
        this.cube.bind(this.prefilterPrg, ['position', 'texCoord']);
        this.cube.draw();
      }
    }

    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null); //brdf lookup texture

    this.brdfLUTTexture = libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].createTexture();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.brdfLUTTexture);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texImage2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RG32F, 512, 512, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].RG, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FLOAT, null);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_S, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_WRAP_T, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].CLAMP_TO_EDGE);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MIN_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].texParameteri(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_MAG_FILTER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].LINEAR);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, captureFrameBuffer);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].framebufferTexture2D(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_ATTACHMENT0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.brdfLUTTexture, 0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, 512, 512);
    this.brdfPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    this.quad.bind(this.brdfPrg);
    this.quad.draw(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TRIANGLE_STRIP);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindFramebuffer(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].FRAMEBUFFER, null);
  }

  uniform() {
    let vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].create());
    let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].create());
    this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].create());
    let eyeDirection = [];
    let camUpDirection = [];
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].transformQuat(eyeDirection, [0.0, 0.0, 1.0], this.rotateQ);
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* vec3 */ "e"].transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].lookAt(vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].perspective(pMatrix, Object(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* toRadian */ "d"])(45), libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientWidth / libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].clientHeight, .1, 100);
    gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].multiply(this.tmpMatrix, pMatrix, vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      roughness: 0.2,
      metallic: 6 / 7,
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder = this.gui.addFolder('material param');
    folder.add(this.params, 'roughness', 0.05, 1).step(0.01);
    folder.add(this.params, 'metallic', 0, 6 / 7).step(0.01);
    folder.open();
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new libs_glTexture__WEBPACK_IMPORTED_MODULE_21___default.a(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"]).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].viewport(0, 0, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].width, libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* canvas */ "b"].height);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearColor(0.3, 0.3, 0.3, 1.);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clearDepth(1.0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].clear(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].COLOR_BUFFER_BIT | libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].identity(gl_matrix__WEBPACK_IMPORTED_MODULE_19__[/* mat4 */ "b"].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.eyeDirection,
      lambertDiffuse: this.params.lambertDiffuse,
      irradianceMap: 0
    };

    if (this.params.map === 'none') {
      this.prg.use();
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.irradianceMap);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE1);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.prefilterMap);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE2);
      libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_2D, this.brdfLUTTexture);
      this.prg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        albedo: [.5, .0, .0],
        roughness: this.params.roughness,
        metallic: this.params.metallic,
        ao: 1.,
        irradianceMap: 0,
        prefilterMap: 1,
        brdfLUT: 2
      }));
      this.sphere.bind(this.prg, ['position', 'normal']);
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      this.mapPrg.style(Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, baseUniforms, {
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4
      }));
      this.sphere.bind(this.mapPrg);
    }

    this.sphere.draw(); // this.cubePrg.use()
    // this.hdrTexture.bind(0)
    // this.cubePrg.style({
    //   equirectangularMap: 0,
    //   vpMatrix: this.tmpMatrix,
    //   mMatrix: mMatrix
    // })
    // this.cube.bind(this.cubePrg, ['position', 'texCoord'])
    // this.cube.draw()
    // this.planeVao.bind()
    // this.planeBuffer.drawTriangles()
    // this.planeVao.unbind()

    this.skyboxPrg.use();
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].activeTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE0);
    libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].bindTexture(libs_GlTools__WEBPACK_IMPORTED_MODULE_3__[/* gl */ "c"].TEXTURE_CUBE_MAP, this.prefilterMap);
    this.skyboxPrg.style({
      environmentMap: 0,
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix
    });
    this.cube.bind(this.skyboxPrg, ['position']);
    this.cube.draw(); // brdf out为vec2，设置为vec4时显示正常
    // this.brdfPrg.use()
    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    // this.quad.bind(this.brdfPrg)
    // this.quad.draw(gl.TRIANGLE_STRIP)
  }

}module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout   vec3 vNormal;\nout vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout vec3 vNormal;\nout vec3 WorldPos;\nout vec2 TexCoords;\n\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n// material map\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 WorldPos;\nin vec2 TexCoords;\n\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\nin vec3 WorldPos;\n\nuniform samplerCube environmentMap;\nuniform float roughness;\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits)\n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t// from spherical coordinates to cartesian coordinates - halfway vector\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\n\t// from tangent-space H vector to world-space sample vector\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec3 N = normalize(WorldPos);\n\n    // make the simplyfying assumption that V equals R equals the normal\n    vec3 R = N;\n    vec3 V = R;\n\n    const uint SAMPLE_COUNT = 1024u;\n    vec3 prefilteredColor = vec3(0.0);\n    float totalWeight = 0.0;\n\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        if(NdotL > 0.0)\n        {\n            // sample from the environment's mip level based on roughness/pdf\n            float D   = DistributionGGX(N, H, roughness);\n            float NdotH = max(dot(N, H), 0.0);\n            float HdotV = max(dot(H, V), 0.0);\n            float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;\n\n            float resolution = 512.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n\n            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel);\n\n            prefilteredColor += textureLod(environmentMap, L, mipLevel).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n\n    prefilteredColor = prefilteredColor / totalWeight;\n\n    FragColor = vec4(prefilteredColor, 1.0);\n}\n"module.exports = "#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nin vec3 WorldPos;\nout vec4 outColor;\nuniform samplerCube environmentMap;\n\nconst float PI = 3.14159265359;\n\nvoid main()\n{\n\t// The world vector acts as the normal of a tangent surface\n    // from the origin, aligned to WorldPos. Given this normal, calculate all\n    // incoming radiance of the environment. The result of this radiance\n    // is the radiance of light coming from -Normal direction, which is what\n    // we use in the PBR shader to sample irradiance.\n    vec3 N = normalize(WorldPos);\n\n    vec3 irradiance = vec3(0.0);\n\n    // tangent space calculation from origin point\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up            = cross(N, right);\n\n    const float sampleDelta = 0.025;\n    float nrSamples = 0.0;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\n\n            irradiance += texture(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n    outColor = vec4(irradiance, 1.0);\n}\n"__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({});__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(2);

// EXTERNAL MODULE: ./src/js/PipeLine.js + 1 modules
var PipeLine = __webpack_require__(5);

// EXTERNAL MODULE: ./libs/Geom.js
var Geom = __webpack_require__(8);

// EXTERNAL MODULE: ./libs/shaders/CustomShaders.js
var CustomShaders = __webpack_require__(13);

// CONCATENATED MODULE: ./libs/loaders/xhr.js
// xhr.js
const load = (mPath, isArrayBuffer) => new Promise((resolve, reject) => {
  const req = new XMLHttpRequest();
  req.addEventListener('load', e => {
    resolve(req.response);
  });
  req.addEventListener('error', e => {
    reject(e);
  });

  if (isArrayBuffer) {
    req.responseType = 'arraybuffer';
  }

  req.open('GET', mPath);
  req.send();
});

/* harmony default export */ var xhr = (load);
// CONCATENATED MODULE: ./libs/loaders/loadImages.js
// loadImages.js
const get = url => new Promise((resolve, reject) => {
  const img = new Image();

  img.onload = function onLoad() {
    resolve(this);
  };

  img.onerror = function onError() {
    reject(`Image not found : ${url}`);
  };

  img.src = url;
});

const loadImages = paths => Promise.all(paths.map(get));

/* harmony default export */ var loaders_loadImages = (loadImages);
// EXTERNAL MODULE: ./libs/GLShader.js
var GLShader = __webpack_require__(28);

// CONCATENATED MODULE: ./libs/shaders/Shader.js

const shaderCache = [];

const definesToString = function (defines) {
  let outStr = '';

  for (const def in defines) {
    if (defines[def]) {
      outStr += `#define ${def} ${defines[def]}\n`;
    }
  }

  return outStr;
};

const injectDefines = function (mShader, mDefines) {
  mShader = mShader.replace('#version 300 es', '');
  return `#version 300 es\n${definesToString(mDefines)}\n${mShader}`;
};

const Shader_get = (vs, fs, defines = {}) => {
  let _shader;

  const _vs = injectDefines(vs, defines);

  const _fs = injectDefines(fs, defines);

  shaderCache.forEach(shader => {
    if (_vs === shader.vs && _fs === shader.fs) {
      _shader = shader.glShader;
    }
  });

  if (!_shader) {
    _shader = new GLShader["a" /* default */](_vs, _fs);
    shaderCache.push({
      vs: _vs,
      fs: _fs,
      glShader: _shader
    });
  }

  return _shader;
};

/* harmony default export */ var Shader = ({
  get: Shader_get
});
// CONCATENATED MODULE: ./libs/Material.js
// material 应该在shader编译前，需要注入define来定义具有相关material map
//这里我们将shader compile相关任务放在shader.js这里

class Material_Material {
  constructor(vs, fs, uniforms = {}, defines = {}) {
    this._shader = Shader.get(vs, fs, defines);
    this.uniforms = Object.assign({}, uniforms);
  }

  update() {
    this._shader.bind();

    this._shader.uniform(this.uniforms);
  }

  get shader() {
    return this._shader;
  }

}
// EXTERNAL MODULE: ./libs/Mesh.js + 1 modules
var Mesh = __webpack_require__(3);

// EXTERNAL MODULE: ./libs/GLTexture.js + 2 modules
var GLTexture = __webpack_require__(14);

// EXTERNAL MODULE: ./libs/physics/Object3D.js
var Object3D = __webpack_require__(19);

// CONCATENATED MODULE: ./libs/loaders/GLTFLoader.js
// GltfLoader.js







const ARRAY_CTOR_MAP = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
const SIZE_MAP = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
const semanticAttributeMap = {
  NORMAL: 'normal',
  POSITION: 'position',
  // 'TANGENT': 'aTangent',
  TEXCOORD_0: 'texCoord',
  // TEXCOORD_1: 'aTextureCoord1',
  WEIGHTS_0: 'aWeight',
  JOINTS_0: 'aJoint',
  COLOR: 'color'
};
let base;

const GLTFLoader_load = mSource => new Promise((resolve, reject) => {
  if (typeof mSource === 'string') {
    base = mSource.substring(0, mSource.lastIndexOf('/') + 1);
  } else {
    base = '';
  }

  _loadGltf(mSource).then(_loadBin).then(_loadTextures).then(_getBufferViewData).then(_parseMaterials).then(_parseMesh).then(_parseNodes).then(gltfInfo => {
    resolve(gltfInfo);
  }).catch(e => {
    console.log('Error:', e);
  });
});

const _parseNodes = gltf => new Promise((resolve, reject) => {
  const {
    nodes,
    scenes
  } = gltf;

  const getTree = nodeIndex => {
    const node = nodes[nodeIndex];
    const obj3D = node.mesh === undefined ? new Object3D["a" /* default */]() : gltf.output.meshes[node.mesh];

    if (node.scale) {
      obj3D.scaleX = node.scale[0];
      obj3D.scaleY = node.scale[1];
      obj3D.scaleZ = node.scale[2];
    }

    if (node.rotation) {
      obj3D.setRotationFromQuaternion(node.rotation);
    }

    if (node.translation) {
      obj3D.x = node.translation[0];
      obj3D.y = node.translation[1];
      obj3D.z = node.translation[2];
    }

    if (node.children) {
      node.children.forEach(child => {
        const _child = getTree(child);

        obj3D.addChild(_child);
      });
    }

    return obj3D;
  };

  gltf.output.scenes = scenes.map(scene => {
    const container = new Object3D["a" /* default */]();
    scene.nodes.forEach(nodeIndex => {
      const childTree = getTree(nodeIndex);
      container.addChild(childTree);
    });
    return container;
  });
  resolve(gltf);
});

const _parseMesh = gltf => new Promise((resolve, reject) => {
  const {
    meshes
  } = gltf;
  meshes.forEach(mesh => {
    const {
      primitives
    } = mesh;
    const geometryInfo = {};
    primitives.forEach(primitiveInfo => {
      const semantics = Object.keys(primitiveInfo.attributes);
      let defines = {};
      semantics.forEach(semantic => {
        const accessorIdx = primitiveInfo.attributes[semantic];
        const attributeInfo = gltf.accessors[accessorIdx];
        const attributeName = semanticAttributeMap[semantic];

        if (!attributeName) {
          return;
        }

        if (semantic === 'NORMAL') {
          defines.HAS_NORMALS = 1;
        }

        if (semantic.indexOf('TEXCOORD') > -1) {
          defines.HAS_UV = 1;
        }

        const size = SIZE_MAP[attributeInfo.type];

        let attributeArray = _getAccessorData(gltf, accessorIdx);

        if (attributeArray instanceof Uint32Array) {
          attributeArray = new Float32Array(attributeArray);
        }

        if (semantic === 'TEXCOORD_1') {
          console.log(size, attributeArray);
        }

        geometryInfo[attributeName] = {
          value: attributeArray,
          size
        }; // console.log('attribute', attributeName, geometry[attributeName]);
      }); //	parse index

      if (primitiveInfo.indices != null) {
        const attributeArray = _getAccessorData(gltf, primitiveInfo.indices, true);

        geometryInfo.indices = {
          value: attributeArray,
          size: 1
        };
      }

      const mesh = new Mesh["a" /* default */]();

      for (const s in geometryInfo) {
        const data = geometryInfo[s];

        if (s !== 'indices') {
          mesh.bufferFlattenData(data.value, s, data.size);
        } else {
          mesh.bufferIndex(data.value);
        }
      }

      const materialInfo = gltf.output.materialInfo[primitiveInfo.material];
      defines = Object.assign(defines, materialInfo.defines);
      const {
        emissiveFactor,
        emissiveTexture,
        normalTexture,
        occlusionTexture,
        pbrMetallicRoughness
      } = materialInfo;
      const {
        baseColorTexture,
        metallicRoughnessTexture
      } = pbrMetallicRoughness;
      const uniforms = {
        uEmissiveFactor: emissiveFactor || [0, 0, 0],
        uBaseColor: pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1],
        uRoughness: pbrMetallicRoughness.roughnessFactor || 1,
        uMetallic: pbrMetallicRoughness.metallicFactor || 1,
        uScaleDiffBaseMR: [0, 0, 0, 0],
        uScaleFGDSpec: [0, 0, 0, 0],
        uScaleIBLAmbient: [1, 1, 1, 1],
        uLightDirection: [1, 1, 1],
        uLightColor: [1, 1, 1],
        uGamma: 1
      };

      if (baseColorTexture) {
        uniforms.uColorMap = baseColorTexture.glTexture;
      }

      if (metallicRoughnessTexture) {
        uniforms.uMetallicRoughnessMap = metallicRoughnessTexture.glTexture;
      }

      if (normalTexture) {
        uniforms.uNormalScale = normalTexture.scale || 1;
        uniforms.uNormalMap = normalTexture.glTexture;
      }

      if (occlusionTexture) {
        uniforms.uAoMap = occlusionTexture.glTexture;
        uniforms.uOcclusionStrength = occlusionTexture.strength || 1;
      }

      if (emissiveTexture) {
        uniforms.uEmissiveMap = emissiveTexture.glTexture;
      }

      const material = new Material_Material(CustomShaders["a" /* default */].gltfVert, CustomShaders["a" /* default */].gltfFrag, uniforms, defines);
      mesh.setMaterial(material);
      gltf.output.meshes.push(mesh);
    });
  });
  resolve(gltf);
});

const _getBufferViewData = gltfInfo => new Promise((resolve, reject) => {
  const {
    bufferViews,
    buffers
  } = gltfInfo;
  bufferViews.forEach((bufferViewInfo, i) => {
    const buffer = buffers[bufferViewInfo.buffer].data;
    bufferViewInfo.data = buffer.slice(bufferViewInfo.byteOffset || 0, (bufferViewInfo.byteOffset || 0) + (bufferViewInfo.byteLength || 0));
  });
  resolve(gltfInfo);
});

const _loadGltf = mSource => new Promise((resolve, reject) => {
  if (typeof mSource !== 'string') {
    resolve(mSource);
  } else {
    xhr(mSource).then(o => {
      const gltfInfo = JSON.parse(o);
      gltfInfo.output = {
        meshes: [],
        scenes: [],
        textures: [],
        material: [],
        materialInfo: []
      };
      resolve(gltfInfo);
    }, e => {
      reject(e);
    });
  }
});

const _loadBin = gltfInfo => new Promise((resolve, reject) => {
  if (gltfInfo.buffers) {
    let count = gltfInfo.buffers.length;
    gltfInfo.buffers.forEach(buffer => {
      const urlBin = `${base}${gltfInfo.buffers[0].uri}`;
      xhr(urlBin, true).then(o => {
        buffer.data = o;
        count--;

        if (count === 0) {
          resolve(gltfInfo);
        }
      }, e => {
        reject(e);
      });
    });
  } else {
    resolve(gltfInfo);
  }
});

const _loadTextures = gltfInfo => new Promise((resolve, reject) => {
  const {
    textures,
    images,
    samplers
  } = gltfInfo;

  if (!images) {
    resolve(gltfInfo);
  }

  const imagesToLoad = images.map(img => `${base}${img.uri}`);
  loaders_loadImages(imagesToLoad).then(o => {
    gltfInfo.output.textures = o.map((img, i) => {
      const settings = Object.assign({}, samplers ? samplers[textures[i].sampler] : {});
      return new GLTexture["a" /* default */](img, settings);
    });
    resolve(gltfInfo);
  }, e => {
    reject(e);
  });
});

const _parseMaterials = gltfInfo => new Promise((resolve, reject) => {
  const {
    materials
  } = gltfInfo;
  const {
    textures
  } = gltfInfo.output;
  gltfInfo.output.materialInfo = materials.map(material => {
    material.defines = {
      USE_IBL: 1
    };

    if (material.normalTexture) {
      material.defines.HAS_NORMALMAP = 1;
      material.normalTexture.glTexture = textures[material.normalTexture.index];
    }

    if (material.occlusionTexture) {
      material.defines.HAS_OCCLUSIONMAP = 1;
      material.occlusionTexture.glTexture = textures[material.occlusionTexture.index];
    }

    if (material.emissiveTexture) {
      material.defines.HAS_EMISSIVEMAP = 1;
      material.emissiveTexture.glTexture = textures[material.emissiveTexture.index];
    } // if(material.pbrMetallicRoughness) {


    if (material.pbrMetallicRoughness.baseColorTexture) {
      material.defines.HAS_BASECOLORMAP = 1;
      material.pbrMetallicRoughness.baseColorTexture.glTexture = textures[material.pbrMetallicRoughness.baseColorTexture.index];
    }

    if (material.pbrMetallicRoughness.metallicRoughnessTexture) {
      material.defines.HAS_METALROUGHNESSMAP = 1;
      material.pbrMetallicRoughness.metallicRoughnessTexture.glTexture = textures[material.pbrMetallicRoughness.metallicRoughnessTexture.index];
    } // }


    return material;
  });
  resolve(gltfInfo);
});

const parse = (mGltfInfo, mBin) => new Promise((resolve, reject) => {
  resolve(mSource);
});

const _getAccessorData = (gltf, accessorIdx, isIndices = false) => {
  const accessorInfo = gltf.accessors[accessorIdx];
  const buffer = gltf.bufferViews[accessorInfo.bufferView].data;
  const byteOffset = accessorInfo.byteOffset || 0;
  const ArrayCtor = ARRAY_CTOR_MAP[accessorInfo.componentType] || Float32Array;
  let size = SIZE_MAP[accessorInfo.type];

  if (size == null && isIndices) {
    size = 1;
  }

  let arr = new ArrayCtor(buffer, byteOffset, size * accessorInfo.count);
  const quantizeExtension = accessorInfo.extensions && accessorInfo.extensions['WEB3D_quantized_attributes'];

  if (quantizeExtension) {
    const decodedArr = new Float32Array(size * accessorInfo.count);
    const decodeMatrix = quantizeExtension.decodeMatrix;
    const decodeOffset = new Array(size);
    const decodeScale = new Array(size);

    for (let k = 0; k < size; k++) {
      decodeOffset[k] = decodeMatrix[size * (size + 1) + k];
      decodeScale[k] = decodeMatrix[k * (size + 1) + k];
    }

    for (let i = 0; i < accessorInfo.count; i++) {
      for (let k = 0; k < size; k++) {
        decodedArr[i * size + k] = arr[i * size + k] * decodeScale[k] + decodeOffset[k];
      }
    }

    arr = decodedArr;
  } // console.log({buffer, byteOffset, ArrayCtor, size, arr});


  return arr;
};

/* harmony default export */ var GLTFLoader = ({
  load: GLTFLoader_load,
  parse
});
// EXTERNAL MODULE: ./libs/GlTools.js
var GlTools = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/gl-matrix/src/gl-matrix.js + 7 modules
var gl_matrix = __webpack_require__(1);

// CONCATENATED MODULE: ./src/js/Pbr/gltf.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gltf_GLTF; });








class gltf_GLTF extends PipeLine["default"] {
  constructor() {
    super();

    Object(defineProperty["a" /* default */])(this, "count", 0);
  }

  init() {
    this.skyboxPrg = this.compile(CustomShaders["a" /* default */].skyboxVert, CustomShaders["a" /* default */].skyboxFrag);
    GlTools["c" /* gl */].enable(GlTools["c" /* gl */].BLEND);
    GlTools["c" /* gl */].blendFunc(GlTools["c" /* gl */].SRC_ALPHA, GlTools["c" /* gl */].ONE_MINUS_SRC_ALPHA);
  }

  attrib() {
    this.skybox = Geom["a" /* default */].skybox(40);
  }

  prepare() {
    this.skyMap = getAssets.outputskybox;
    this.env = 'studio9';
    this.textureIrr = getAssets[`${this.env}_irradiance`];
    this.textureRad = getAssets[`${this.env}_radiance`];
    this.textureBrdf = getAssets['brdfLUT'];
    const gltfList = ['chinatown_lion', 'BoomBox', 'FlightHelmet', 'horse_statuette', 'swan_sculpture', 'triton_on_a_frieze'];
    const index = 1;
    const url = `assets/gltf/${gltfList[index]}/scene.gltf`;
    GLTFLoader.load(url).then(gltfInfo => {
      this.gltf = gltfInfo;
      const {
        meshes
      } = gltfInfo.output;
      this.scenes = gltfInfo.output.scenes;
      meshes.forEach(mesh => {
        mesh.material.uniforms.uBRDFMap = this.textureBrdf;
        mesh.material.uniforms.uIrradianceMap = this.textureIrr;
        mesh.material.uniforms.uRadianceMap = this.textureRad;
      });
      this.gltfPrg = meshes[0].material.shader;
    }).catch(e => {
      console.log('Error loading gltf:', e);
    });
    this.camera.radius = 6;
  }

  uniform() {
    gl_matrix["b" /* mat4 */].perspective(this.pMatrix, Object(GlTools["d" /* toRadian */])(45), GlTools["b" /* canvas */].clientWidth / GlTools["b" /* canvas */].clientHeight, .1, 100);
    gl_matrix["b" /* mat4 */].multiply(this.tmpMatrix, this.pMatrix, this.vMatrix);
    let mMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    gl_matrix["b" /* mat4 */].multiply(this.mvpMatrix, this.tmpMatrix, mMatrix);
    this.skyboxPrg.use();
    this.skyboxPrg.style({
      mvpMatrix: this.mvpMatrix,
      uGamma: 2.2,
      uExposure: 5.,
      tex: this.skyMap
    });
  }

  render() {
    GlTools["c" /* gl */].clearColor(0.3, 0.3, .3, 1.0);
    GlTools["c" /* gl */].clear(GlTools["c" /* gl */].COLOR_BUFFER_BIT);
    this.skyboxPrg.use();
    GlTools["a" /* GlTools */].draw(this.skybox);

    if (this.gltfPrg) {
      this.gltfPrg.use();
    }

    if (this.scenes) {
      this.scenes.forEach(scene => {
        scene.scaleX = 100;
        scene.scaleY = 100;
        scene.scaleZ = 100;
        GlTools["a" /* GlTools */].draw(scene);
      });
    }
  }

}__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/js/PipeLine.js + 1 modules
var PipeLine = __webpack_require__(5);

// EXTERNAL MODULE: ./libs/GlTools.js
var GlTools = __webpack_require__(0);

// EXTERNAL MODULE: ./src/shaders/mask.vert
var mask = __webpack_require__(41);
var mask_default = /*#__PURE__*/__webpack_require__.n(mask);

// EXTERNAL MODULE: ./src/shaders/mask.frag
var shaders_mask = __webpack_require__(110);
var shaders_mask_default = /*#__PURE__*/__webpack_require__.n(shaders_mask);

// EXTERNAL MODULE: ./src/shaders/maskOutline.frag
var maskOutline = __webpack_require__(111);
var maskOutline_default = /*#__PURE__*/__webpack_require__.n(maskOutline);

// EXTERNAL MODULE: ./node_modules/gl-matrix/src/gl-matrix.js + 7 modules
var gl_matrix = __webpack_require__(1);

// EXTERNAL MODULE: ./src/js/Torus.js
var Torus = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(2);

// CONCATENATED MODULE: ./libs/physics/Geometry3D.js


class Geometry3D_Ray {
  constructor(origin, direction) {
    Object(defineProperty["a" /* default */])(this, "origin", gl_matrix["e" /* vec3 */].create());

    Object(defineProperty["a" /* default */])(this, "direction", gl_matrix["e" /* vec3 */].create());

    this.origin = gl_matrix["e" /* vec3 */].fromValues(...origin);
    gl_matrix["e" /* vec3 */].normalize(this.direction, gl_matrix["e" /* vec3 */].fromValues(...direction));
  }

}
class Geometry3D_AABB {
  //half size
  constructor(origin, size) {
    Object(defineProperty["a" /* default */])(this, "origin", gl_matrix["e" /* vec3 */].create());

    Object(defineProperty["a" /* default */])(this, "size", gl_matrix["e" /* vec3 */].create());

    this.origin = origin;
    this.size = size;
  }

  fromMinMax(min, max) {
    return new Geometry3D_AABB([(min[0] + max[0]) * .5, (min[1] + max[1]) * .5, (min[2] + max[2]) * .5], [(max[0] - min[0]) * .5, (max[1] - min[1]) * .5, (max[2] - min[2]) * .5]);
  }

  getMin() {
    let p1, p2;
    p1 = gl_matrix["e" /* vec3 */].create();
    p2 = gl_matrix["e" /* vec3 */].create();
    p1 = gl_matrix["e" /* vec3 */].add(p1, this.origin, this.size);
    p2 = gl_matrix["e" /* vec3 */].subtract(p2, this.origin, this.size);
    let t = gl_matrix["e" /* vec3 */].create();
    gl_matrix["e" /* vec3 */].min(t, p1, p2);
    return t;
  }

  getMax() {
    let p1, p2;
    p1 = gl_matrix["e" /* vec3 */].create();
    p2 = gl_matrix["e" /* vec3 */].create();
    p1 = gl_matrix["e" /* vec3 */].add(p1, this.origin, this.size);
    p2 = gl_matrix["e" /* vec3 */].subtract(p2, this.origin, this.size);
    let t = gl_matrix["e" /* vec3 */].create();
    gl_matrix["e" /* vec3 */].max(t, p1, p2);
    return t;
  }

  get position() {
    let position = [];
    let origin = this.origin;
    let size = this.size;
    position.push(origin[0] - size[0], origin[1] + size[1], origin[2] + size[2]);
    position.push(origin[0] - size[0], origin[1] - size[1], origin[2] + size[2]);
    position.push(origin[0] + size[0], origin[1] + size[1], origin[2] + size[2]);
    position.push(origin[0] + size[0], origin[1] - size[1], origin[2] + size[2]);
    position.push(origin[0] + size[0], origin[1] + size[1], origin[2] - size[2]);
    position.push(origin[0] + size[0], origin[1] - size[1], origin[2] - size[2]);
    position.push(origin[0] - size[0], origin[1] + size[1], origin[2] - size[2]);
    position.push(origin[0] - size[0], origin[1] - size[1], origin[2] - size[2]);
    return position;
  }

  get index() {
    // 6 face
    return [0, 1, 2, 1, 3, 2, 6, 4, 7, 7, 4, 5, 1, 0, 6, 1, 6, 7, 3, 4, 2, 3, 5, 4, 0, 6, 4, 0, 2, 4, 1, 7, 5, 1, 5, 3];
  }

  get texCoord() {
    return [0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, // 
    1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, // front face
    1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, // left face 
    1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, // right face
    0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, // bottom face
    0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0]; // top face 
  }

}
class RayCast {
  rayAABB(aabb, ray) {
    let min = aabb.getMin();
    let max = aabb.getMax();
    let t1 = (min[0] - ray.origin[0]) / (ray.direction[0] == 0 ? 0.00001 : ray.direction[0]);
    let t2 = (max[0] - ray.origin[0]) / (ray.direction[0] == 0 ? 0.00001 : ray.direction[0]);
    let t3 = (min[1] - ray.origin[1]) / (ray.direction[1] == 0 ? 0.00001 : ray.direction[1]);
    let t4 = (max[1] - ray.origin[1]) / (ray.direction[1] == 0 ? 0.00001 : ray.direction[1]);
    let t5 = (min[2] - ray.origin[2]) / (ray.direction[2] == 0 ? 0.00001 : ray.direction[2]);
    let t6 = (max[2] - ray.origin[2]) / (ray.direction[2] == 0 ? 0.00001 : ray.direction[2]);
    let tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    let tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)); // if tmax < 0, ray is intersecting AABB
    // but entire AABB is behing it's origin

    if (tmax < 0) {
      return false;
    } // if tmin > tmax, ray doesn't intersect AABB


    if (tmin > tmax) {
      return false;
    }

    let rayT = tmin; // If tmin is < 0, tmax is closer

    if (tmin < 0.0) {
      rayT = tmax;
    }

    return true;
  }

  raySphere() {}

}
// CONCATENATED MODULE: ./libs/physics/Intersect.js




class Intersect_Intersect {
  constructor() {
    Object(defineProperty["a" /* default */])(this, "ray", void 0);

    Object(defineProperty["a" /* default */])(this, "aabb", void 0);

    this.rayCast = new RayCast();
  }

  setRay(mouseX, mouseY, pMatrix, vMatrix, cameraPos) {
    mouseX = mouseX - GlTools["b" /* canvas */].getBoundingClientRect().left;
    mouseY = mouseY - GlTools["b" /* canvas */].getBoundingClientRect().top;
    let x = 2.0 * mouseX / GlTools["b" /* canvas */].clientWidth - 1.0;
    let y = 1.0 - 2.0 * mouseY / GlTools["b" /* canvas */].clientHeight;
    let z = 1.0;
    let rayNds = gl_matrix["e" /* vec3 */].fromValues(x, y, z);
    let rayClip = gl_matrix["f" /* vec4 */].fromValues(x, y, -1., 1.);
    let rayEye = gl_matrix["f" /* vec4 */].create();
    gl_matrix["b" /* mat4 */].invert(pMatrix, pMatrix);
    gl_matrix["b" /* mat4 */].multiply(rayEye, pMatrix, rayClip);
    rayEye = gl_matrix["f" /* vec4 */].fromValues(rayEye[0], rayEye[1], -1., 0.);

    let _rayWorld = gl_matrix["f" /* vec4 */].create();

    gl_matrix["b" /* mat4 */].invert(vMatrix, vMatrix);
    gl_matrix["b" /* mat4 */].multiply(_rayWorld, vMatrix, rayEye);
    let rayWorld = gl_matrix["e" /* vec3 */].fromValues(_rayWorld[0], _rayWorld[1], _rayWorld[2]);
    this.ray = new Geometry3D_Ray(cameraPos, gl_matrix["e" /* vec3 */].normalize(rayWorld, rayWorld));
  }

  castRay(vertices, type = 'AABB') {
    let result = false;

    if (type == 'AABB') {
      this.boundingVolume(vertices);
      result = this.rayCast.rayAABB(this.aabb, this.ray);
    }

    return result;
  }

  boundingVolume(vertices, type = 'AABB') {
    let minX, maxX, minY, maxY, minZ, maxZ;
    let sphereCenter, sphereRadius, boundMin, boundMax;

    for (let i = 0; i < vertices.length; i++) {
      if (vertices[i][0] > maxX || !maxX) maxX = vertices[i][0];
      if (vertices[i][0] < minX || !minX) minX = vertices[i][0];
      if (vertices[i][1] > maxY || !maxY) maxY = vertices[i][1];
      if (vertices[i][1] < minY || !minY) minY = vertices[i][1];
      if (vertices[i][2] > maxZ || !maxZ) maxZ = vertices[i][2];
      if (vertices[i][2] < minZ || !minZ) minZ = vertices[i][2];
    }

    sphereCenter = [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2, minZ + (maxZ - minZ) / 2];
    sphereRadius = Math.max((maxX - minX) / 2, (maxY - minY) / 2, (maxZ - minZ) / 2);
    boundMin = gl_matrix["e" /* vec3 */].fromValues(minX, minY, minZ);
    boundMax = gl_matrix["e" /* vec3 */].fromValues(maxX, maxY, maxZ);

    if (type == 'sphere') {} else if (type == 'AABB') {
      let box = new Geometry3D_AABB().fromMinMax(boundMin, boundMax);
      this.aabb = box;
      return {
        position: box.position,
        index: box.index,
        texCoord: box.texCoord
      };
    }
  }

}
// EXTERNAL MODULE: ./libs/Geom.js
var Geom = __webpack_require__(8);

// CONCATENATED MODULE: ./src/js/OpenGL/Mask.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mask_Mask; });










function transformPosition(vertices, mMatrix) {
  let t1;
  let result = [];

  for (let i = 0; i < vertices.length; i++) {
    t1 = gl_matrix["f" /* vec4 */].fromValues(vertices[i][0], vertices[i][1], vertices[i][2], 1);
    let t = gl_matrix["f" /* vec4 */].create();
    gl_matrix["f" /* vec4 */].transformMat4(t, t1, mMatrix);
    let tmp = Array(...t).splice(0, 3, 1);
    result.push(tmp);
  }

  return result;
}

class Mask_Mask extends PipeLine["default"] {
  constructor() {
    super();
  }

  init() {
    this.outlinePrg = this.compile(mask_default.a, maskOutline_default.a);
    this.prg = this.compile(mask_default.a, shaders_mask_default.a);
    GlTools["c" /* gl */].cullFace(GlTools["c" /* gl */].BACK);
    this._drawCube = this._drawCube.bind(this);
    this._drawTorus = this._drawTorus.bind(this);
    this.intersect = new Intersect_Intersect();
  }

  attrib() {
    this.cube = Geom["a" /* default */].cube(1);
    this.torus = Object(Torus["Torus"])(64, 64, .1, .4);
    /* bounding mesh
        let torusAABB = this.intersect.boundingVolume(pos)
        this.torusFrame = new Mesh()
        this.torusFrame.bufferVertex(torusAABB.position)
        this.torusFrame.bufferTexCoord(torusAABB.texCoord)
        this.torusFrame.bufferIndex(torusAABB.index)
    
        let cubeAABB = this.intersect.boundingVolume(spliceCube(CubeData))
        this.cubeFrame = new Mesh()
        this.cubeFrame.bufferVertex(cubeAABB.position)
        this.cubeFrame.bufferTexCoord(cubeAABB.texCoord)
        this.cubeFrame.bufferIndex(cubeAABB.index)
    */

    this.texture = getAssets.splash;
    this.texture.bind();
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_2D, GlTools["c" /* gl */].TEXTURE_MAG_FILTER, GlTools["c" /* gl */].LINEAR);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_2D, GlTools["c" /* gl */].TEXTURE_MIN_FILTER, GlTools["c" /* gl */].NEAREST_MIPMAP_NEAREST);
    GlTools["c" /* gl */].generateMipmap(GlTools["c" /* gl */].TEXTURE_2D);
    GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_2D, null);
  }

  _setGUI() {
    this.addGUIParams({
      lod: 1.,
      LINEAR_MIPMAP_LINEAR: false,
      NEAREST_MIPMAP_NEAREST: true
    });
    let folder = this.gui.addFolder('tetxureLod lod param');
    folder.add(this.params, 'lod', 1., Math.log2(512)).step(1.);
    folder.open();
    let folder1 = this.gui.addFolder('TEXTURE_MIN_FILTER');
    folder1.add(this.params, 'LINEAR_MIPMAP_LINEAR').listen().onChange(() => {
      this.setChecked('LINEAR_MIPMAP_LINEAR');
    });
    folder1.add(this.params, 'NEAREST_MIPMAP_NEAREST').listen().onChange(() => {
      this.setChecked('NEAREST_MIPMAP_NEAREST');
    });
    folder1.open();
  }

  setChecked(val) {
    this.texture.bind();
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_2D, GlTools["c" /* gl */].TEXTURE_MIN_FILTER, GlTools["c" /* gl */][val]);
    this.params.LINEAR_MIPMAP_LINEAR = false;
    this.params.NEAREST_MIPMAP_NEAREST = false;
    this.params[val] = true;
  }

  prepare() {
    GlTools["c" /* gl */].enable(GlTools["c" /* gl */].DEPTH_TEST);
    GlTools["c" /* gl */].depthFunc(GlTools["c" /* gl */].LESS);
    GlTools["c" /* gl */].enable(GlTools["c" /* gl */].STENCIL_TEST);
    GlTools["c" /* gl */].stencilFunc(GlTools["c" /* gl */].NOTEQUAL, 1, 0xff);
    GlTools["c" /* gl */].stencilOp(GlTools["c" /* gl */].KEEP, GlTools["c" /* gl */].KEEP, GlTools["c" /* gl */].REPLACE);
    this.camera.setProj(60, .1, 100);
  }

  uniform() {
    let pMatrix = gl_matrix["b" /* mat4 */].clone(this.camera.projMatrix);
    let vMatrix = gl_matrix["b" /* mat4 */].clone(this.camera.viewMatrix);
    this.intersect.setRay(this.mousePos.x, this.mousePos.y, pMatrix, vMatrix, this.camera.position);
  }

  render() {
    GlTools["c" /* gl */].clearColor(0.3, 0.3, .3, 1.0);
    GlTools["c" /* gl */].clearDepth(1.0);
    GlTools["c" /* gl */].clear(GlTools["c" /* gl */].COLOR_BUFFER_BIT | GlTools["c" /* gl */].DEPTH_BUFFER_BIT | GlTools["c" /* gl */].STENCIL_BUFFER_BIT);
    GlTools["c" /* gl */].stencilMask(0x00); //写入0

    let mMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create()); // translate 之后鼠标放在cube水平中心点很远的地方也能触发outline，这是个bug,原因是boundingbox计算有问题，初始minX，maxX这些值为0，0实际上已经是一个值了
    // 应该换成循环的第一个值为min和max，而不是0

    gl_matrix["b" /* mat4 */].translate(mMatrix, mMatrix, [-2.5, 0, 0]);

    if (this.intersect.castRay(transformPosition(this.cube.vertices, mMatrix))) {
      this.renderOutline(mMatrix, this._drawCube);
    } else this.renderDefault(mMatrix, this._drawCube);

    mMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    gl_matrix["b" /* mat4 */].translate(mMatrix, mMatrix, [2., 0, 0]);

    if (this.intersect.castRay(transformPosition(this.torus.vertices, mMatrix))) {
      this.renderOutline(mMatrix, this._drawTorus);
    } else this.renderDefault(mMatrix, this._drawTorus);
    /*draw boundingVolume
        mMatrix = mat4.create()
        mat4.translate(mMatrix, mMatrix, [1.5, 0, 0])
        this.prg.use()
        mat4.multiply(this.mvpMatrix, this.tmpMatrix, mMatrix)
        this.prg.style({
          mvpMatrix: this.mvpMatrix,
          texture: 0,
          lod: this.params.lod
        })
        this.torusFrame.bind(this.prg, ['position', 'texCoord'])
        this.torusFrame.draw(3)
    
        mMatrix = mat4.create()
        mat4.scale(mMatrix, mMatrix, [.6, .6, .6])
        mat4.translate(mMatrix, mMatrix, [-2.05, 0, 0])
        mat4.multiply(this.mvpMatrix, this.tmpMatrix, mMatrix)
        this.prg.style({
          mvpMatrix: this.mvpMatrix,
          texture: 0,
          lod: this.params.lod
        })
        this.cubeFrame.bind(this.prg, ['position', 'texCoord'])
        this.cubeFrame.draw(3)
    */

  }

  renderDefault(mMatrix, draw) {
    this.prg.use();
    this.prg.style({
      texture: this.texture,
      uModelMatrix: mMatrix,
      lod: this.params.lod
    });
    draw();
  }

  renderOutline(mMatrix, draw) {
    GlTools["c" /* gl */].stencilFunc(GlTools["c" /* gl */].ALWAYS, 1, 0xff);
    GlTools["c" /* gl */].stencilMask(0xff); //写入1

    this.renderDefault(mMatrix, draw);
    GlTools["c" /* gl */].stencilFunc(GlTools["c" /* gl */].NOTEQUAL, 1, 0xff); //不等于1的才能通过测试

    GlTools["c" /* gl */].stencilMask(0x00); //写入0

    const scale = 1.1;
    gl_matrix["b" /* mat4 */].scale(mMatrix, mMatrix, [scale, scale, scale]);
    this.outlinePrg.use();
    this.outlinePrg.style({
      uModelMatrix: mMatrix
    });
    draw();
  }

  _drawCube() {
    GlTools["a" /* GlTools */].draw(this.cube, true);
  }

  _drawTorus() {
    GlTools["a" /* GlTools */].draw(this.torus, true);
  }

}__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(2);

// EXTERNAL MODULE: ./src/js/PipeLine.js + 1 modules
var PipeLine = __webpack_require__(5);

// EXTERNAL MODULE: ./src/shaders/bloom/bloom.vert
var bloom = __webpack_require__(67);
var bloom_default = /*#__PURE__*/__webpack_require__.n(bloom);

// EXTERNAL MODULE: ./src/shaders/bloom/bloom.frag
var bloom_bloom = __webpack_require__(68);
var bloom_bloom_default = /*#__PURE__*/__webpack_require__.n(bloom_bloom);

// EXTERNAL MODULE: ./src/shaders/bloom/blur.frag
var bloom_blur = __webpack_require__(69);
var blur_default = /*#__PURE__*/__webpack_require__.n(bloom_blur);

// EXTERNAL MODULE: ./src/shaders/bloom/bloom_final.frag
var bloom_final = __webpack_require__(70);
var bloom_final_default = /*#__PURE__*/__webpack_require__.n(bloom_final);

// EXTERNAL MODULE: ./node_modules/gl-matrix/src/gl-matrix.js + 7 modules
var gl_matrix = __webpack_require__(1);

// EXTERNAL MODULE: ./libs/GlTools.js
var GlTools = __webpack_require__(0);

// EXTERNAL MODULE: ./libs/Geom.js
var Geom = __webpack_require__(8);

// EXTERNAL MODULE: ./libs/shaders/CustomShaders.js
var CustomShaders = __webpack_require__(13);

// EXTERNAL MODULE: ./libs/GLTexture.js + 2 modules
var GLTexture = __webpack_require__(14);

// EXTERNAL MODULE: ./libs/utils/WebglNumber.js
var WebglNumber = __webpack_require__(20);

// CONCATENATED MODULE: ./libs/FrameBuffer.js
// FrameBuffer.js



let webglDepthTexture;
let hasCheckedMultiRenderSupport = false;
let extDrawBuffer;

const checkMultiRender = function () {
  if (window.useWebgl2) {
    return true;
  } else {
    extDrawBuffer = GlTools["c" /* gl */].getExtension('WEBGL_draw_buffers');
    return !!extDrawBuffer;
  }

  hasCheckedMultiRenderSupport = true;
};

class FrameBuffer_FrameBuffer {
  constructor(mWidth, mHeight, mParameters = {}, mNumTargets = 1) {
    webglDepthTexture = !window.useWebgl2 && GlTools["c" /* gl */].getExtension('WEBGL_depth_texture');
    this.width = mWidth;
    this.height = mHeight;
    this._numTargets = mNumTargets;
    this._multipleTargets = mNumTargets > 1;
    this._parameters = mParameters;

    if (!hasCheckedMultiRenderSupport) {
      checkMultiRender();
    }

    if (this._multipleTargets) {
      this._checkMaxNumRenderTarget();
    }

    this._init();
  }

  _init() {
    this._initTextures();

    this.frameBuffer = GlTools["c" /* gl */].createFramebuffer();
    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, this.frameBuffer);

    if (window.useWebgl2) {
      let depthRenderBuffer = GlTools["c" /* gl */].createRenderbuffer();
      GlTools["c" /* gl */].bindRenderbuffer(GlTools["c" /* gl */].RENDERBUFFER, depthRenderBuffer);
      GlTools["c" /* gl */].renderbufferStorage(GlTools["c" /* gl */].RENDERBUFFER, GlTools["c" /* gl */].DEPTH24_STENCIL8, this.width, this.height);
      GlTools["c" /* gl */].framebufferRenderbuffer(GlTools["c" /* gl */].FRAMEBUFFER, GlTools["c" /* gl */].DEPTH_ATTACHMENT, GlTools["c" /* gl */].RENDERBUFFER, depthRenderBuffer);
      const buffers = [];

      for (let i = 0; i < this._numTargets; i++) {
        GlTools["c" /* gl */].framebufferTexture2D(GlTools["c" /* gl */].DRAW_FRAMEBUFFER, GlTools["c" /* gl */].COLOR_ATTACHMENT0 + i, GlTools["c" /* gl */].TEXTURE_2D, this._textures[i].texture, 0);
        buffers.push(GlTools["c" /* gl */][`COLOR_ATTACHMENT${i}`]);
      }

      GlTools["c" /* gl */].drawBuffers(buffers); //gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
    } else {
      for (let i = 0; i < this._numTargets; i++) {
        GlTools["c" /* gl */].framebufferTexture2D(GlTools["c" /* gl */].FRAMEBUFFER, GlTools["c" /* gl */].COLOR_ATTACHMENT0 + i, GlTools["c" /* gl */].TEXTURE_2D, this._textures[i].texture, 0);
      }

      if (this._multipleTargets) {
        const drawBuffers = [];

        for (let i = 0; i < this._numTargets; i++) {
          drawBuffers.push(extDrawBuffer[`COLOR_ATTACHMENT${i}_WEBGL`]);
        }

        extDrawBuffer.drawBuffersWEBGL(drawBuffers);
      }

      if (webglDepthTexture) {
        GlTools["c" /* gl */].framebufferTexture2D(GlTools["c" /* gl */].FRAMEBUFFER, GlTools["c" /* gl */].DEPTH_ATTACHMENT, GlTools["c" /* gl */].TEXTURE_2D, this.glDepthTexture.texture, 0);
      }
    } //	CHECKING FBO
    // const FBOstatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    // if(FBOstatus != gl.FRAMEBUFFER_COMPLETE) {
    // 	console.error('GL_FRAMEBUFFER_COMPLETE failed, CANNOT use Framebuffer', WebglNumber[FBOstatus]);
    // }
    //	UNBIND


    GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_2D, null);
    GlTools["c" /* gl */].bindRenderbuffer(GlTools["c" /* gl */].RENDERBUFFER, null);
    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, null); //	CLEAR FRAMEBUFFER 
    //this.clear();
  }

  _checkMaxNumRenderTarget() {
    const maxNumDrawBuffers = window.useWebgl2 ? GlTools["c" /* gl */].getParameter(GlTools["c" /* gl */].MAX_DRAW_BUFFERS) : GlTools["c" /* gl */].getParameter(extDrawBuffer.MAX_DRAW_BUFFERS_WEBGL);

    if (this._numTargets > maxNumDrawBuffers) {
      console.error('Over max number of draw buffers supported : ', maxNumDrawBuffers);
      this._numTargets = maxNumDrawBuffers;
    }
  }

  _initTextures() {
    this._textures = [];

    for (let i = 0; i < this._numTargets; i++) {
      const glt = this._createTexture();

      this._textures.push(glt);
    } // if(window.useWebgl2) { 
    // 	this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);
    // } else {
    // 	this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, { minFilter:gl.LINEAR });
    // }

  }

  _createTexture(mInternalformat, mTexelType, mFormat, mParameters = {}) {
    const parameters = Object.assign({}, this._parameters);
    parameters.internalFormat = mInternalformat || parameters.internalFormat;
    parameters.format = mFormat || parameters.format || GlTools["c" /* gl */].RGBA;
    parameters.type = mTexelType || parameters.type || GlTools["c" /* gl */].UNSIGNED_BYTE;

    for (const s in mParameters) {
      parameters[s] = mParameters[s];
    }

    const texture = new GLTexture["a" /* default */](null, parameters, this.width, this.height);
    return texture;
  } //	PUBLIC METHODS


  bind(mAutoSetViewport = true) {
    if (mAutoSetViewport) {
      GlTools["c" /* gl */].viewport(0, 0, this.width, this.height);
    }

    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, this.frameBuffer);
  }

  unbind(mAutoSetViewport = true) {
    if (mAutoSetViewport) {
      GlTools["c" /* gl */].viewport(0, 0, GlTools["c" /* gl */].width, GlTools["c" /* gl */].height);
    }

    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, null);

    this._textures.forEach(texture => {
      texture.generateMipmap();
    });
  }

  clear(r = 0, g = 0, b = 0, a = 0) {
    this.bind();
    GlTools["a" /* GlTools */].clear(r, g, b, a);
    this.unbind();
  } //	TEXTURES


  get textures() {
    return this._textures;
  }

  getDepthTexture() {
    return this.glDepthTexture;
  } //	TOUGHTS : Should I remove these from frame buffer ? 
  //	Shouldn't these be set individually to each texture ? 
  //	e.g. fbo.getTexture(0).minFilter = gl.NEAREST;
  //		 fbo.getTexture(1).minFilter = gl.LINEAR; ... etc ? 
  //	MIPMAP FILTER


  get minFilter() {
    return this._textures[0].minFilter;
  }

  set minFilter(mValue) {
    this._textures.forEach(texture => {
      texture.minFilter = mValue;
    });
  }

  get magFilter() {
    return this._textures[0].magFilter;
  }

  set magFilter(mValue) {
    this._textures.forEach(texture => {
      texture.magFilter = mValue;
    });
  } //	WRAPPING


  get wrapS() {
    return this._textures[0].wrapS;
  }

  set wrapS(mValue) {
    this._textures.forEach(texture => {
      texture.wrapS = mValue;
    });
  }

  get wrapT() {
    return this._textures[0].wrapT;
  }

  set wrapT(mValue) {
    this._textures.forEach(texture => {
      texture.wrapT = mValue;
    });
  } //	UTILS


  showParameters() {
    this._textures[0].showParameters();
  }

  get numTargets() {
    return this._numTargets;
  }

}

/* harmony default export */ var libs_FrameBuffer = (FrameBuffer_FrameBuffer);
// CONCATENATED MODULE: ./src/js/AdvancedLight/Bloom.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bloom_Bloom; });











class Bloom_Bloom extends PipeLine["default"] {
  constructor() {
    super();

    Object(defineProperty["a" /* default */])(this, "count", 0);

    GlTools["c" /* gl */].getExtension("EXT_color_buffer_float");
  }

  init() {
    this.prg = this.compile(bloom_default.a, bloom_bloom_default.a);
    this.blurPrg = this.compile(CustomShaders["a" /* default */].bigTriangleVert, blur_default.a);
    this.finalPrg = this.compile(CustomShaders["a" /* default */].bigTriangleVert, bloom_final_default.a);
  }

  attrib() {
    this.statue = Geom["a" /* default */].cube(1);
    this.quad = Geom["a" /* default */].bigTriangle();
  }

  prepare() {
    this.camera.radius = 3.5;
    let fbo = new libs_FrameBuffer(GlTools["b" /* canvas */].width, GlTools["b" /* canvas */].height, {
      internalFormat: GlTools["c" /* gl */].RGBA16F,
      type: GlTools["c" /* gl */].FLOAT
    }, 2);
    this.hdrFbo = fbo.frameBuffer;
    this.textures = fbo.textures;
    let {
      pingpongFBO,
      pingpongColorbuffers
    } = pingpongFrameBuffer(GlTools["b" /* canvas */].width, GlTools["b" /* canvas */].height);
    this.pingpongFBO = pingpongFBO;
    this.pingpongColorbuffers = pingpongColorbuffers;
    GlTools["c" /* gl */].disable(GlTools["c" /* gl */].DEPTH_TEST);
    GlTools["c" /* gl */].enable(GlTools["c" /* gl */].BLEND);
    GlTools["c" /* gl */].blendFunc(GlTools["c" /* gl */].SRC_ALPHA, GlTools["c" /* gl */].ONE_MINUS_SRC_ALPHA);
  }

  _setGUI() {
    this.addGUIParams({
      texOffsetScale: 1,
      blurPassCount: 20,
      lightScale: 1,
      uAlpha: .5
    });
    this.gui.add(this.params, 'texOffsetScale', 0, 4).step(.02);
    this.gui.add(this.params, 'blurPassCount', 1, 40).step(1);
    this.gui.add(this.params, 'lightScale', .1, 10).step(.1);
    this.gui.add(this.params, 'uAlpha', 0, 1.0).step(.1);
  }

  uniform() {
    let mMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    let invMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    gl_matrix["b" /* mat4 */].invert(invMatrix, mMatrix);
  }

  renderScene() {
    let a = [10, 10, 10];
    let b = a.map(x => x * this.params.lightScale);
    this.prg.use();
    this.prg.style({
      'lights[0].Position': [1.5, 0, 0],
      'lights[0].Color': b,
      'lights[1].Position': [-1.5, 0, 0],
      'lights[1].Color': b,
      'lights[2].Position': [0, 1.5, -2],
      'lights[2].Color': b,
      'lights[3].Position': [0, 0, 2.],
      'lights[3].Color': [10, 20, 10],
      'lights[4].Position': [0, -1.5, 0.],
      'lights[4].Color': [100, 20, 10],
      baseColor: [0., 0.3, 0.3],
      uAlpha: this.params.uAlpha
    });
    this.statue.rotationY = 12;
    GlTools["a" /* GlTools */].draw(this.statue);
  }

  render() {
    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, this.hdrFbo);
    GlTools["a" /* GlTools */].clear(0, 0, 0);
    GlTools["c" /* gl */].cullFace(GlTools["c" /* gl */].FRONT);
    this.renderScene();
    GlTools["c" /* gl */].cullFace(GlTools["c" /* gl */].BACK);
    this.renderScene();
    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, null);
    this.blurPrg.use();
    let horizontal = true,
        first_iteration = true,
        amount = this.params.blurPassCount;

    for (let i = 0; i < amount; i++) {
      GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, this.pingpongFBO[Number(horizontal)]);

      if (first_iteration) {
        this.textures[1].bind();
      } else GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_2D, this.pingpongColorbuffers[Number(!horizontal)]);

      this.blurPrg.uniform('image', 'uniform1i', 0);
      this.blurPrg.style({
        horizontal,
        texOffsetScale: this.params.texOffsetScale
      });
      GlTools["a" /* GlTools */].draw(this.quad);
      horizontal = !horizontal;
      if (first_iteration) first_iteration = false;
    }

    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, null);
    GlTools["a" /* GlTools */].clear(0, 0, 0);
    this.finalPrg.use();
    this.textures[0].bind(0);
    GlTools["c" /* gl */].activeTexture(GlTools["c" /* gl */].TEXTURE1);
    GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_2D, this.pingpongColorbuffers[1]);
    this.finalPrg.uniform('scene', 'uniform1i', 0);
    this.finalPrg.uniform('bloomBlur', 'uniform1i', 1);
    this.finalPrg.style({
      bloom: true,
      exposure: .1
    });
    GlTools["a" /* GlTools */].draw(this.quad);
  }

}

function pingpongFrameBuffer(width, height) {
  const pingpongFBO = [];
  const pingpongColorbuffers = [];

  for (let i = 0; i < 2; i++) {
    pingpongFBO[i] = GlTools["c" /* gl */].createFramebuffer();
    pingpongColorbuffers[i] = GlTools["c" /* gl */].createTexture();
    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, pingpongFBO[i]);
    GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_2D, pingpongColorbuffers[i]);
    GlTools["c" /* gl */].texImage2D(GlTools["c" /* gl */].TEXTURE_2D, 0, GlTools["c" /* gl */].RGBA16F, width, height, 0, GlTools["c" /* gl */].RGBA, GlTools["c" /* gl */].FLOAT, null);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_2D, GlTools["c" /* gl */].TEXTURE_MAG_FILTER, GlTools["c" /* gl */].LINEAR);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_2D, GlTools["c" /* gl */].TEXTURE_MIN_FILTER, GlTools["c" /* gl */].LINEAR);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_2D, GlTools["c" /* gl */].TEXTURE_WRAP_S, GlTools["c" /* gl */].CLAMP_TO_EDGE);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_2D, GlTools["c" /* gl */].TEXTURE_WRAP_T, GlTools["c" /* gl */].CLAMP_TO_EDGE);
    GlTools["c" /* gl */].framebufferTexture2D(GlTools["c" /* gl */].FRAMEBUFFER, GlTools["c" /* gl */].COLOR_ATTACHMENT0, GlTools["c" /* gl */].TEXTURE_2D, pingpongColorbuffers[i], 0);
  }

  GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, null);
  return {
    pingpongFBO,
    pingpongColorbuffers
  };
}__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(2);

// EXTERNAL MODULE: ./libs/GLShader.js
var GLShader = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/gl-matrix/src/gl-matrix.js + 7 modules
var gl_matrix = __webpack_require__(1);

// EXTERNAL MODULE: ./libs/GlTools.js
var GlTools = __webpack_require__(0);

// CONCATENATED MODULE: ./libs/cameras/Camera.js


 // cameraFront = -(cameraPos - camraTarget)

const getMouse = function (mEvent, mTarget, finger2) {
  const o = mTarget || {};

  if (mEvent.touches && !finger2) {
    o.x = mEvent.touches[0].pageX;
    o.y = mEvent.touches[0].pageY;
  } else if (!mEvent.touches) {
    o.x = mEvent.clientX;
    o.y = mEvent.clientY;
  } else if (mEvent.touches && finger2) {
    o.x = mEvent.touches[1].pageX;
    o.y = mEvent.touches[1].pageY;
  }

  return o;
};

const MIN_DIFF = 0.0001;
class Camera_Camrea {
  constructor(position = [0, 0, 0], up = [0, 1, 0]) {
    Object(defineProperty["a" /* default */])(this, "cameraPos", void 0);

    Object(defineProperty["a" /* default */])(this, "up", void 0);

    Object(defineProperty["a" /* default */])(this, "cameraFront", [0, 0, -1]);

    Object(defineProperty["a" /* default */])(this, "_mouse", {});

    Object(defineProperty["a" /* default */])(this, "_preMouse", {});

    Object(defineProperty["a" /* default */])(this, "_mousedown", false);

    Object(defineProperty["a" /* default */])(this, "_rx", 0);

    Object(defineProperty["a" /* default */])(this, "_ry", 0);

    Object(defineProperty["a" /* default */])(this, "_preRx", 0);

    Object(defineProperty["a" /* default */])(this, "_preRy", 0);

    Object(defineProperty["a" /* default */])(this, "_targetRx", 0);

    Object(defineProperty["a" /* default */])(this, "_targetRy", 0);

    Object(defineProperty["a" /* default */])(this, "_viewMatrix", gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create()));

    Object(defineProperty["a" /* default */])(this, "_width", GlTools["b" /* canvas */].width);

    Object(defineProperty["a" /* default */])(this, "_height", GlTools["b" /* canvas */].height);

    Object(defineProperty["a" /* default */])(this, "sensitivity", 1.);

    Object(defineProperty["a" /* default */])(this, "target", [0, 0, 0]);

    Object(defineProperty["a" /* default */])(this, "offset", [0, 0, 0]);

    Object(defineProperty["a" /* default */])(this, "radius", 5);

    Object(defineProperty["a" /* default */])(this, "_targetRadius", 5);

    Object(defineProperty["a" /* default */])(this, "_updateWheel", false);

    this.position = position;
    this.up = up;
    this.projMatrix = gl_matrix["b" /* mat4 */].create();
    gl_matrix["b" /* mat4 */].perspective(this.projMatrix, Object(GlTools["d" /* toRadian */])(45), GlTools["b" /* canvas */].clientWidth / GlTools["b" /* canvas */].clientHeight, .1, 100);

    this._addEvents();
  }

  setProj(fov, near, far) {
    gl_matrix["b" /* mat4 */].perspective(this.projMatrix, Object(GlTools["d" /* toRadian */])(fov), GlTools["b" /* canvas */].clientWidth / GlTools["b" /* canvas */].clientHeight, near, far);
  }

  _addEvents() {
    GlTools["b" /* canvas */].addEventListener('mousedown', e => this._down(e));
    GlTools["b" /* canvas */].addEventListener('mousemove', e => this._move(e));
    document.addEventListener('mouseup', e => this._up(e));
    GlTools["b" /* canvas */].addEventListener('mousewheel', e => this._onWheel(e));
    GlTools["b" /* canvas */].addEventListener('DOMMouseScroll', e => this._onWheel(e));
  }

  _down(mEvent) {
    this._mousedown = true;
    getMouse(mEvent, this._mouse);
    getMouse(mEvent, this._preMouse); // reset 重新开始计算

    this._preRx = this._targetRx;
    this._preRy = this._targetRy;
  }

  _move(mEvent) {
    if (this._mousedown) {
      getMouse(mEvent, this._mouse);
      let diffX = (this._mouse.x - this._preMouse.x) / this._width;
      let diffY = (this._mouse.y - this._preMouse.y) / this._height;
      this._targetRx = this._preRx + diffX * Math.PI * 2 * this.sensitivity;
      this._targetRy = this._preRy + diffY * Math.PI * this.sensitivity;
    }
  }

  _up(mEvent) {
    this._mousedown = false;
  }

  updateMatrix() {
    this._rx += (this._targetRx - this._rx) * 0.1; //ease out

    if (Math.abs(this._targetRx - this._rx) < MIN_DIFF) {
      this._rx = this._targetRx;
    }

    this._ry += (this._targetRy - this._ry) * 0.1; //ease out

    if (Math.abs(this._targetRy - this._ry) < MIN_DIFF) {
      this._ry = this._targetRy;
    } // or use scheduling to add EF


    if (this._updateWheel) {
      this.radius += (this._targetRadius - this.radius) * 0.1; //ease out

      if (Math.abs(this._targetRadius - this.radius) < MIN_DIFF) {
        this.radius = this._targetRadius;
      }
    }

    this.position[1] = Math.sin(this._ry) * this.radius;
    let tr = Math.abs(Math.cos(this._ry) * this.radius); // 防止y突然从1变成-1，x，z的象限变化

    this.position[0] = Math.cos(this._rx + Math.PI * 0.5) * tr;
    this.position[2] = Math.sin(this._rx + Math.PI * 0.5) * tr; //mat4.lookAt(mat4.create(), this.position, this.position + this.cameraFront, this.up)

    this.position = [this.position[0] + this.offset[0], this.position[1] + this.offset[1], this.position[2] + this.offset[2]];
    gl_matrix["b" /* mat4 */].lookAt(this._viewMatrix, this.position, this.target, this.up);
  }

  _onWheel(mEvent) {
    const w = mEvent.wheelDelta;
    const d = mEvent.detail;
    let value = 0;

    if (d) {
      if (w) {
        value = w / d / 40 * d > 0 ? 1 : -1; // Opera
      } else {
        value = -d / 3; // Firefox;         TODO: do not /3 for OS X
      }
    } else {
      value = w / 120;
    }

    this._targetRadius = this.radius + -value * 1;
    if (this._targetRadius <= 1) this._targetRadius = 1;
    this._updateWheel = true;
  }

  get viewMatrix() {
    return this._viewMatrix;
  } // 设置旋转角度


  set rx(value) {
    this._targetRx = value;
  }

}
// EXTERNAL MODULE: ./node_modules/dat.gui/build/dat.gui.module.js
var dat_gui_module = __webpack_require__(43);

// CONCATENATED MODULE: ./src/js/PipeLine.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PipeLine_Pipeline; });






class PipeLine_Pipeline {
  constructor() {
    Object(defineProperty["a" /* default */])(this, "rotateQ", gl_matrix["c" /* quat */].create());

    Object(defineProperty["a" /* default */])(this, "mousePos", {
      x: 0,
      y: 0
    });

    Object(defineProperty["a" /* default */])(this, "camera", new Camera_Camrea());

    Object(defineProperty["a" /* default */])(this, "pMatrix", gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create()));

    Object(defineProperty["a" /* default */])(this, "mvpMatrix", gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create()));

    Object(defineProperty["a" /* default */])(this, "tmpMatrix", gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create()));

    Object(defineProperty["a" /* default */])(this, "_params", {});

    Object(defineProperty["a" /* default */])(this, "gui", new dat_gui_module["a" /* GUI */]({
      width: 300
    }));

    this.vMatrix = this.camera.viewMatrix;
    GlTools["a" /* GlTools */].setCamera(this.camera);
    this.init();
    this.attrib();
    this.prepare();

    this._setGUI();

    this._animate = this.animate.bind(this);
    GlTools["c" /* gl */].enable(GlTools["c" /* gl */].DEPTH_TEST);
    GlTools["c" /* gl */].depthFunc(GlTools["c" /* gl */].LEQUAL);
    GlTools["c" /* gl */].enable(GlTools["c" /* gl */].CULL_FACE);
  }

  init() {}

  compile(vs, fs) {
    let prg = new GLShader["a" /* default */](vs, fs);
    return prg;
  }

  attrib() {}

  uniform() {}

  prepare() {}

  animate() {
    requestAnimationFrame(this._animate);
    this.camera.updateMatrix();
    this.uniform();
    this.render();
  }

  render() {}

  play() {
    this.animate();
  }

  _setGUI() {// this.addGUIParams({
    //   lt: 0.2,
    //   gt: 0.98,
    //   clamp: false
    // })
    // let folder = gui.addFolder('grayFocus')
    // folder.add(this.params, 'lt', 0, 1).step(0.01)
    // folder.add(this.params, 'gt', 0, 1).step(0.01)
    // folder.add(this.params, 'clamp')
    // folder.open()
  }

  addGUIParams(o) {
    return Object.assign(this._params, o);
  }

  get params() {
    return this._params;
  }

  set params(param) {
    throw Error("Params has no setter,please use addGUIParams");
  }

}__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread.js
var objectSpread = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(2);

// EXTERNAL MODULE: ./src/js/PipeLine.js + 1 modules
var PipeLine = __webpack_require__(5);

// EXTERNAL MODULE: ./libs/GlTools.js
var GlTools = __webpack_require__(0);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/pbr_ibl.vert
var pbr_ibl = __webpack_require__(120);
var pbr_ibl_default = /*#__PURE__*/__webpack_require__.n(pbr_ibl);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/pbr_ibl.frag
var ibl_diffuse_pbr_ibl = __webpack_require__(121);
var ibl_diffuse_pbr_ibl_default = /*#__PURE__*/__webpack_require__.n(ibl_diffuse_pbr_ibl);

// EXTERNAL MODULE: ./src/shaders/pbr/pbr_map.vert
var pbr_map = __webpack_require__(32);
var pbr_map_default = /*#__PURE__*/__webpack_require__.n(pbr_map);

// EXTERNAL MODULE: ./src/shaders/pbr/pbr_map.frag
var pbr_pbr_map = __webpack_require__(33);
var pbr_pbr_map_default = /*#__PURE__*/__webpack_require__.n(pbr_pbr_map);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/cubemap.vert
var cubemap = __webpack_require__(42);
var cubemap_default = /*#__PURE__*/__webpack_require__.n(cubemap);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/equirectangular_to_cubemap.frag
var equirectangular_to_cubemap = __webpack_require__(122);
var equirectangular_to_cubemap_default = /*#__PURE__*/__webpack_require__.n(equirectangular_to_cubemap);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/skybox.vert
var skybox = __webpack_require__(123);
var skybox_default = /*#__PURE__*/__webpack_require__.n(skybox);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/skybox.frag
var ibl_diffuse_skybox = __webpack_require__(124);
var ibl_diffuse_skybox_default = /*#__PURE__*/__webpack_require__.n(ibl_diffuse_skybox);

// EXTERNAL MODULE: ./src/shaders/ibl_diffuse/irradiance_convolution.frag
var irradiance_convolution = __webpack_require__(125);
var irradiance_convolution_default = /*#__PURE__*/__webpack_require__.n(irradiance_convolution);

// EXTERNAL MODULE: ./libs/glBuffer.js
var glBuffer = __webpack_require__(11);

// EXTERNAL MODULE: ./libs/vao.js
var vao = __webpack_require__(15);
var vao_default = /*#__PURE__*/__webpack_require__.n(vao);

// EXTERNAL MODULE: ./src/js/Torus.js
var Torus = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/gl-matrix/src/gl-matrix.js + 7 modules
var gl_matrix = __webpack_require__(1);

// EXTERNAL MODULE: ./libs/Mesh.js + 1 modules
var Mesh = __webpack_require__(3);

// EXTERNAL MODULE: ./libs/glTexture.js
var glTexture = __webpack_require__(4);
var glTexture_default = /*#__PURE__*/__webpack_require__.n(glTexture);

// EXTERNAL MODULE: ./libs/loaders/HDRParser.js
var HDRParser = __webpack_require__(9);

// EXTERNAL MODULE: ./libs/GLCubeTexture.js
var GLCubeTexture = __webpack_require__(12);

// CONCATENATED MODULE: ./libs/CubeFrameBuffer.js
// CubeFrameBuffer.js





class CubeFrameBuffer_CubeFrameBuffer {
  constructor(size, mParameters = {}) {
    this._size = size;
    this.magFilter = mParameters.magFilter || GlTools["c" /* gl */].LINEAR;
    this.minFilter = mParameters.minFilter || GlTools["c" /* gl */].LINEAR;
    this.wrapS = mParameters.wrapS || GlTools["c" /* gl */].CLAMP_TO_EDGE;
    this.wrapT = mParameters.wrapT || GlTools["c" /* gl */].CLAMP_TO_EDGE;

    this._init();
  }

  _init() {
    this.texture = GlTools["c" /* gl */].createTexture();
    this.glTexture = new GLCubeTexture["a" /* default */](this.texture, {}, true);
    GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, this.texture);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, GlTools["c" /* gl */].TEXTURE_MAG_FILTER, this.magFilter);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, GlTools["c" /* gl */].TEXTURE_MIN_FILTER, this.minFilter);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, GlTools["c" /* gl */].TEXTURE_WRAP_S, this.wrapS);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, GlTools["c" /* gl */].TEXTURE_WRAP_T, this.wrapT);
    const targets = [GlTools["c" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_X, GlTools["c" /* gl */].TEXTURE_CUBE_MAP_NEGATIVE_X, GlTools["c" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_Y, GlTools["c" /* gl */].TEXTURE_CUBE_MAP_NEGATIVE_Y, GlTools["c" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_Z, GlTools["c" /* gl */].TEXTURE_CUBE_MAP_NEGATIVE_Z];

    for (let i = 0; i < targets.length; i++) {
      GlTools["c" /* gl */].pixelStorei(GlTools["c" /* gl */].UNPACK_FLIP_Y_WEBGL, false);
      GlTools["c" /* gl */].texImage2D(targets[i], 0, GlTools["c" /* gl */].RGBA, this.width, this.height, 0, GlTools["c" /* gl */].RGBA, GlTools["c" /* gl */].FLOAT, null);
    }

    this._frameBuffers = [];

    for (let i = 0; i < targets.length; i++) {
      const frameBuffer = GlTools["c" /* gl */].createFramebuffer();
      GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, frameBuffer);
      GlTools["c" /* gl */].framebufferTexture2D(GlTools["c" /* gl */].FRAMEBUFFER, GlTools["c" /* gl */].COLOR_ATTACHMENT0, targets[i], this.texture, 0);
      const status = GlTools["c" /* gl */].checkFramebufferStatus(GlTools["c" /* gl */].FRAMEBUFFER);

      if (status !== GlTools["c" /* gl */].FRAMEBUFFER_COMPLETE) {
        console.log(`'gl.checkFramebufferStatus() returned '${status}`);
      }

      this._frameBuffers.push(frameBuffer);
    } // gl.generateMipmap(gl.TEXTURE_CUBE_MAP);


    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, null);
    GlTools["c" /* gl */].bindRenderbuffer(GlTools["c" /* gl */].RENDERBUFFER, null);
    GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, null);
  }

  bind(mTargetIndex) {
    // if(Math.random() > .99) console.log('bind :', mTargetIndex, this._frameBuffers[mTargetIndex]);
    GlTools["c" /* gl */].viewport(0, 0, this.width, this.height);
    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, this._frameBuffers[mTargetIndex]);
  }

  unbind() {
    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, null);
    GlTools["c" /* gl */].viewport(0, 0, GlTools["b" /* canvas */].width, GlTools["b" /* canvas */].height);
  } //	TEXTURES


  getTexture() {
    return this.glTexture;
  } //	GETTERS AND SETTERS


  get width() {
    return this._size;
  }

  get height() {
    return this._size;
  }

}

/* harmony default export */ var libs_CubeFrameBuffer = (CubeFrameBuffer_CubeFrameBuffer);
// CONCATENATED MODULE: ./src/js/Pbr/IblDiffuse.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IblDiffuse_IblDiffuse; });




















 //ibl diffuse即irradiance，为normal正交的平面上半球内所有方向的平均颜色微分

class IblDiffuse_IblDiffuse extends PipeLine["default"] {
  constructor() {
    super();

    Object(defineProperty["a" /* default */])(this, "count", 0);
  }

  init() {
    GlTools["c" /* gl */].getExtension('OES_standard_derivatives');
    GlTools["c" /* gl */].getExtension('OES_texture_float');
    GlTools["c" /* gl */].getExtension('OES_texture_float_linear'); // gl.getExtension('OES_texture_half_float')
    // gl.getExtension('OES_texture_half_float_linear')

    this.prg = this.compile(pbr_ibl_default.a, ibl_diffuse_pbr_ibl_default.a);
    this.mapPrg = this.compile(pbr_map_default.a, pbr_pbr_map_default.a);
    this.cubePrg = this.compile(cubemap_default.a, equirectangular_to_cubemap_default.a);
    this.skyboxPrg = this.compile(skybox_default.a, ibl_diffuse_skybox_default.a);
    this.irradiancePrg = this.compile(cubemap_default.a, irradiance_convolution_default.a);
  }

  attrib() {
    let {
      pos,
      index,
      normal,
      uv
    } = Object(Torus["Sphere"])(256, 256, .15);
    let sphere = new Mesh["a" /* default */]();
    sphere.bufferVertex(pos);
    sphere.bufferIndex(index);
    sphere.bufferNormal(normal);
    sphere.bufferTexCoord(uv);
    this.sphere = sphere;
    let cube = new Mesh["a" /* default */]();
    cube.bufferData(Torus["CubeData"], ['position', 'normal', 'texCoord'], [3, 3, 2]);
    this.cube = cube;
    let planeVertices = [// positions          // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat)
    3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, 3.0, 0.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, 3.0, 1.0, 0.0, -3.0, -0.5, -3.0, 0.0, 1.0, 3.0, -0.5, -3.0, 1.0, 1.0];
    this.planeBuffer = new glBuffer["a" /* ArrayBuffer */](GlTools["c" /* gl */], new Float32Array(planeVertices));
    this.planeBuffer.attrib('position', 3, GlTools["c" /* gl */].FLOAT);
    this.planeBuffer.attrib('texCoord', 2, GlTools["c" /* gl */].FLOAT);
    this.planeVao = new vao_default.a(GlTools["c" /* gl */]);
    this.planeVao.setup(this.cubePrg, [this.planeBuffer]);
  }

  prepare() {
    GlTools["c" /* gl */].enable(GlTools["c" /* gl */].DEPTH_TEST);
    GlTools["c" /* gl */].depthFunc(GlTools["c" /* gl */].LEQUAL);
    GlTools["c" /* gl */].pixelStorei(GlTools["c" /* gl */].UNPACK_FLIP_Y_WEBGL, true);
    let hdrInfo = Object(HDRParser["a" /* default */])(getAssets.equirectangular);
    console.log('hdrInfo', hdrInfo);
    this.hdrTexture = new glTexture_default.a(GlTools["c" /* gl */], GlTools["c" /* gl */].RGBA).fromData(hdrInfo.shape[0], hdrInfo.shape[1], hdrInfo.data, GlTools["c" /* gl */].FLOAT);
    this.hdrTexture.clamp();
    let cubemapTexture = GlTools["c" /* gl */].createTexture();
    GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, cubemapTexture);

    for (var i = 0; i < 6; i++) {
      //r,l,u,d,b,f 为6个面指定空数据
      GlTools["c" /* gl */].texImage2D(GlTools["c" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GlTools["c" /* gl */].RGBA, 512, 512, 0, GlTools["c" /* gl */].RGBA, GlTools["c" /* gl */].FLOAT, null);
    }

    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, GlTools["c" /* gl */].TEXTURE_WRAP_S, GlTools["c" /* gl */].CLAMP_TO_EDGE);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, GlTools["c" /* gl */].TEXTURE_WRAP_T, GlTools["c" /* gl */].CLAMP_TO_EDGE);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, GlTools["c" /* gl */].TEXTURE_MAG_FILTER, GlTools["c" /* gl */].LINEAR);
    GlTools["c" /* gl */].texParameteri(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, GlTools["c" /* gl */].TEXTURE_MIN_FILTER, GlTools["c" /* gl */].LINEAR);
    this.cubemapTexture = cubemapTexture; // render 6 faces to framebuffer

    this.cubePrg.use();
    this.hdrTexture.bind(0);
    let pMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    let mMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    let vMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    let vpMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    gl_matrix["b" /* mat4 */].perspective(pMatrix, Object(GlTools["d" /* toRadian */])(90), 1., .1, 100);
    const CAMERA_SETTINGS = [[gl_matrix["e" /* vec3 */].fromValues(0, 0, 0), gl_matrix["e" /* vec3 */].fromValues(1, 0, 0), gl_matrix["e" /* vec3 */].fromValues(0, -1, 0)], [gl_matrix["e" /* vec3 */].fromValues(0, 0, 0), gl_matrix["e" /* vec3 */].fromValues(-1, 0, 0), gl_matrix["e" /* vec3 */].fromValues(0, -1, 0)], [gl_matrix["e" /* vec3 */].fromValues(0, 0, 0), gl_matrix["e" /* vec3 */].fromValues(0, 1, 0), gl_matrix["e" /* vec3 */].fromValues(0, 0, 1)], [gl_matrix["e" /* vec3 */].fromValues(0, 0, 0), gl_matrix["e" /* vec3 */].fromValues(0, -1, 0), gl_matrix["e" /* vec3 */].fromValues(0, 0, -1)], [gl_matrix["e" /* vec3 */].fromValues(0, 0, 0), gl_matrix["e" /* vec3 */].fromValues(0, 0, 1), gl_matrix["e" /* vec3 */].fromValues(0, -1, 0)], [gl_matrix["e" /* vec3 */].fromValues(0, 0, 0), gl_matrix["e" /* vec3 */].fromValues(0, 0, -1), gl_matrix["e" /* vec3 */].fromValues(0, -1, 0)]];
    GlTools["c" /* gl */].viewport(0, 0, 512, 512);
    let captureFrameBuffer = GlTools["c" /* gl */].createFramebuffer();
    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, captureFrameBuffer);

    for (let i = 0; i < 6; i++) {
      gl_matrix["b" /* mat4 */].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix["b" /* mat4 */].multiply(vpMatrix, pMatrix, vMatrix);
      this.cubePrg.style({
        equirectangularMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      GlTools["c" /* gl */].framebufferTexture2D(GlTools["c" /* gl */].FRAMEBUFFER, GlTools["c" /* gl */].COLOR_ATTACHMENT0, GlTools["c" /* gl */].TEXTURE_CUBE_MAP_POSITIVE_X + i, this.cubemapTexture, 0);
      GlTools["c" /* gl */].clear(GlTools["c" /* gl */].COLOR_BUFFER_BIT | GlTools["c" /* gl */].DEPTH_BUFFER_BIT);
      this.cube.bind(this.cubePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    GlTools["c" /* gl */].bindFramebuffer(GlTools["c" /* gl */].FRAMEBUFFER, null);
    this.irradiancePrg.use();
    let irradianceFbo = new libs_CubeFrameBuffer(32);
    GlTools["c" /* gl */].activeTexture(GlTools["c" /* gl */].TEXTURE0);
    GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, this.cubemapTexture); // 放在这，防止new cubeframebuffer时绑定了tetxure0到null

    for (let i = 0; i < 6; i++) {
      gl_matrix["b" /* mat4 */].lookAt(vMatrix, CAMERA_SETTINGS[i][0], CAMERA_SETTINGS[i][1], CAMERA_SETTINGS[i][2]);
      gl_matrix["b" /* mat4 */].multiply(vpMatrix, pMatrix, vMatrix);
      this.irradiancePrg.style({
        environmentMap: 0,
        vpMatrix,
        mMatrix: mMatrix
      });
      irradianceFbo.bind(i);
      GlTools["c" /* gl */].clear(GlTools["c" /* gl */].COLOR_BUFFER_BIT | GlTools["c" /* gl */].DEPTH_BUFFER_BIT);
      this.cube.bind(this.irradiancePrg, ['position', 'texCoord']);
      this.cube.draw();
    }

    irradianceFbo.unbind();
    this.irradianceFbo = irradianceFbo;
  }

  uniform() {
    let vMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    let pMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    this.tmpMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    let eyeDirection = [];
    let camUpDirection = [];
    gl_matrix["e" /* vec3 */].transformQuat(eyeDirection, [0.0, 0.0, 1.0], this.rotateQ);
    gl_matrix["e" /* vec3 */].transformQuat(camUpDirection, [0.0, 1.0, 0.0], this.rotateQ);
    this.eyeDirection = eyeDirection;
    gl_matrix["b" /* mat4 */].lookAt(vMatrix, eyeDirection, [0, 0, 0], camUpDirection);
    gl_matrix["b" /* mat4 */].perspective(pMatrix, Object(GlTools["d" /* toRadian */])(60), GlTools["b" /* canvas */].clientWidth / GlTools["b" /* canvas */].clientHeight, .1, 100);
    gl_matrix["b" /* mat4 */].multiply(this.tmpMatrix, pMatrix, vMatrix);
  }

  _setGUI() {
    this.addGUIParams({
      roughness: 0.2,
      metallic: 6 / 7,
      lambertDiffuse: true,
      orenNayarDiffuse: false,
      map: 'none'
    });
    let folder = this.gui.addFolder('material param');
    folder.add(this.params, 'roughness', 0.05, 1).step(0.01);
    folder.add(this.params, 'metallic', 0, 6 / 7).step(0.01);
    folder.open();
    let folder1 = this.gui.addFolder('diffuse model');
    folder1.add(this.params, 'lambertDiffuse').listen().onChange(() => {
      this.setChecked('lambertDiffuse');
    });
    folder1.add(this.params, 'orenNayarDiffuse').listen().onChange(() => {
      this.setChecked('orenNayarDiffuse');
    });
    folder1.open();
    let folder2 = this.gui.addFolder('material map');
    folder2.add(this.params, 'map', ['none', 'plastic', 'wall', 'gold', 'grass', 'rusted_iron', 'wood']).listen().onChange(() => {
      this.setTexture();
    });
    folder2.open();
  }

  setChecked(prop) {
    this.params.lambertDiffuse = false;
    this.params.orenNayarDiffuse = false;
    this.params[prop] = true;
  }

  setTexture() {
    let map = this.params.map;
    if (map === 'none') return;
    this.texture0 = new glTexture_default.a(GlTools["c" /* gl */], GlTools["c" /* gl */].RGBA).fromImage(getAssets[map + 'Albedo']);
    this.texture1 = new glTexture_default.a(GlTools["c" /* gl */], GlTools["c" /* gl */].RGBA).fromImage(getAssets[map + 'Roughness']);
    this.texture2 = new glTexture_default.a(GlTools["c" /* gl */], GlTools["c" /* gl */].RGBA).fromImage(getAssets[map + 'Metallic']);
    this.texture3 = new glTexture_default.a(GlTools["c" /* gl */], GlTools["c" /* gl */].RGBA).fromImage(getAssets[map + 'Ao']);
    this.texture4 = new glTexture_default.a(GlTools["c" /* gl */], GlTools["c" /* gl */].RGBA).fromImage(getAssets[map + 'Normal']);
  }

  render() {
    GlTools["c" /* gl */].viewport(0, 0, GlTools["b" /* canvas */].width, GlTools["b" /* canvas */].height);
    GlTools["c" /* gl */].clearColor(0.3, 0.3, 0.3, 1.);
    GlTools["c" /* gl */].clearDepth(1.0);
    GlTools["c" /* gl */].clear(GlTools["c" /* gl */].COLOR_BUFFER_BIT | GlTools["c" /* gl */].DEPTH_BUFFER_BIT);
    let mMatrix = gl_matrix["b" /* mat4 */].identity(gl_matrix["b" /* mat4 */].create());
    let baseUniforms = {
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix,
      lightPositions: [// use flatten array for gl.uniform3fv
      -10., 10., 10., 10., 10., 10., -10., -10., 10., 10., -10., 10.],
      lightColors: new Array(12).fill(300.),
      camPos: this.eyeDirection,
      lambertDiffuse: this.params.lambertDiffuse,
      irradianceMap: 0
    };

    if (this.params.map === 'none') {
      this.prg.use();
      this.irradianceFbo.getTexture().bind(0);
      this.prg.style(Object(objectSpread["a" /* default */])({}, baseUniforms, {
        albedo: [.5, .0, .0],
        roughness: this.params.roughness,
        metallic: this.params.metallic,
        ao: 1.
      }));
      this.sphere.bind(this.prg, ['position', 'normal']);
    } else {
      this.mapPrg.use();
      this.texture0.bind(0);
      this.texture1.bind(1);
      this.texture2.bind(2);
      this.texture3.bind(3);
      this.texture4.bind(4);
      this.mapPrg.style(Object(objectSpread["a" /* default */])({}, baseUniforms, {
        albedoMap: 0,
        roughnessMap: 1,
        metallicMap: 2,
        aoMap: 3,
        normalMap: 4
      }));
      this.sphere.bind(this.mapPrg);
    }

    this.sphere.draw(); // this.cubePrg.use()
    // this.hdrTexture.bind(0)
    // this.cubePrg.style({
    //   equirectangularMap: 0,
    //   vpMatrix: this.tmpMatrix,
    //   mMatrix: mMatrix
    // })
    // this.cube.bind(this.cubePrg, ['position', 'texCoord'])
    // this.cube.draw()
    // this.planeVao.bind()
    // this.planeBuffer.drawTriangles()
    // this.planeVao.unbind()

    this.skyboxPrg.use();
    GlTools["c" /* gl */].activeTexture(GlTools["c" /* gl */].TEXTURE0);
    GlTools["c" /* gl */].bindTexture(GlTools["c" /* gl */].TEXTURE_CUBE_MAP, this.cubemapTexture); // this.irradianceFbo.getTexture().bind(0)

    this.skyboxPrg.style({
      environmentMap: 0,
      vpMatrix: this.tmpMatrix,
      mMatrix: mMatrix
    });
    this.cube.bind(this.skyboxPrg, ['position']);
    this.cube.draw();
  }

}