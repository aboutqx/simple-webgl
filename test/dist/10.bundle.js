(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{44:function(e,n,t){"use strict";t.d(n,"a",(function(){return a}));var o=t(0);class a{constructor(e,n){this._mesh=e,this._shader=n}draw(e){this._shader.bind(),this._shader.style(e),o.a.draw(this._mesh)}get mesh(){return this._mesh}get shader(){return this._shader}}},48:function(e,n,t){"use strict";t.d(n,"a",(function(){return s}));var o=t(13),a=t(15),r=t(42),i=t(44);class s extends i.a{constructor(e,n){const t=new a.a(o.g,o.f);super(r.a.skybox(e),t),this.skyMap=n}draw(e){e&&(this.skyMap=e),super.draw({uGamma:2.2,uExposure:5,tex:this.skyMap})}}},69:function(e,n,t){"use strict";n.a="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D equirectangularMap;\nin vec3 WorldPos;\nout vec4 outColor;\n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec2 SampleSphericalMap(vec3 v)\n{\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y)); // [-PI/2,PI/2]\n    uv *= invAtan; //[-.5,.5]\n    uv += 0.5;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = SampleSphericalMap(normalize(WorldPos));\n    vec3 color = textureLod(equirectangularMap, uv, 0.).rgb;\n\n    outColor = vec4(color, 1.0);\n    // gl_FragColor = vec4(WorldPos,1.);\n}\n"},88:function(e,n,t){"use strict";t.r(n),t.d(n,"default",(function(){return m}));var o=t(43),a=t(0),r=t(69),i=t(48),s=t(13),l=t(42),c=t(1),u=t(10);class m extends o.a{constructor(){super()}init(){a.a.applyHdrExtension(),this.prg=this.compile("#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\nin vec3 position;\nin vec3 normal;\nin vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nout   vec3 vNormal;\nout vec3 WorldPos;\nout vec2 vTexCoord;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  vTexCoord = texCoord;\n}\n","#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D   brdfLUT;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nin vec3 vNormal;\nin vec3 vPosition;\nout vec4 outColor;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// deal with IBL\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - vPosition);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - vPosition);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - vPosition);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse    = irradiance * albedo;\n\n    vec3 R = reflect(-V, N);\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    outColor = vec4(color, 1.0);\n\n}\n"),this.cubePrg=this.compile(s.b,r.a),this.prefilterPrg=this.compile(s.b,"#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec4 FragColor;\nin vec3 vPosition;\n\nuniform samplerCube environmentMap;\nuniform float roughness;\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits)\n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t// from spherical coordinates to cartesian coordinates - halfway vector\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\n\t// from tangent-space H vector to world-space sample vector\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec3 N = normalize(vPosition);\n\n    // make the simplyfying assumption that V equals R equals the normal\n    vec3 R = N;\n    vec3 V = R;\n\n    const uint SAMPLE_COUNT = 1024u;\n    vec3 prefilteredColor = vec3(0.0);\n    float totalWeight = 0.0;\n\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        if(NdotL > 0.0)\n        {\n            // sample from the environment's mip level based on roughness/pdf\n            float D   = DistributionGGX(N, H, roughness);\n            float NdotH = max(dot(N, H), 0.0);\n            float HdotV = max(dot(H, V), 0.0);\n            float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;\n\n            float resolution = 512.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n\n            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel);\n\n            prefilteredColor += textureLod(environmentMap, L, mipLevel).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n\n    prefilteredColor = prefilteredColor / totalWeight;\n\n    FragColor = vec4(prefilteredColor, 1.0);\n}\n"),this.brdfPrg=this.compile(s.c,"#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec2 FragColor;\nin vec2 vTexCoord;\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits)\n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t// from spherical coordinates to cartesian coordinates - halfway vector\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\n\t// from tangent-space H vector to world-space sample vector\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    // note that we use a different k for IBL\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 1024u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the\n        // preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec2 integratedBRDF = IntegrateBRDF(vTexCoord.x, vTexCoord.y);\n    FragColor = integratedBRDF;\n    // FragColor = vec4(integratedBRDF, 0. ,1.);\n}\n"),this.irradiancePrg=this.compile(s.b,"#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nin vec3 vPosition;\nout vec4 outColor;\nuniform samplerCube environmentMap;\n\nconst float PI = 3.14159265359;\n\nvoid main()\n{\n\t// The world vector acts as the normal of a tangent surface\n    // from the origin, aligned to vPosition. Given this normal, calculate all\n    // incoming radiance of the environment. The result of this radiance\n    // is the radiance of light coming from -Normal direction, which is what\n    // we use in the PBR shader to sample irradiance.\n    vec3 N = normalize(vPosition);\n\n    vec3 irradiance = vec3(0.0);\n\n    // tangent space calculation from origin point\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up            = cross(N, right);\n\n    const float sampleDelta = 0.025;\n    float nrSamples = 0.0;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\n\n            irradiance += texture(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n    outColor = vec4(irradiance, 1.0);\n}\n")}attrib(){this.sphere=l.a.sphere(2,100),this.skybox=new i.a(2),this.cube=l.a.cube(2),this.quad=l.a.bigTriangle(),this.orbital.radius=12}prepare(){a.c.pixelStorei(a.c.UNPACK_FLIP_Y_WEBGL,!0);let e=c.b.create(),n=c.b.create(),t=c.b.create(),o=c.b.create();c.b.perspective(e,Object(a.d)(90),1,.1,100);const r=[[c.e.fromValues(0,0,0),c.e.fromValues(1,0,0),c.e.fromValues(0,-1,0)],[c.e.fromValues(0,0,0),c.e.fromValues(-1,0,0),c.e.fromValues(0,-1,0)],[c.e.fromValues(0,0,0),c.e.fromValues(0,1,0),c.e.fromValues(0,0,1)],[c.e.fromValues(0,0,0),c.e.fromValues(0,-1,0),c.e.fromValues(0,0,-1)],[c.e.fromValues(0,0,0),c.e.fromValues(0,0,1),c.e.fromValues(0,-1,0)],[c.e.fromValues(0,0,0),c.e.fromValues(0,0,-1),c.e.fromValues(0,-1,0)]];this.hdrTexture=getAssets.equirectangular;let i=new u.a(null,{width:512,height:512});this.cubemapTexture=i,this.cubePrg.use(),this.hdrTexture.bind(),a.c.viewport(0,0,512,512);let s=a.c.createFramebuffer();a.c.bindFramebuffer(a.c.FRAMEBUFFER,s);for(let i=0;i<6;i++)c.b.lookAt(t,r[i][0],r[i][1],r[i][2]),c.b.multiply(o,e,t),this.cubePrg.uniform("environmentMap","uniform1i",0),this.cubePrg.style({vpMatrix:o,mMatrix:n}),a.c.framebufferTexture2D(a.c.FRAMEBUFFER,a.c.COLOR_ATTACHMENT0,a.c.TEXTURE_CUBE_MAP_POSITIVE_X+i,this.cubemapTexture.texture,0),a.c.clear(a.c.COLOR_BUFFER_BIT|a.c.DEPTH_BUFFER_BIT),a.a.draw(this.cube);this.cubemapTexture.bind(),a.c.generateMipmap(a.c.TEXTURE_CUBE_MAP),(()=>{const e=a.c.checkFramebufferStatus(a.c.FRAMEBUFFER);e!=a.c.FRAMEBUFFER_COMPLETE&&console.log("gl.checkFramebufferStatus() returned "+e.toString(16)),a.c.bindFramebuffer(a.c.FRAMEBUFFER,null)})()}uniform(){}_setGUI(){this.addGUIParams({roughness:.2,metallic:6/7,map:"none"});let e=this.gui.addFolder("material param");e.add(this.params,"roughness",.05,1).step(.01),e.add(this.params,"metallic",0,6/7).step(.01),e.open(),this.addRadio("lambertDiffuse",["lambertDiffuse","orenNayarDiffuse"],"diffuse model");let n=this.gui.addFolder("material map");n.add(this.params,"map",["none","plastic","wall","gold","grass","rusted_iron","wood"]).listen().onChange(()=>{this.setTexture()}),n.open()}setTexture(){let e=this.params.map;"none"!==e&&(this.texture0=getAssets[e+"Albedo"],this.texture1=getAssets[e+"Roughness"],this.texture2=getAssets[e+"Metallic"],this.texture3=getAssets[e+"Ao"],this.texture4=getAssets[e+"Normal"])}render(){a.c.viewport(0,0,a.b.width,a.b.height),a.a.clear();let e=c.b.create();this.cubePrg.use(),this.cubePrg.style({equirectangularMap:this.hdrTexture,mMatrix:e}),a.a.draw(this.cube)}}}}]);