(window.webpackJsonp=window.webpackJsonp||[]).push([[10,23],{115:function(e,t){e.exports="#version 300 es\n#define GLSLIFY 1\nin vec3 position;\n\nuniform mat4 lightSpaceMatrix;\nuniform mat4 mMatrix;\n\nvoid main(void){\n    gl_Position = lightSpaceMatrix * mMatrix * vec4(position, 1.0);\n}\n"},116:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n\nvoid main(){\n\n}\n"},117:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D depthMap;\nuniform float near_plane;\nuniform float far_plane;\n\n// required when using a perspective projection matrix\nfloat LinearizeDepth(float depth)\n{\n    float z = depth * 2.0 - 1.0; // Back to NDC\n    return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));\n}\n\nvoid main()\n{\n    float depthValue = texture(depthMap, TexCoords).r;\n    // FragColor = vec4(vec3(LinearizeDepth(depthValue) / far_plane), 1.0); // perspective\n    FragColor = vec4(vec3(depthValue), 1.0); // orthographic\n}\n"},118:function(e,t){e.exports="#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoord;\n\n\nout vec3 FragPos;\nout  vec3 Normal;\nout  vec2 TexCoords;\nout vec4 FragPosLightSpace;\n\n\nuniform mat4 pMatrix;\nuniform mat4 vMatrix;\nuniform mat4 mMatrix;\nuniform mat4 lightSpaceMatrix;\n\nvoid main(){\n  gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.);\n  FragPos = vec3(mMatrix * vec4(position, 1.));\n  Normal = transpose(inverse(mat3(mMatrix))) * normal;\n  TexCoords = texCoord;\n  FragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.); // 从lightPos视角看的坐标\n}\n"},119:function(e,t){e.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords;\nin vec4 FragPosLightSpace;\n\n\nuniform sampler2D diffuseTexture;\nuniform sampler2D shadowMap;\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nfloat ShadowCalculation(vec4 fragPosLightSpace, float bias){\n      // 执行透视除法\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n    // 变换到[0,1]的范围\n    projCoords = projCoords * 0.5 + 0.5;\n    // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)\n    float closestDepth = texture(shadowMap, projCoords.xy).r;\n    // 取得当前片元在光源视角下的深度\n    float currentDepth = projCoords.z;\n    // 检查当前片元是否在阴影中\n\n    float shadow = 0.0;\n    vec2 texelSize = vec2(1. / float(textureSize(shadowMap, 0).x));\n    for(int x = -1; x <= 1; ++x)\n    {\n        for(int y = -1; y <= 1; ++y)\n        {\n            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;\n            shadow += currentDepth - bias > pcfDepth ? .7 : 0.0;\n        }\n    }\n    shadow /= 9.0;\n\n    if(projCoords.z > 1.0) shadow = 0.0;\n\n    return shadow;\n}\n\nvoid main(){\n    vec3 color = texture(diffuseTexture, TexCoords).rgb;\n    vec3 normal = normalize(Normal);\n    vec3 lightColor = vec3(2.0);\n    // Ambient\n    vec3 ambient = 0.15 * color;\n    // Diffuse\n    vec3 lightDir = normalize(lightPos - FragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * lightColor;\n    // Specular\n    vec3 viewDir = normalize(viewPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = 0.0;\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);\n    vec3 specular = spec * lightColor;\n    // 计算阴影\n    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);\n    float shadow = ShadowCalculation(FragPosLightSpace, bias);\n    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;\n\n    FragColor = vec4(lighting, 1.0);\n}\n"},15:function(e,t){e.exports="#version 300 es\n#define GLSLIFY 1\nin vec3 position;\nin vec2 texCoord;\n\nout vec2 TexCoords;\nvoid main(){\n  TexCoords = texCoord;\n  gl_Position = vec4(position, 1.);\n}\n"},58:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return C});var i=n(2),r=n(5),a=n(0),o=n(3),s=n.n(o),d=n(115),c=n.n(d),h=n(116),l=n.n(h),u=n(15),p=n.n(u),f=n(117),m=n.n(f),x=n(118),v=n.n(x),M=n(119),T=n.n(M),g=n(1),E=n(6),P=n(4);const w=1024,F=1024,b=[0,4,-1];let D=g.a.identity(g.a.create()),_=g.a.identity(g.a.create());class C extends r.default{constructor(){super(),Object(i.a)(this,"count",0)}init(){this.prg=this.compile(c.a,l.a),this.depthQuadPrg=this.compile(p.a,m.a),this.shadowPrg=this.compile(v.a,T.a),a.d.pixelStorei(a.d.UNPACK_FLIP_Y_WEBGL,!0)}attrib(){this.plane=new P.a,this.plane.bufferData([30,-1.01,30,1,0,-30,-1.01,30,0,0,-30,-1.01,-30,0,1,30,-1.01,30,1,0,-30,-1.01,-30,0,1,30,-1.01,-30,1,1],["position","texCoord"],[3,2]),this.cube=new P.a,this.cube.bufferData(E.CubeData,["position","normal","texCoord"],[3,3,2]),this.quad=new P.a,this.quad.bufferData(E.QuadData,["position","texCoord"],[3,2])}prepare(){let e=g.a.identity(g.a.create()),t=g.a.identity(g.a.create());this.tmpMatrix=g.a.identity(g.a.create());g.a.ortho(t,-25,25,-25,25,.1,18.5),g.a.lookAt(e,b,[0,0,0],[0,1,0]),g.a.multiply(this.tmpMatrix,t,e),g.a.perspective(_,Object(a.e)(60),a.c/a.b,.1,100),a.d.enable(a.d.DEPTH_TEST),a.d.depthFunc(a.d.LESS),a.d.clearColor(.3,.3,.3,1),this.depthBuffer=function(e,t){const n=a.d.createFramebuffer(),i=a.d.createTexture();a.d.bindTexture(a.d.TEXTURE_2D,i),a.d.texImage2D(a.d.TEXTURE_2D,0,a.d.DEPTH_COMPONENT16,e,t,0,a.d.DEPTH_COMPONENT,a.d.UNSIGNED_SHORT,null),a.d.texParameteri(a.d.TEXTURE_2D,a.d.TEXTURE_MIN_FILTER,a.d.NEAREST),a.d.texParameteri(a.d.TEXTURE_2D,a.d.TEXTURE_MAG_FILTER,a.d.NEAREST),a.d.texParameteri(a.d.TEXTURE_2D,a.d.TEXTURE_WRAP_S,a.d.REPEAT),a.d.texParameteri(a.d.TEXTURE_2D,a.d.TEXTURE_WRAP_T,a.d.REPEAT);return a.d.bindFramebuffer(a.d.FRAMEBUFFER,n),a.d.framebufferTexture2D(a.d.FRAMEBUFFER,a.d.DEPTH_ATTACHMENT,a.d.TEXTURE_2D,i,0),a.d.drawBuffers([a.d.NONE]),a.d.readBuffer(a.d.NONE),a.d.bindFramebuffer(a.d.FRAMEBUFFER,null),{frameBuffer:n,depthTexture:i}}(w,F),this.camera.radius=11,this.wood=new s.a(a.d).fromImage(getAssets.wood),this.wood.bind(),this.wood.repeat()}uniform(){D=this.camera.viewMatrix}render(){a.d.viewport(0,0,w,F),a.d.bindFramebuffer(a.d.FRAMEBUFFER,this.depthBuffer.frameBuffer),a.d.clear(a.d.DEPTH_BUFFER_BIT),this.prg.use(),this.prg.style({lightSpaceMatrix:this.tmpMatrix}),this._renderScene(this.prg,["position"]),a.d.bindFramebuffer(a.d.FRAMEBUFFER,null),a.d.viewport(0,0,a.c,a.b),a.d.clear(a.d.COLOR_BUFFER_BIT|a.d.DEPTH_BUFFER_BIT),a.d.activeTexture(a.d.TEXTURE0),a.d.bindTexture(a.d.TEXTURE_2D,this.depthBuffer.depthTexture),this.wood.bind(1),this.shadowPrg.use(),this.shadowPrg.style({shadowMap:0,diffuseTexture:1,lightPos:b,viewPos:this.camera.cameraPos,mMatrix:this.mMatrix,pMatrix:_,vMatrix:D,lightSpaceMatrix:this.tmpMatrix}),this._renderScene(this.shadowPrg)}_renderScene(e,t){this.mMatrix=g.a.identity(g.a.create()),e.style({mMatrix:this.mMatrix}),this.plane.bind(e,t),this.plane.draw(),g.a.translate(this.mMatrix,this.mMatrix,[-1.2,0,5]),e.style({mMatrix:this.mMatrix}),this.cube.bind(e,t),this.cube.draw(),this.mMatrix=g.a.identity(g.a.create()),g.a.translate(this.mMatrix,this.mMatrix,[2,2,4]),e.style({mMatrix:this.mMatrix}),this.cube.bind(e,t),this.cube.draw(),this.mMatrix=g.a.identity(g.a.create()),g.a.translate(this.mMatrix,this.mMatrix,[-2.2,.4,1]),g.a.rotate(this.mMatrix,this.mMatrix,Object(a.e)(30),[2,2,4]),e.style({mMatrix:this.mMatrix}),this.cube.bind(e,t),this.cube.draw()}}},6:function(e,t,n){"use strict";function i(e,t,n,i,a){let o,s=[],d=[],c=[],h=[];for(let d=0;d<=e;d++){let l=2*Math.PI/e*d,u=Math.cos(l),p=Math.sin(l);for(let e=0;e<=t;e++){let d=2*Math.PI/t*e,l=(u*n+i)*Math.cos(d),f=p*n,m=(u*n+i)*Math.sin(d);s.push(l,f,m),o=a||r(360/t*e,1,1,1),h.push(o[0],o[1],o[2],o[3]);let x=u*Math.cos(d),v=u*Math.sin(d);c.push(x,p,v)}}for(let n=0;n<e;n++)for(let e=0;e<t;e++){let i=(t+1)*n+e;d.push(i,i+t+1,i+1),d.push(i+t+1,i+t+2,i+1)}return{pos:s,index:d,normal:c,color:h}}function r(e,t,n,i){if(t>1||n>1||i>1)return;let r=e%360,a=Math.floor(r/60),o=r/60-a,s=n*(1-t),d=n*(1-t*o),c=n*(1-t*(1-o)),h=[];if(!t>0&&!t<0)h.push(n,n,n,i);else{let e=[n,d,s,s,c,n],t=[c,n,n,d,s,s],r=[s,s,c,n,n,d];h.push(e[a],t[a],r[a],i)}return h}function a(e,t,n,i){for(var a=[],o=[],s=[],d=[],c=[],h=0;h<=e;h++)for(var l=Math.PI/e*h,u=Math.cos(l),p=Math.sin(l),f=0;f<=t;f++){var m=2*Math.PI/t*f,x=p*n*Math.cos(m),v=u*n,M=p*n*Math.sin(m),T=p*Math.cos(m),g=p*Math.sin(m);if(i)var E=i;else E=r(360/e*h,1,1,1);a.push(x,v,M),o.push(T,u,g),s.push(E[0],E[1],E[2],E[3]),d.push(1-1/t*f,1/e*h)}for(l=0,h=0;h<e;h++)for(f=0;f<t;f++)l=(t+1)*h+f,c.push(l,l+1,l+t+2),c.push(l,l+t+2,l+t+1);return{pos:a,normal:o,color:s,uv:d,index:c}}function o(e,t,n){const i=e/2,r=n/2;return[i,t,r,0,1,0,1,0,-i,t,-r,0,1,0,0,1,-i,t,r,0,1,0,0,0,i,t,r,0,1,0,1,0,i,t,-r,0,1,0,1,1,-i,t,-r,0,1,0,0,1]}n.r(t),n.d(t,"Torus",function(){return i}),n.d(t,"hsva",function(){return r}),n.d(t,"Sphere",function(){return a}),n.d(t,"plane",function(){return o}),n.d(t,"QuadData",function(){return s}),n.d(t,"CubeData",function(){return d});const s=[-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0],d=[-1,-1,-1,0,0,-1,0,0,1,1,-1,0,0,-1,1,1,1,-1,-1,0,0,-1,1,0,1,1,-1,0,0,-1,1,1,-1,-1,-1,0,0,-1,0,0,-1,1,-1,0,0,-1,0,1,-1,-1,1,0,0,1,0,0,1,-1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,-1,1,1,0,0,1,0,1,-1,-1,1,0,0,1,0,0,-1,1,1,-1,0,0,1,0,-1,1,-1,-1,0,0,1,1,-1,-1,-1,-1,0,0,0,1,-1,-1,-1,-1,0,0,0,1,-1,-1,1,-1,0,0,0,0,-1,1,1,-1,0,0,1,0,1,1,1,1,0,0,1,0,1,-1,-1,1,0,0,0,1,1,1,-1,1,0,0,1,1,1,-1,-1,1,0,0,0,1,1,1,1,1,0,0,1,0,1,-1,1,1,0,0,0,0,-1,-1,-1,0,-1,0,0,1,1,-1,-1,0,-1,0,1,1,1,-1,1,0,-1,0,1,0,1,-1,1,0,-1,0,1,0,-1,-1,1,0,-1,0,0,0,-1,-1,-1,0,-1,0,0,1,-1,1,-1,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,-1,0,1,0,1,1,1,1,1,0,1,0,1,0,-1,1,-1,0,1,0,0,1,-1,1,1,0,1,0,0,0]}}]);