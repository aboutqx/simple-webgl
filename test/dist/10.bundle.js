(window.webpackJsonp=window.webpackJsonp||[]).push([[10,22,28],{126:function(t,e){t.exports="precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying   vec3 vNormal;\nvarying vec3 WorldPos;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n\n}\n"},127:function(t,e){t.exports="\nprecision mediump float;\n#define GLSLIFY 1\n\n// material parameters\nuniform vec3 albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvoid main(void){\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"},142:function(t,e){t.exports="// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 texCoord;\nattribute vec3 normal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n    vTextureCoord = texCoord;\n    vNormal = normal;\n}"},143:function(t,e){t.exports="// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"},28:function(t,e,n){"use strict";var o=n(0),a=n(14),r=n(12);n(144);const i=(t,e)=>{if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0},s=t=>{const e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=`${t+1}: ${e[t]}`;return e.join("\n")},h=t=>t.slice?t.slice(0):new Float32Array(t),l=n(142),c=n(143),u={float:"uniform1f",vec2:"uniform2fv",vec3:"uniform3fv",vec4:"uniform4fv",int:"uniform1i",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"};class m{constructor(t=l,e=c,n){this.parameters=[],this._uniformTextures=[],this._varyings=n,t||(t=l),e||(e=l);const o=this._createShaderProgram(t,!0),a=this._createShaderProgram(e,!1);this._attachShaderProgram(o,a)}use(){this.bind()}bind(){o.c.useProgram(this.shaderProgram),o.a.useShader(this)}uniform(t,e,n){if("object"==typeof t)return void this.uniformObject(t);const a=u[e]||e;let r,s=!1,l=-1;for(let e=0;e<this.parameters.length;e++)if((r=this.parameters[e]).name===t){s=!0,l=e;break}let c=!1;if(s?(this.shaderProgram[t]=r.uniformLoc,c=r.isNumber):(c="uniform1i"===a||"uniform1f"===a,this.shaderProgram[t]=o.c.getUniformLocation(this.shaderProgram,t),c?this.parameters.push({name:t,type:a,value:n,uniformLoc:this.shaderProgram[t],isNumber:c}):this.parameters.push({name:t,type:a,value:h(n),uniformLoc:this.shaderProgram[t],isNumber:c}),l=this.parameters.length-1),this.parameters[l].uniformLoc)if(-1===a.indexOf("Matrix"))if(c){(this.parameters[l].value!==n||!s)&&(o.c[a](this.shaderProgram[t],n),this.parameters[l].value=n)}else i(this.parameters[l].value,n)&&s||(o.c[a](this.shaderProgram[t],n),this.parameters[l].value=h(n));else i(this.parameters[l].value,n)&&s||(o.c[a](this.shaderProgram[t],!1,n),this.parameters[l].value=h(n))}style(t){this.uniformObject(t)}uniformObject(t){for(const e in t)if(t[e]instanceof a.a||t[e]instanceof r.a){const n=t[e];let o=-1;this._uniformTextures.forEach((t,a)=>{t.name===e&&(o=a,t.texture=n)}),-1===o&&(o=this._uniformTextures.length,this._uniformTextures.push({name:e,texture:n})),this.uniform(e,"uniform1i",o),n.bind(o)}else{let n=t[e];const o=m.getUniformType(n);if(n.concat&&n[0].concat){let t=[];for(let e=0;e<n.length;e++)t=t.concat(n[e]);n=t}this.uniform(e,o,n)}}_createShaderProgram(t,e){const n=e?o.c.VERTEX_SHADER:o.c.FRAGMENT_SHADER,a=o.c.createShader(n);return o.c.shaderSource(a,t),o.c.compileShader(a),o.c.getShaderParameter(a,o.c.COMPILE_STATUS)?a:(console.warn("Error in Shader : ",o.c.getShaderInfoLog(a)),console.log(s(t)),null)}_attachShaderProgram(t,e){this.shaderProgram=o.c.createProgram(),o.c.attachShader(this.shaderProgram,t),o.c.attachShader(this.shaderProgram,e),o.c.deleteShader(t),o.c.deleteShader(e),this._varyings&&(console.log("Transform feedback setup : ",this._varyings),o.c.transformFeedbackVaryings(this.shaderProgram,this._varyings,o.c.SEPARATE_ATTRIBS)),o.c.linkProgram(this.shaderProgram)}}m.getUniformType=function(t){const e=function(t){return 9===t.length?"uniformMatrix3fv":16===t.length?"uniformMatrix4fv":`vec${t.length}`};return!!t.length?t[0].concat?e(t[0]):e(t):"float"},e.a=m},32:function(t,e){t.exports="precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\nuniform   mat4 mMatrix;\nuniform   mat4 vpMatrix;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\nvoid main(void){\n\n\tvec4 pos       = mMatrix * vec4(position, 1.0);\n\tgl_Position    = vpMatrix * pos;\n\n  vNormal = mat3(mMatrix) * normal;\n  WorldPos = pos.xyz;\n  TexCoords = texCoord;\n}\n"},33:function(t,e){t.exports="#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\n#define GLSLIFY 1\n// material map\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D metallicMap;\nuniform sampler2D aoMap;\n\nuniform bool lambertDiffuse;\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\nuniform vec3 camPos;\n\nvarying vec3 vNormal;\nvarying vec3 WorldPos;\nvarying vec2 TexCoords;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;//max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// OrenNayar diffuse\nvec3 getDiffuse( vec3 diffuseColor, float roughness4, float NoV, float NoL, float VoH )\n{\n\tfloat VoL = 2. * VoH - 1.;\n\tfloat c1 = 1. - 0.5 * roughness4 / (roughness4 + 0.33);\n\tfloat cosri = VoL - NoV * NoL;\n\tfloat c2 = 0.45 * roughness4 / (roughness4 + 0.09) * cosri * ( cosri >= 0. ? min( 1., NoL / NoV ) : NoL );\n\treturn diffuseColor / PI * ( NoL * c1 + c2 );\n}\n\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture2D(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(vNormal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid main(void){\n    vec3 albedo     = pow(texture2D(albedoMap, TexCoords).rgb, vec3(2.2));\n    vec3 N     = getNormalFromMap();\n    float metallic  = texture2D(metallicMap, TexCoords).r;\n    float roughness = texture2D(roughnessMap, TexCoords).r;\n    float ao        = texture2D(aoMap, TexCoords).r;\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0      = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n\n        // get all the usefull dot products and clamp them between 0 and 1 just to be safe\n        float NoL\t\t\t\t= saturate( dot( N, L ) );\n        float NoV\t\t\t\t= saturate( dot( N, V ) );\n        float VoH\t\t\t\t= saturate( dot( V, H ) );\n        float NoH\t\t\t\t= saturate( dot( N, H ) );\n\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = lightColors[i] * attenuation;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //反射百分比\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\n\n        // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n\n        vec3 diffuse = lambertDiffuse ? albedo / PI : getDiffuse( albedo, roughness, NoV, NoL, VoH );\n        // add to outgoing radiance Lo\n        Lo += (kD * diffuse + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (note that the next IBL tutorial will replace\n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n\n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    gl_FragColor = vec4(color, 1.0);\n\n}\n"},4:function(t,e){var n=0,o=3553;function a(t,e,n){return 9728|+t|+e<<8|+(e&&n)<<1}function r(t,e){return this._uid=n++,this.gl=t,this.id=this.gl.createTexture(),this.width=0,this.height=0,this.format=e||t.RGB,this.type=t.UNSIGNED_BYTE,this.img=null,t.bindTexture(o,this.id),this.setFilter(!0),this}r.prototype={fromImage:function(t){var e=this.gl;return this.img=t,this.width=t.width,this.height=t.height,e.bindTexture(o,this.id),e.texImage2D(o,0,this.format,this.format,this.type,t),this},fromData:function(t,e,n,a){var r=this.gl;return this.width=t,this.height=e,n=n||null,this.type=a||r.UNSIGNED_BYTE,r.bindTexture(o,this.id),window.useWebgl2?a===r.RGBA16F?r.texImage2D(r.TEXTURE_2D,0,this.type,t,e,0,this.format,r.HALF_FLOAT,n):a===r.RG32F||a===r.RGBA32F||a===r.RGB32F?r.texImage2D(r.TEXTURE_2D,0,this.type,t,e,0,this.format,r.FLOAT,n):r.texImage2D(o,0,this.format,t,e,0,this.format,this.type,n):r.texImage2D(o,0,this.format,t,e,0,this.format,this.type,n),this},bind:function(t){var e=this.gl;void 0!==t&&e.activeTexture(e.TEXTURE0+(0|t)),e.bindTexture(o,this.id)},dispose:function(){this.gl&&this.gl.deleteTexture(this.id),this.id=null,this.gl=null},setFilter:function(t,e,n){var r=this.gl,i=a(!!t,!!e,!!n);r.texParameteri(o,r.TEXTURE_MAG_FILTER,a(!!t,!1,!1)),r.texParameteri(o,r.TEXTURE_MIN_FILTER,i)},repeat:function(){this.wrap(this.gl.REPEAT)},clamp:function(){this.wrap(this.gl.CLAMP_TO_EDGE)},mirror:function(){this.wrap(this.gl.MIRRORED_REPEAT)},wrap:function(t){var e=this.gl;e.texParameteri(o,e.TEXTURE_WRAP_S,t),e.texParameteri(o,e.TEXTURE_WRAP_T,t)}},t.exports=r},5:function(t,e,n){"use strict";n.r(e);var o=n(2),a=n(28),r=n(1),i=n(0);const s=function(t,e,n){const o=e||{};return t.touches&&!n?(o.x=t.touches[0].pageX,o.y=t.touches[0].pageY):t.touches?t.touches&&n&&(o.x=t.touches[1].pageX,o.y=t.touches[1].pageY):(o.x=t.clientX,o.y=t.clientY),o},h=1e-4;class l{constructor(t=[0,0,0],e=[0,1,0]){Object(o.a)(this,"cameraPos",void 0),Object(o.a)(this,"up",void 0),Object(o.a)(this,"cameraFront",[0,0,-1]),Object(o.a)(this,"_mouse",{}),Object(o.a)(this,"_preMouse",{}),Object(o.a)(this,"_mousedown",!1),Object(o.a)(this,"_rx",0),Object(o.a)(this,"_ry",0),Object(o.a)(this,"_preRx",0),Object(o.a)(this,"_preRy",0),Object(o.a)(this,"_targetRx",0),Object(o.a)(this,"_targetRy",0),Object(o.a)(this,"_viewMatrix",r.b.identity(r.b.create())),Object(o.a)(this,"_width",i.b.width),Object(o.a)(this,"_height",i.b.height),Object(o.a)(this,"sensitivity",1),Object(o.a)(this,"target",[0,0,0]),Object(o.a)(this,"offset",[0,0,0]),Object(o.a)(this,"radius",5),Object(o.a)(this,"_targetRadius",5),Object(o.a)(this,"_updateWheel",!1),this.position=t,this.up=e,this.projMatrix=r.b.create(),r.b.perspective(this.projMatrix,Object(i.d)(45),i.b.clientWidth/i.b.clientHeight,.1,100),this._addEvents()}setProj(t,e,n){r.b.perspective(this.projMatrix,Object(i.d)(t),i.b.clientWidth/i.b.clientHeight,e,n)}_addEvents(){i.b.addEventListener("mousedown",t=>this._down(t)),i.b.addEventListener("mousemove",t=>this._move(t)),document.addEventListener("mouseup",t=>this._up(t)),i.b.addEventListener("mousewheel",t=>this._onWheel(t)),i.b.addEventListener("DOMMouseScroll",t=>this._onWheel(t))}_down(t){this._mousedown=!0,s(t,this._mouse),s(t,this._preMouse),this._preRx=this._targetRx,this._preRy=this._targetRy}_move(t){if(this._mousedown){s(t,this._mouse);let e=(this._mouse.x-this._preMouse.x)/this._width,n=(this._mouse.y-this._preMouse.y)/this._height;this._targetRx=this._preRx+e*Math.PI*2*this.sensitivity,this._targetRy=this._preRy+n*Math.PI*this.sensitivity}}_up(t){this._mousedown=!1}updateMatrix(){this._rx+=.1*(this._targetRx-this._rx),Math.abs(this._targetRx-this._rx)<h&&(this._rx=this._targetRx),this._ry+=.1*(this._targetRy-this._ry),Math.abs(this._targetRy-this._ry)<h&&(this._ry=this._targetRy),this._updateWheel&&(this.radius+=.1*(this._targetRadius-this.radius),Math.abs(this._targetRadius-this.radius)<h&&(this.radius=this._targetRadius)),this.position[1]=Math.sin(this._ry)*this.radius;let t=Math.abs(Math.cos(this._ry)*this.radius);this.position[0]=Math.cos(this._rx+.5*Math.PI)*t,this.position[2]=Math.sin(this._rx+.5*Math.PI)*t,this.position=[this.position[0]+this.offset[0],this.position[1]+this.offset[1],this.position[2]+this.offset[2]],r.b.lookAt(this._viewMatrix,this.position,this.target,this.up)}_onWheel(t){const e=t.wheelDelta,n=t.detail;let o=0;o=n?e?e/n/40*n>0?1:-1:-n/3:e/120,this._targetRadius=this.radius+1*-o,this._targetRadius<=1&&(this._targetRadius=1),this._updateWheel=!0}get viewMatrix(){return this._viewMatrix}set rx(t){this._targetRx=t}}var c=n(43);n.d(e,"default",function(){return u});class u{constructor(){Object(o.a)(this,"rotateQ",r.c.create()),Object(o.a)(this,"mousePos",{x:0,y:0}),Object(o.a)(this,"camera",new l),Object(o.a)(this,"pMatrix",r.b.identity(r.b.create())),Object(o.a)(this,"mvpMatrix",r.b.identity(r.b.create())),Object(o.a)(this,"tmpMatrix",r.b.identity(r.b.create())),Object(o.a)(this,"_params",{}),Object(o.a)(this,"gui",new c.a({width:300})),this.vMatrix=this.camera.viewMatrix,i.a.setCamera(this.camera),this.init(),this.attrib(),this.prepare(),this._setGUI(),this._animate=this.animate.bind(this),i.c.enable(i.c.DEPTH_TEST),i.c.depthFunc(i.c.LEQUAL),i.c.enable(i.c.CULL_FACE)}init(){}compile(t,e){return new a.a(t,e)}attrib(){}uniform(){}prepare(){}animate(){requestAnimationFrame(this._animate),this.camera.updateMatrix(),this.uniform(),this.render()}render(){}play(){this.animate()}_setGUI(){}addGUIParams(t){return Object.assign(this._params,t)}get params(){return this._params}set params(t){throw Error("Params has no setter,please use addGUIParams")}}},58:function(t,e,n){"use strict";n.r(e),n.d(e,"default",function(){return M});var o=n(7),a=n(2),r=n(5),i=n(0),s=n(126),h=n.n(s),l=n(127),c=n.n(l),u=n(32),m=n.n(u),d=n(33),f=n.n(d),g=n(6),p=n(1),v=n(3),b=n(4),x=n.n(b);const _=7,N=7,y=.8;class M extends r.default{constructor(){super(),Object(a.a)(this,"count",0)}init(){i.c.getExtension("OES_standard_derivatives"),this.prg=this.compile(h.a,c.a),this.mapPrg=this.compile(m.a,f.a)}attrib(){let{pos:t,index:e,normal:n,uv:o}=Object(g.Sphere)(256,256,.25),a=new v.a;a.bufferVertex(t),a.bufferIndex(e),a.bufferNormal(n),a.bufferTexCoord(o),this.sphere=a}prepare(){i.c.enable(i.c.DEPTH_TEST),i.c.depthFunc(i.c.LEQUAL)}uniform(){let t=p.b.identity(p.b.create()),e=p.b.identity(p.b.create());this.tmpMatrix=p.b.identity(p.b.create());let n=[],o=[];"none"===this.params.map?p.e.transformQuat(n,[0,0,5],this.rotateQ):p.e.transformQuat(n,[0,0,1],this.rotateQ),p.e.transformQuat(o,[0,1,0],this.rotateQ),this.eyeDirection=n,p.b.lookAt(t,n,[0,0,0],o),p.b.perspective(e,Object(i.d)(45),i.b.clientWidth/i.b.clientHeight,.1,100),p.b.multiply(this.tmpMatrix,e,t)}_setGUI(){this.addGUIParams({lambertDiffuse:!0,orenNayarDiffuse:!1,map:"none"});let t=this.gui.addFolder("diffuse model");t.add(this.params,"lambertDiffuse").listen().onChange(()=>{this.setChecked("lambertDiffuse")}),t.add(this.params,"orenNayarDiffuse").listen().onChange(()=>{this.setChecked("orenNayarDiffuse")}),t.open();let e=this.gui.addFolder("material map");e.add(this.params,"map",["none","plastic","wall","gold","grass","rusted_iron","wood"]).listen().onChange(()=>{this.setTexture()}),e.open()}setChecked(t){this.params.lambertDiffuse=!1,this.params.orenNayarDiffuse=!1,this.params[t]=!0}setTexture(){let t=this.params.map;"none"!==t&&(this.texture0=new x.a(i.c,i.c.RGBA).fromImage(getAssets[t+"Albedo"]),this.texture1=new x.a(i.c,i.c.RGBA).fromImage(getAssets[t+"Roughness"]),this.texture2=new x.a(i.c,i.c.RGBA).fromImage(getAssets[t+"Metallic"]),this.texture3=new x.a(i.c,i.c.RGBA).fromImage(getAssets[t+"Ao"]),this.texture4=new x.a(i.c,i.c.RGBA).fromImage(getAssets[t+"Normal"]))}render(){i.c.clearColor(.3,.3,.3,1),i.c.clearDepth(1),i.c.clear(i.c.COLOR_BUFFER_BIT|i.c.DEPTH_BUFFER_BIT);let t=p.b.identity(p.b.create()),e={vpMatrix:this.tmpMatrix,lightPositions:[-10,10,10,10,10,10,-10,-10,10,10,-10,10],lightColors:new Array(12).fill(300),camPos:this.eyeDirection,lambertDiffuse:this.params.lambertDiffuse};if("none"===this.params.map){this.prg.use(),this.prg.style(Object(o.a)({},e,{albedo:[.5,0,0],ao:1})),this.sphere.bind(this.prg,["position","normal"]);for(let e=0;e<_;e++){this.prg.style({metallic:e/_});for(let n=0;n<N;n++)p.b.translate(t,p.b.create(),[(n-N/2)*y,(e-_/2)*y,0]),this.prg.style({roughness:P(n/N,.05,1),mMatrix:t}),this.sphere.draw()}}else this.mapPrg.use(),this.texture0.bind(0),this.texture1.bind(1),this.texture2.bind(2),this.texture3.bind(3),this.texture4.bind(4),this.mapPrg.style(Object(o.a)({},e,{mMatrix:t,albedoMap:0,roughnessMap:1,metallicMap:2,aoMap:3,normalMap:4})),this.sphere.bind(this.mapPrg),this.sphere.draw()}}function P(t,e,n){return e>n?P(t,n,e):t<e?e:t>n?n:t}},6:function(t,e,n){"use strict";n.r(e),n.d(e,"Torus",function(){return a}),n.d(e,"hsva",function(){return r}),n.d(e,"Sphere",function(){return i}),n.d(e,"plane",function(){return s}),n.d(e,"QuadData",function(){return h}),n.d(e,"TorusKnot",function(){return l}),n.d(e,"regularPolyhedron",function(){return c});var o=n(3);function a(t,e,n,a,i){let s,h=[],l=[],c=[],u=[],m=[];for(let o=0;o<=t;o++){let l=2*Math.PI/t*o,d=Math.cos(l),f=Math.sin(l);for(let l=0;l<=e;l++){m.push(l/e,o/t);let g=2*Math.PI/e*l,p=(d*n+a)*Math.cos(g),v=f*n,b=(d*n+a)*Math.sin(g);h.push(p,v,b),s=i||r(360/e*l,1,1,1),u.push(s[0],s[1],s[2],s[3]);let x=d*Math.cos(g),_=d*Math.sin(g);c.push(x,f,_)}}for(let n=0;n<t;n++)for(let t=0;t<e;t++){let o=(e+1)*n+t;l.push(o,o+e+1,o+1),l.push(o+e+1,o+e+2,o+1)}let d=new o.a;return d.bufferFlattenData(h,"position",3),d.bufferFlattenData(m,"texCoord",2),d.bufferFlattenData(u,"color",4),d.bufferIndex(l),d.bufferFlattenData(c,"normal",3),d}function r(t,e,n,o){if(e>1||n>1||o>1)return;let a=t%360,r=Math.floor(a/60),i=a/60-r,s=n*(1-e),h=n*(1-e*i),l=n*(1-e*(1-i)),c=[];if(!e>0&&!e<0)c.push(n,n,n,o);else{let t=[n,h,s,s,l,n],e=[l,n,n,h,s,s],a=[s,s,l,n,n,h];c.push(t[r],e[r],a[r],o)}return c}function i(t,e,n,o){for(var a=[],i=[],s=[],h=[],l=[],c=0;c<=t;c++)for(var u=Math.PI/t*c,m=Math.cos(u),d=Math.sin(u),f=0;f<=e;f++){var g=2*Math.PI/e*f,p=d*n*Math.cos(g),v=m*n,b=d*n*Math.sin(g),x=d*Math.cos(g),_=d*Math.sin(g);if(o)var N=o;else N=r(360/t*c,1,1,1);a.push(p,v,b),i.push(x,m,_),s.push(N[0],N[1],N[2],N[3]),h.push(1-1/e*f,1/t*c)}for(u=0,c=0;c<t;c++)for(f=0;f<e;f++)u=(e+1)*c+f,l.push(u,u+1,u+e+2),l.push(u,u+e+2,u+e+1);return{pos:a,normal:i,color:s,uv:h,index:l}}function s(t,e,n){const o=t/2,a=n/2;return[o,e,a,0,1,0,1,0,-o,e,-a,0,1,0,0,1,-o,e,a,0,1,0,0,0,o,e,a,0,1,0,1,0,o,e,-a,0,1,0,1,1,-o,e,-a,0,1,0,0,1]}const h=[-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0];function l(){}function c(){}}}]);