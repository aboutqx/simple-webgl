(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{96:function(e,t,i){"use strict";i.r(t),i.d(t,"default",(function(){return h}));var n=i(2),r=i(43),s=i(42),a=i(1),o=i(0);function l(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function c(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?l(Object(i),!0).forEach((function(t){Object(n.a)(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):l(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}const u=[1.6,1.6,1.6],f=[[0,0,0],[2,5,-15],[-2.5,-2.2,-2.5],[-1.8,-2,-12.3],[2.4,-.4,-3.5],[-1.7,3,-7.5],[1.3,-2,-2.5],[1.5,2,-2.5],[2.5,.2,-1.5],[-.9,1,-1.5]];class h extends r.a{constructor(){super(),Object(n.a)(this,"lightPos",void 0)}init(){this.prg=this.basicVert("#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    sampler2D emission;\n    float shininess;\n};\nstruct Light {\n    // vec3 position; // directional light only has direction\n    vec3 direction;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\nin vec3 vPosition;\nin vec3 vNormal;\nin vec2 vTexCoord;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\nvoid main()\n{\n  // ambient\n  vec3 ambient = light.ambient * texture(material.diffuse, vTexCoord).rgb;\n\n  // diffuse\n  vec3 norm = normalize(vNormal);\n  // vec3 lightDir = normalize(light.position - vPosition);\n  vec3 lightDir = normalize(-light.direction);\n  float diff = max(dot(norm, lightDir), 0.0);\n   vec3 diffuse = light.diffuse * diff * texture(material.diffuse, vTexCoord).rgb;\n\n  // specular\n  vec3 viewDir = normalize(camPos - vPosition);\n  vec3 reflectDir = reflect(-lightDir, norm);\n  float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n  vec3 specular = light.specular * spec * texture(material.specular, vTexCoord).rgb;\n\n  vec3 emission = texture(material.emission, vTexCoord).rgb * vec3(.3,.3,7.) * .6;\n\n  vec3 result = ambient + diffuse + specular + emission;\n  FragColor = vec4(result, 1.0);\n}\n"),this.pointPrg=this.basicVert("#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    sampler2D emission;\n    float shininess;\n};\n\nstruct Light {\n    vec3 position;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\n    float constant;\n    float linear;\n    float quadratic;\n};\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec2 vTexCoord;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\nuniform float uTime;\n\nvoid main()\n{\n    // ambient\n    vec3 ambient = light.ambient * texture(material.diffuse, vTexCoord).rgb;\n\n    // diffuse\n    vec3 norm = normalize(vNormal);\n    vec3 lightDir = normalize(light.position - vPosition);\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, vTexCoord).rgb;\n\n    // specular\n    vec3 viewDir = normalize(camPos - vPosition);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * spec * texture(material.specular, vTexCoord).rgb;\n\n    // attenuation\n    float distance    = length(light.position - vPosition);\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n\n    ambient  *= attenuation;\n    diffuse   *= attenuation;\n    specular *= attenuation;\n\n    vec3 emission = texture(material.emission, vTexCoord).rgb * vec3(.3,.3,7.) * .6;\n    emission = emission * (sin(uTime/180.) * 0.5 + 0.5) * 2.0;   \n    vec3 result = ambient + diffuse + specular + emission;\n    FragColor = vec4(result, 1.0);\n}\n"),this.spotPrg=this.basicVert("#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    sampler2D emission;\n    float shininess;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 direction;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\n    float constant;\n    float linear;\n    float quadratic;\n\n    float cutOff;\n    float outerCutOff;\n};\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec2 vTexCoord;\n\nuniform vec3 cameraPos;\nuniform Material material;\nuniform Light light;\n\nvoid main()\n{\n  vec3 result;\n  vec3 lightDir = normalize(light.position - vPosition);\n\n  // ambient\n  vec3 ambient = light.ambient * texture(material.diffuse, vTexCoord).rgb;\n\n  // diffuse\n  vec3 norm = normalize(vNormal);\n\n  float diff = max(dot(norm, lightDir), 0.0);\n  vec3 diffuse = light.diffuse * diff * texture(material.diffuse, vTexCoord).rgb;\n\n  // specular\n  vec3 viewDir = normalize(cameraPos - vPosition);\n  vec3 reflectDir = reflect(-lightDir, norm);\n  float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n  vec3 specular = light.specular * spec * texture(material.specular, vTexCoord).rgb;\n\n  // spotlight (soft edges)\n  float theta = dot(lightDir, normalize(-light.direction)); \n  float epsilon = (light.cutOff - light.outerCutOff);\n  float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);\n  diffuse  *= intensity;\n  specular *= intensity;\n\n  // attenuation\n  float distance    = length(light.position - vPosition);\n  float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n\n  ambient  *= attenuation;\n  diffuse   *= attenuation;\n  specular *= attenuation;\n\n  vec3 emission = texture(material.emission, vTexCoord).rgb * vec3(.3,.3,7.) * .6;\n  result = ambient + diffuse + specular + emission;\n\n  FragColor = vec4(result, 1.0);\n}\n"),this.lampPrg=this.basicColor()}attrib(){this.cube=s.a.cube(1),this.lamp=s.a.sphere(.1,20)}prepare(){this.diffuseTexture=getAssets.cubeSpecular,this.specularTexture=getAssets.cubeSpecular,this.emissionTexture=getAssets.cubeEmission,this.orbital.radius=6}_setGUI(){this.addRadio("pointLight",["directionalLight","pointLight","spotLight"],"light type")}uniform(){}_renderLight(){let e=a.b.create();a.b.scale(e,e,[.5,.5,.5]),a.b.translate(e,e,this.lightPos),this.lampPrg.use(),this.lampPrg.style({mMatrix:e,color:u}),o.a.draw(this.lamp)}_renderCube(e){f.map((t,i)=>{let n=a.b.create();a.b.rotate(n,n,Object(o.d)(20*i),this.lightPos),a.b.translate(n,n,t),a.b.rotate(n,n,Object(o.d)(performance.now()/10),t),e.style({mMatrix:n}),o.a.draw(this.cube)})}render(){o.a.clear(0,0,0);const e={"material.shininess":30,"material.diffuse":this.diffuseTexture,"material.specular":this.specularTexture,"material.emission":this.emissionTexture,"light.ambient":[.1,.1,.1],"light.diffuse":u,"light.specular":[.3,.3,.3]};if(this.params.directionalLight){this.lightPos=[0,0,1].map(e=>20*e);let t=a.e.create();a.e.negate(t,this.lightPos),this.prg.use(),this.prg.style(c(c({},e),{},{"light.direction":t})),this._renderCube(this.prg)}else if(this.params.pointLight)this.pointPrg.use(),this.lightPos=[0,0,-1.5],this.pointPrg.style(c(c({},e),{},{"light.position":this.lightPos,"light.constant":1,"light.linear":.09,"light.quadratic":.032})),this._renderCube(this.pointPrg);else if(this.params.spotLight){this.lightPos=[0,0,1].map(e=>6*e);let t=a.e.create();a.e.negate(t,this.lightPos),this.spotPrg.use(),this.spotPrg.style(c(c({},e),{},{"light.position":this.lightPos,"light.direction":t,"light.cutOff":Math.cos(Object(o.d)(12.5)),"light.outerCutOff":Math.cos(Object(o.d)(15.5)),"light.constant":1,"light.linear":.09,"light.quadratic":.032})),this._renderCube(this.spotPrg)}this._renderLight()}}}}]);