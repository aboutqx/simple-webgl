(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{24:function(i,n){i.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\nuniform vec3 lightColor;\nvoid main()\n{\n    FragColor = vec4(lightColor, 1.0); \n}\n"},25:function(i,n){i.exports="#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nvoid main()\n{\n    gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n}\n"},41:function(i,n,e){"use strict";e.r(n),e.d(n,"default",function(){return M});var t=e(2),a=e(5),r=e(4),o=e(67),s=e.n(o),l=e(68),c=e.n(l),m=e(24),u=e.n(m),f=e(25),d=e.n(f),p=e(1),v=e(0);let h=p.a.identity(p.a.create()),g=p.a.identity(p.a.create());const x=[.33,.42,.18],b=[1,.1,1.5];class M extends a.default{constructor(){super(),Object(t.a)(this,"count",0)}init(){this.prg=this.compile(s.a,c.a),this.lampPrg=this.compile(d.a,u.a)}attrib(){let i=new r.a;i.bufferData([-.5,-.5,-.5,0,0,-1,.5,-.5,-.5,0,0,-1,.5,.5,-.5,0,0,-1,.5,.5,-.5,0,0,-1,-.5,.5,-.5,0,0,-1,-.5,-.5,-.5,0,0,-1,-.5,-.5,.5,0,0,1,.5,-.5,.5,0,0,1,.5,.5,.5,0,0,1,.5,.5,.5,0,0,1,-.5,.5,.5,0,0,1,-.5,-.5,.5,0,0,1,-.5,.5,.5,-1,0,0,-.5,.5,-.5,-1,0,0,-.5,-.5,-.5,-1,0,0,-.5,-.5,-.5,-1,0,0,-.5,-.5,.5,-1,0,0,-.5,.5,.5,-1,0,0,.5,.5,.5,1,0,0,.5,.5,-.5,1,0,0,.5,-.5,-.5,1,0,0,.5,-.5,-.5,1,0,0,.5,-.5,.5,1,0,0,.5,.5,.5,1,0,0,-.5,-.5,-.5,0,-1,0,.5,-.5,-.5,0,-1,0,.5,-.5,.5,0,-1,0,.5,-.5,.5,0,-1,0,-.5,-.5,.5,0,-1,0,-.5,-.5,-.5,0,-1,0,-.5,.5,-.5,0,1,0,.5,.5,-.5,0,1,0,.5,.5,.5,0,1,0,.5,.5,.5,0,1,0,-.5,.5,.5,0,1,0,-.5,.5,-.5,0,1,0],["position","normal"],[3,3]),this.cube=i,this.lampVao=v.d.createVertexArray(),v.d.bindVertexArray(this.lampVao),v.d.bindBuffer(v.d.ARRAY_BUFFER,this.cube._buffers[0].buffer.buffer),v.d.vertexAttribPointer(0,3,v.d.FLOAT,!1,24,0),v.d.enableVertexAttribArray(0)}prepare(){v.d.enable(v.d.DEPTH_TEST),v.d.depthFunc(v.d.LEQUAL),v.d.clearColor(.3,.3,.3,1),v.d.clearDepth(1)}uniform(){let i=[],n=[];p.d.transformQuat(i,[0,0,3],this.rotateQ),p.d.transformQuat(n,[0,1,0],this.rotateQ),this.eyeDirection=i,p.a.lookAt(h,i,[0,0,0],n),p.a.perspective(g,Object(v.e)(60),v.a.clientWidth/v.a.clientHeight,.1,100);let e=p.a.identity(p.a.create());this.prg.use(),this.prg.style({mMatrix:e,vMatrix:h,pMatrix:g,camPos:i,"light.position":b,"material.ambient":[1,.5,.31],"material.diffuse":[1,.5,.31],"material.specular":[.5,.5,.5],"material.shininess":50,"light.ambient":[.2,.2,.2],"light.diffuse":[.5,.5,.5],"light.specular":[1,1,1]})}render(){v.d.clear(v.d.COLOR_BUFFER_BIT|v.d.DEPTH_BUFFER_BIT),this.cube.bind(this.prg,["position","normal"]),this.cube.draw();let i=p.a.identity(p.a.create());p.a.translate(i,i,b),p.a.scale(i,i,[.2,.2,.2]),this.lampPrg.use(),this.lampPrg.style({mMatrix:i,vMatrix:h,pMatrix:g,lightColor:x}),v.d.bindVertexArray(this.lampVao),v.d.drawArrays(v.d.TRIANGLES,0,36)}}},67:function(i,n){i.exports="#version 300 es\n#define GLSLIFY 1\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nout vec3 Normal;\nout vec3 FragPos;\nvoid main()\n{\n  Normal = mat3(transpose(inverse(mMatrix))) * normal; // 法线矩阵 修复不等比缩放\n  FragPos = vec3(mMatrix * vec4(position, 1.0));\n  gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n\n}\n"},68:function(i,n){i.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\nout vec4 FragColor;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\nstruct Light {\n    vec3 position;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\nin vec3 FragPos;\nin vec3 Normal;\n\nuniform vec3 camPos;\nuniform Material material;\nuniform Light light;\n\n\nvoid main()\n{\n  // ambient\n  vec3 ambient = light.ambient * material.ambient;\n\n  // diffuse\n  vec3 norm = normalize(Normal);\n  vec3 lightDir = normalize(light.position - FragPos);\n  float diff = max(dot(norm, lightDir), 0.0);\n  vec3 diffuse = light.diffuse * (diff * material.diffuse);\n\n  // specular\n  vec3 viewDir = normalize(camPos - FragPos);\n  vec3 reflectDir = reflect(-lightDir, norm);\n  float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n  vec3 specular = light.specular * (spec * material.specular);\n\n  vec3 result = ambient + diffuse + specular;\n  FragColor = vec4(result, 1.0);\n}\n"}}]);